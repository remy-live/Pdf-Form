<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pdf Studio</title>

    <script src="ext.js"></script>
    <script src="template.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }

        .canvas-box {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
            background: transparent;
        }

        .os-input {
            background: #ffffff;
            border: 1px solid #d1d1d6;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 12px;
        }

        .os-input:focus {
            border-color: #1c1c1e;
            outline: none;
        }

        /* Tool Button Compact Style */
        .tool-btn {
            width: 100%;
            height: 36px;
            border-radius: 6px;
            transition: 0.1s;
            color: #636366;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            background: #e5e5ea;
            color: #000;
        }

        .tool-btn.active {
            background: #1c1c1e;
            color: #ffffff;
        }

        .tool-btn i {
            font-size: 14px;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            padding: 0;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #d1d1d6;
            border-radius: 4px;
        }

        .align-btn.selected {
            background-color: #e5e5ea;
            color: black;
            border-color: #d1d1d6;
        }

        /* Navigator List Items */
        .nav-item {
            padding: 8px 10px;
            font-size: 11px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            user-select: none;
            transition: background 0.1s;
        }

        .nav-item:hover {
            background: #f9fafb;
        }

        .nav-item.active {
            background: #eff6ff;
            color: #2563eb;
            font-weight: 600;
            border-left: 3px solid #2563eb;
        }

        .nav-item i {
            width: 16px;
            text-align: center;
            color: #9ca3af;
        }

        .nav-item.active i {
            color: #2563eb;
        }

        .nav-item.dragging {
            opacity: 0.5;
            background: #e5e7eb;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            color: #9ca3af;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: 0.2s;
        }

        .tab-btn:hover {
            color: #1c1c1e;
            background: #f9fafb;
        }

        .tab-btn.active {
            color: #1c1c1e;
            border-bottom-color: #1c1c1e;
        }

        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }

        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.2s, transform 0.2s;
        }

        .modal-exit {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s, transform 0.2s;
        }

        .active-tab {
            color: #2563eb;
            /* bleu */
            border-bottom-color: #2563eb;
        }

        .nav-delete-btn {
            margin-left: auto;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            color: #ef4444;
            opacity: 0;
            transition: all 0.2s;
        }

        .nav-delete-btn:hover {
            background-color: #fee2e2;
        }

        .nav-item:hover .nav-delete-btn {
            opacity: 1;
        }

        .bank-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bank-item:hover {
            border-color: #2563eb;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .bank-item:active {
            cursor: grabbing;
        }

        .bank-preview {
            width: 40px;
            height: 40px;
            object-fit: contain;
            background-color: #f3f4f6;
            border-radius: 4px;
        }

        .bank-text-preview {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eff6ff;
            color: #2563eb;
            font-weight: bold;
            font-size: 16px;
            border-radius: 4px;
        }

        .bank-del-btn {
            margin-left: auto;
            color: #ef4444;
            opacity: 0;
            cursor: pointer;
            padding: 4px;
        }

        .bank-item:hover .bank-del-btn {
            opacity: 1;
        }

        .storage-bar-container {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .storage-bar-fill {
            height: 100%;
            background: #2563eb;
            transition: width 0.3s;
        }

        .storage-text {
            font-size: 9px;
            color: #9ca3af;
            margin-top: 2px;
            display: flex;
            justify-content: space-between;
        }

        .bank-name-input {
            width: 100%;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 4px;
            border: 1px solid #3b82f6;
            border-radius: 4px;
            outline: none;
            background: white;
            color: black;
            margin: -3px 0;
        }

        .help-tab {
            border-bottom-width: 2px;
            transition: all 0.2s;
        }

        /* TOAST NOTIFICATIONS */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            /* Laisse passer les clics au travers */
        }

        .toast {
            background: #1c1c1e;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            min-width: 200px;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .toast.success i {
            color: #4ade80;
        }

        /* Vert */
        .toast.info i {
            color: #60a5fa;
        }

        /* Bleu */
        .toast.error i {
            color: #f87171;
        }

        /* --- OUTILS DÉVELOPPEUR (CACHÉS PAR DÉFAUT) --- */
        .dev-btn {
            display: none !important;
        }

        /* Si le body a la classe "codage", on affiche les boutons */
        body.codage .dev-btn {
            display: flex !important;
        }

        /* Rouge */
    </style>
</head>

<body class="bg-bg h-screen w-screen flex flex-col text-text">
    <div id="float-bar"
        class="fixed z-50 bg-white shadow-xl border border-gray-200 rounded-lg p-1 flex items-center gap-1 hidden transform -translate-x-1/2 transition-all duration-100"
        style="top:0; left:0;">
        <select onchange="App.formatText('fontFamily', this.value)" id="wysiwyg-font"
            class="text-[10px] border-r border-gray-200 pr-1 mr-1 outline-none bg-transparent h-6 cursor-pointer max-w-[80px]">
            <option value="Arial">Arial</option>
            <option value="Helvetica">Helvetica</option>
            <option value="Times New Roman">Times</option>
            <option value="Courier New">Courier</option>
        </select>

        <input type="number" id="wysiwyg-size" onchange="App.formatText('size', this.value)"
            class="w-10 text-[10px] border border-gray-200 rounded h-6 text-center outline-none mr-1"
            title="Taille (Globale)" min="6" max="100">

        <div
            class="relative w-6 h-6 rounded overflow-hidden border border-gray-300 cursor-pointer hover:border-gray-400 mr-1">
            <input type="color" id="wysiwyg-color" oninput="App.formatText('color', this.value)"
                class="absolute top-[-50%] left-[-50%] w-[200%] h-[200%] cursor-pointer p-0 border-0"
                title="Couleur du texte">
        </div>

        <div class="w-px h-4 bg-gray-200 mx-1"></div>

        <button onclick="App.formatText('bold')"
            class="w-6 h-6 flex items-center justify-center rounded hover:bg-gray-100 text-gray-700 font-bold text-xs"
            title="Gras">B</button>
        <button onclick="App.formatText('italic')"
            class="w-6 h-6 flex items-center justify-center rounded hover:bg-gray-100 text-gray-700 italic text-xs"
            title="Italique">I</button>
        <button onclick="App.formatText('underline')"
            class="w-6 h-6 flex items-center justify-center rounded hover:bg-gray-100 text-gray-700 underline text-xs"
            title="Souligné">U</button>

        <div class="w-px h-4 bg-gray-200 mx-1"></div>

        <button onclick="App.formatText('align', 'left')"
            class="w-6 h-6 flex items-center justify-center rounded hover:bg-gray-100 text-gray-600"><i
                class="fa-solid fa-align-left text-[10px]"></i></button>
        <button onclick="App.formatText('align', 'center')"
            class="w-6 h-6 flex items-center justify-center rounded hover:bg-gray-100 text-gray-600"><i
                class="fa-solid fa-align-center text-[10px]"></i></button>
        <button onclick="App.formatText('align', 'right')"
            class="w-6 h-6 flex items-center justify-center rounded hover:bg-gray-100 text-gray-600"><i
                class="fa-solid fa-align-right text-[10px]"></i></button>
    </div>

    <div id="modal-overlay"
        class="fixed inset-0 bg-black/40 z-[100] hidden flex items-center justify-center backdrop-blur-sm">
        <div id="modal-box" class="bg-white rounded-xl shadow-2xl w-96 p-5 transform transition-all">
            <h3 id="modal-title" class="text-lg font-bold mb-2">Titre</h3>
            <p id="modal-msg" class="text-sm text-gray-600 mb-5 leading-relaxed">Message...</p>

            <div id="modal-btn-info" class="flex justify-end">
                <button onclick="App.closeModal()"
                    class="bg-gray-800 text-white text-xs font-bold px-4 py-2 rounded hover:bg-black transition">Compris</button>
            </div>

            <div id="modal-btn-confirm" class="flex justify-end gap-2 hidden">
                <button onclick="App.closeModal()"
                    class="text-gray-500 hover:bg-gray-100 text-xs font-bold px-4 py-2 rounded transition">Annuler</button>
                <button id="btn-confirm-yes"
                    class="bg-blue-600 text-white text-xs font-bold px-4 py-2 rounded hover:bg-blue-700 transition">Confirmer</button>
            </div>
        </div>
    </div>

    <header class="h-14 bg-panel border-b border-border flex items-center px-5 justify-between shrink-0 z-20">
        <div class="flex items-center gap-4">
            <div class="font-bold text-lg flex items-center gap-2"><i class="fa-solid fa-cube"></i> Studio</div>
            <div class="h-5 w-px bg-border mx-1"></div>
            <div class="flex items-center ml-4 group">
                <input type="text" id="doc-title" value="Mon_Formulaire"
                    class="bg-transparent text-gray-600 text-sm font-medium px-2 py-1 rounded border border-transparent hover:bg-gray-50 hover:text-gray-900 focus:bg-white focus:text-black focus:ring-1 focus:ring-gray-200 focus:outline-none transition-all duration-300 w-24 focus:w-64 text-right placeholder-gray-400"
                    placeholder="Nom...">

                <span class="text-gray-400 text-xs ml-0.5 pt-0.5 select-none">.pdf</span>

                <i class="fa-solid fa-pencil text-gray-300 text-[10px] ml-2 opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer"
                    onclick="document.getElementById('doc-title').focus()"></i>
            </div>
            <div class="flex gap-1">
                <button onclick="History.undo()"
                    class="w-8 h-8 flex items-center justify-center rounded hover:bg-bg text-slate-500 hover:text-black"
                    title="Annuler (Ctrl+Z)"><i class="fa-solid fa-arrow-rotate-left text-xs"></i></button>
                <button onclick="History.redo()"
                    class="w-8 h-8 flex items-center justify-center rounded hover:bg-bg text-slate-500 hover:text-black"
                    title="Rétablir (Ctrl+Y)"><i class="fa-solid fa-arrow-rotate-right text-xs"></i></button>
            </div>
        </div>

        <div id="toolbar-main" class="flex items-center gap-4 transition-opacity duration-200">

            <div id="toolbar-font" class="flex items-center gap-2 bg-bg px-2 py-1 rounded-lg border border-border">
                <i class="fa-solid fa-font text-[10px] text-gray-400"></i>
                <select id="g-font"
                    class="bg-transparent text-xs font-medium border-none outline-none w-20 cursor-pointer"
                    onchange="App.setStyle('font', this.value)">
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times</option>
                    <option value="Courier New">Courier</option>
                </select>
                <input type="number" id="g-size" value="16"
                    class="bg-transparent text-xs font-medium w-10 text-center outline-none border-none"
                    oninput="App.setStyle('size', this.value)" title="Taille Police">
            </div>

            <div class="flex items-center gap-2 bg-bg px-2 py-1 rounded-lg border border-border">
                <div class="flex flex-col items-center group cursor-pointer relative" title="Couleur Fond">
                    <input type="color" id="g-fill" value="#ffffff" class="w-5 h-5 cursor-pointer absolute opacity-0"
                        oninput="App.setStyle('fill', this.value)">
                    <div class="w-4 h-4 rounded bg-white border border-gray-300 shadow-sm" id="preview-fill"></div>
                </div>
                <div class="flex flex-col items-center group cursor-pointer relative" title="Couleur Bordure">
                    <input type="color" id="g-stroke" value="#000000" class="w-5 h-5 cursor-pointer absolute opacity-0"
                        oninput="App.setStyle('stroke', this.value)">
                    <div class="w-4 h-4 rounded bg-black border border-gray-300 shadow-sm" id="preview-stroke"></div>
                </div>
                <div class="w-px h-4 bg-gray-300"></div>
                <input type="number" id="g-width" value="1" min="0" max="10"
                    class="bg-transparent text-xs font-medium w-8 text-center outline-none border-none"
                    oninput="App.setStyle('width', this.value)" title="Épaisseur Trait">
            </div>

            <div class="flex items-center gap-2 px-2 border-l border-border pl-4">
                <label class="flex items-center gap-2 cursor-pointer select-none border-r border-border pr-3 mr-1">
                    <input type="checkbox" id="g-snap" class="accent-black w-4 h-4 rounded" checked
                        onchange="State.snap=this.checked">
                    <span class="text-[10px] font-bold text-gray-500">AIMANT</span>
                </label>
                <div class="flex items-center gap-3">

                    <span class="text-[9px] font-bold text-gray-400 uppercase" title="Hauteur Champ Texte">
                        Input</span>
                    <input type="number" id="g-def-height" value="24"
                        class="os-input w-12 text-center h-5 p-0 text-[10px]"
                        onchange="State.defaults.defHeight = parseInt(this.value)">

                    <button id="btn-size-painter" onclick="App.setTool('size-painter')"
                        class="mx-2 w-7 h-7 bg-gray-100 hover:bg-black hover:text-white text-gray-500 rounded flex items-center justify-center transition shadow-sm"
                        title="Appliquer la taille par défaut au clic">
                        <i class="fa-solid fa-paintbrush text-xs"></i>
                    </button>


                    <span class="text-[9px] font-bold text-gray-400 uppercase" title="Taille Case / Radio">
                        Box</span>
                    <input type="number" id="g-def-box" value="14" class="os-input w-12 text-center h-5 p-0 text-[10px]"
                        onchange="State.defaults.boxSize = parseInt(this.value)">

                    <label class="flex items-center gap-2 cursor-pointer select-none ml-2">
                        <input type="checkbox" id="g-lock" class="accent-black w-4 h-4 rounded" checked
                            onchange="App.setStyle('lock', this.checked)">
                        <span class="text-[10px] font-bold text-gray-500">FIXE</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-3">
            <button id="btn-flow-toggle" onclick="App.toggleFlowLines()"
                class="flex items-center justify-center w-7 h-7 bg-white border border-gray-200 text-gray-500 rounded hover:text-blue-600 hover:border-blue-400 transition-all"
                title="Afficher/Masquer le parcours de tabulation">
                <i class="fa-solid fa-route text-[11px]"></i>
            </button>
            <button onclick="App.togglePreview()" id="btn-preview"
                class="text-xs font-bold text-gray-500 hover:text-black hover:bg-bg px-3 py-2 rounded transition flex items-center gap-2"
                title="Mode Aperçu">
                <i class="fa-regular fa-eye"></i> </button>
            <button onclick="document.getElementById('file-input').click()"
                class="text-xs font-bold text-gray-500 hover:text-black hover:bg-bg px-3 py-2 rounded transition"
                title="Importer un fichier PDF">PDF</button>

            <button onclick="Exporter.download()"
                class="bg-active text-white text-xs font-bold px-4 py-2 rounded shadow-md hover:bg-gray-800 transition flex items-center gap-2"
                title="Télécharger le document final">Export</button>

            <button
                onclick="if(document.fullscreenElement) document.exitFullscreen(); else document.documentElement.requestFullscreen();"
                class="text-gray-400 hover:text-blue-600 w-8 h-8 rounded-full border border-transparent hover:border-blue-100 hover:bg-blue-50 transition flex items-center justify-center ml-2"
                title="Plein Écran">
                <i class="fa-solid fa-expand"></i>
            </button>
            <button onclick="openDonationModal()"
                class="text-pink-500 hover:text-pink-600  rounded-full hover:bg-pink-50 transition transform hover:scale-110"
                title="Soutenir le projet">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd"
                        d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"
                        clip-rule="evenodd" />
                </svg>
            </button>
            <button onclick="App.toggleHelp()"
                class="text-gray-400 hover:text-blue-600 w-8 h-8 rounded-full border border-transparent hover:border-blue-100 hover:bg-blue-50 transition flex items-center justify-center ml-1"
                title="Centre d'aide et Raccourcis">
                <i class="fa-solid fa-circle-question text-lg"></i>
            </button>
        </div>
    </header>

    <div class="flex flex-1 h-[calc(100vh-56px)]">
        <aside id="sidebar-tools"
            class="w-[220px] bg-panel border-r border-border flex flex-col shrink-0 transition-transform duration-300 z-10">

            <div class="p-2 border-b border-border bg-white">
                <span class="text-[9px] font-bold uppercase text-gray-400 ml-1 mb-2 block">Outils</span>

                <div class="grid grid-cols-4 gap-1">
                    <button onclick="App.setTool('select')" id="btn-select" class="tool-btn active"
                        title="Sélection (V / S)">
                        <i class="fa-solid fa-arrow-pointer"></i>
                    </button>

                    <button onclick="App.setTool('hand')" id="btn-hand" class="tool-btn" title="Déplacer (M / Espace)">
                        <i class="fa-solid fa-hand"></i>
                    </button>

                    <div class="col-span-2"></div>

                    <button onclick="App.setTool('textfield')" id="btn-textfield" class="tool-btn" title="Champ Texte">
                        <i class="fa-solid fa-i-cursor"></i>
                    </button>

                    <button onclick="App.setTool('textarea')" id="btn-textarea" class="tool-btn"
                        title="Paragraphe (Multi-lignes)">
                        <i class="fa-solid fa-paragraph"></i>
                    </button>

                    <button onclick="App.setTool('checkbox')" id="btn-checkbox" class="tool-btn" title="Case à cocher">
                        <i class="fa-regular fa-square-check"></i>
                    </button>

                    <button onclick="App.setTool('radio')" id="btn-radio" class="tool-btn"
                        title="Bouton Radio (Choix unique)">
                        <i class="fa-regular fa-circle-dot"></i>
                    </button>

                    <button onclick="App.setTool('dropdown')" id="btn-dropdown" class="tool-btn" title="Menu Déroulant">
                        <i class="fa-regular fa-square-caret-down"></i>
                    </button>

                    <button onclick="App.setTool('label')" id="btn-label" class="tool-btn"
                        title="Étiquette / Titre (Texte fixe)">
                        <i class="fa-solid fa-heading"></i>
                    </button>
                    <button onclick="App.setTool('paragraph')" id="btn-paragraph" class="tool-btn"
                        title="Texte Riche (Notice/Statuts)">
                        <i class="fa-solid fa-align-justify"></i>
                    </button>
                    <button onclick="App.setTool('rect')" id="btn-rect" class="tool-btn" title="Rectangle (Dessin)">
                        <i class="fa-regular fa-square"></i>
                    </button>

                    <button onclick="App.setTool('circle')" id="btn-circle" class="tool-btn" title="Cercle (Dessin)">
                        <i class="fa-regular fa-circle"></i>
                    </button>

                    <button onclick="App.setTool('line')" id="btn-line" class="tool-btn" title="Ligne (Dessin)">
                        <i class="fa-solid fa-minus"></i>
                    </button>
                </div>
            </div>

            <div class="px-3 py-2 bg-gray-50 border-b border-border flex justify-between items-center shrink-0">
                <span class="text-[10px] font-bold uppercase text-gray-400">Ordre</span>

                <div class="flex items-center gap-2">
                    <button onclick="App.autoSort()"
                        class="bg-white border border-gray-200 text-gray-600 hover:text-blue-600 hover:border-blue-300 text-[10px] px-2 py-1 rounded flex items-center gap-1.5 transition shadow-sm"
                        title="Tri Automatique (Haut vers Bas)">
                        <i class="fa-solid fa-arrow-down-z-a"></i> Auto
                    </button>

                    <button onclick="App.toggleSequenceMode()" id="btn-seq"
                        class="bg-white border border-gray-200 text-gray-600 hover:text-orange-600 hover:border-orange-300 text-[10px] px-2 py-1 rounded flex items-center gap-1.5 transition shadow-sm"
                        title="Définir l'ordre manuellement">
                        <i class="fa-solid fa-arrow-down-1-9"></i> Séquence
                    </button>
                </div>
            </div>

            <div id="navigator-list" class="flex-1 overflow-y-auto overflow-x-hidden bg-white scrollbar-thin">
            </div>

            <div class="p-2 border-t border-border grid grid-cols-3 gap-2 bg-gray-50 shrink-0">

                <button onclick="Project.new()"
                    class="tool-btn text-[10px] h-8 bg-slate-100 border border-slate-300 text-slate-700 hover:bg-slate-200 hover:text-black hover:border-slate-400 font-medium"
                    title="Nouveau Projet (Tout effacer)">
                    <i class="fa-solid fa-file-circle-plus"></i>
                </button>

                <button onclick="Project.save()"
                    class="tool-btn text-[10px] h-8 bg-slate-100 border border-slate-300 text-slate-700 hover:bg-slate-200 hover:text-black hover:border-slate-400 font-medium"
                    title="Sauvegarder Projet (Ctrl+S)">
                    <i class="fa-solid fa-floppy-disk"></i>
                </button>

                <button onclick="document.getElementById('project-input').click()"
                    class="tool-btn text-[10px] h-8 bg-slate-100 border border-slate-300 text-slate-700 hover:bg-slate-200 hover:text-black hover:border-slate-400 font-medium"
                    title="Ouvrir Projet">
                    <i class="fa-solid fa-folder-open"></i>
                </button>
            </div>
        </aside>

        <main id="workspace" class="flex-1 bg-[#d4d4d8] relative overflow-hidden flex justify-center items-center">
            <div class="canvas-box relative"><canvas id="c"></canvas></div>

            <div id="page-nav"
                class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-white border border-gray-200 px-4 py-2 rounded-full shadow-lg flex items-center gap-4 z-50 hidden">
                <button onclick="App.changePage(-1)" class="hover:text-blue-600 transition" title="Page Précédente">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <span id="page-indicator" class="text-xs font-bold w-20 text-center font-mono text-gray-600">Page 1 /
                    1</span>
                <button onclick="App.changePage(1)" class="hover:text-blue-600 transition" title="Page Suivante">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
            </div>

            <div class="absolute bottom-4 left-4 flex items-center gap-3 z-50">

                <div class="flex items-center bg-white border border-gray-200 rounded-md shadow-sm overflow-hidden">
                    <button onclick="App.setZoom(-0.1)"
                        class="w-8 h-8 flex items-center justify-center hover:bg-gray-50 text-gray-600 active:bg-gray-100 border-r border-gray-200 transition"
                        title="Dézoomer (-)">
                        <i class="fa-solid fa-minus text-xs"></i>
                    </button>

                    <button onclick="App.resetZoom()"
                        class="px-2 h-8 flex items-center justify-center hover:bg-gray-50 text-gray-600 text-[10px] font-bold font-mono active:bg-gray-100 min-w-[50px] transition"
                        title="Réinitialiser (100%)">
                        100%
                    </button>

                    <button onclick="App.setZoom(0.1)"
                        class="w-8 h-8 flex items-center justify-center hover:bg-gray-50 text-gray-600 active:bg-gray-100 border-l border-gray-200 transition"
                        title="Zoomer (+)">
                        <i class="fa-solid fa-plus text-xs"></i>
                    </button>
                </div>

                <div id="coord-display"
                    class="bg-white border border-gray-200 px-3 py-1.5 rounded-md shadow-sm text-[10px] font-mono text-gray-500 min-w-[80px] text-center select-none cursor-default">
                    x: 0 | y: 0
                </div>
            </div>
        </main>

        <aside id="panel-right"
            class="w-72 bg-panel border-l border-border flex flex-col shrink-0 z-10 transition-transform duration-300">
            <div class="flex border-b border-border bg-gray-50">
                <div class="flex border-b border-border bg-gray-50">
                    <button onclick="App.setSideTab('props')" id="tab-btn-props"
                        class="tab-btn active">Propriétés</button>
                    <button onclick="App.setSideTab('bank')" id="tab-btn-bank" class="tab-btn">Banque</button>
                    <button onclick="App.setSideTab('templates')" id="tab-btn-templates"
                        class="tab-btn">Modèles</button>
                </div>
            </div>

            <div id="view-props" class="flex-1 flex flex-col overflow-hidden">
                <div id="panel-empty"
                    class="flex-1 flex flex-col items-center justify-center text-gray-300 p-6 text-center">
                    <i class="fa-regular fa-object-group text-3xl mb-3 opacity-30"></i>
                    <p class="text-xs">Sélectionnez un objet</p>
                </div>

                <div id="panel-content" class="flex-1 overflow-y-auto p-5 hidden flex flex-col gap-6">

                    <div id="batch-radio-section"
                        class="hidden flex-col gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                        <span class="text-[10px] font-bold uppercase text-blue-400">Groupe Radio</span>
                        <p class="text-[10px] text-blue-800 mb-1">Associer ces boutons au même groupe ?</p>
                        <div class="flex gap-2">
                            <input type="text" id="batch-grp-name" class="os-input flex-1 bg-white border-blue-200"
                                placeholder="Nom du groupe commun">
                            <button onclick="App.applyBatchGroup()"
                                class="bg-blue-600 text-white text-[10px] font-bold px-3 rounded hover:bg-blue-700 transition">OK</button>
                        </div>
                    </div>

                    <div id="sec-align" class="hidden flex-col gap-2 p-2 bg-gray-50 rounded-lg border border-gray-200">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Alignement</span>
                        <div class="grid grid-cols-4 gap-1">
                            <button onclick="App.align('left')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Gauche"><i class="fa-solid fa-align-left"></i></button>
                            <button onclick="App.align('center')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Centre Horizontal"><i class="fa-solid fa-align-center"></i></button>
                            <button onclick="App.align('right')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Droite"><i class="fa-solid fa-align-right"></i></button>
                            <button onclick="App.align('dist-h')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Distribuer Horizontal"><i class="fa-solid fa-arrows-left-right"></i></button>

                            <button onclick="App.align('top')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Haut"><i class="fa-solid fa-align-left"
                                    style="transform: rotate(90deg);"></i></button>
                            <button onclick="App.align('middle')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Milieu Vertical"><i class="fa-solid fa-align-center"
                                    style="transform: rotate(90deg);"></i></button>
                            <button onclick="App.align('bottom')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Bas"><i class="fa-solid fa-align-right"
                                    style="transform: rotate(90deg);"></i></button>
                            <button onclick="App.align('dist-v')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Distribuer Vertical"><i class="fa-solid fa-arrows-left-right"
                                    style="transform: rotate(90deg);"></i></button>
                        </div>
                    </div>

                    <div id="sec-config" class="flex flex-col gap-3">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Config</span>
                        <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">ID</span><input type="text" id="p-id"
                                class="os-input font-mono text-xs bg-gray-50"></div>

                        <div id="row-font-size" class="grid grid-cols-[60px_1fr] items-center gap-2">
                            <span class="text-xs font-medium">Police</span>
                            <div class="flex items-center gap-2">
                                <input type="number" id="p-font-size" class="os-input w-16 text-center" min="6"
                                    max="100">
                                <span class="text-[10px] text-gray-400">px</span>
                            </div>
                        </div>
                        <div id="row-format" class="grid grid-cols-[60px_1fr] items-center gap-2">
                            <span class="text-xs font-medium">Format</span>
                            <select id="p-fmt" class="os-input">
                                <option value="text">Texte</option>
                                <option value="number">Nombre (€)</option>
                                <option value="date">Date</option>
                            </select>
                        </div>
                        <div id="row-align" class="grid grid-cols-[60px_1fr] items-center gap-2">
                            <span class="text-xs font-medium">Texte</span>
                            <div class="flex bg-gray-50 p-0.5 rounded border border-gray-200">
                                <button id="p-align-left" onclick="Panel.apply('textAlign', 'left')"
                                    class="align-btn flex-1 py-1 rounded hover:bg-white text-[10px] border border-transparent"><i
                                        class="fa-solid fa-align-left"></i></button>
                                <button id="p-align-center" onclick="Panel.apply('textAlign', 'center')"
                                    class="align-btn flex-1 py-1 rounded hover:bg-white text-[10px] border border-transparent"><i
                                        class="fa-solid fa-align-center"></i></button>
                                <button id="p-align-right" onclick="Panel.apply('textAlign', 'right')"
                                    class="align-btn flex-1 py-1 rounded hover:bg-white text-[10px] border border-transparent"><i
                                        class="fa-solid fa-align-right"></i></button>
                            </div>
                        </div>

                        <div id="sub-radio" class="hidden flex-col gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                            <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                    class="text-xs">Groupe</span><input type="text" id="p-grp" class="os-input bg-white"
                                    placeholder="Nom du groupe"></div>
                            <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                    class="text-xs">Valeur</span><input type="text" id="p-val"
                                    class="os-input bg-white"></div>
                        </div>
                        <div id="sub-dropdown"
                            class="hidden flex-col gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                            <div class="grid grid-cols-[60px_1fr] items-center gap-2">
                                <span class="text-xs font-medium">Défaut</span>
                                <select id="p-dropdown-val" class="os-input bg-white h-6 p-0 px-1">
                                </select>
                            </div>

                            <div class="flex flex-col gap-1">
                                <span class="text-xs font-medium">Options (1/ligne)</span>
                                <textarea id="p-opts"
                                    class="os-input h-24 resize-none font-mono text-[10px] leading-tight"
                                    placeholder="Option 1&#10;Option 2..."></textarea>
                            </div>
                        </div>
                        <div class="flex gap-4 mt-1"><label
                                class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                    id="p-req" class="accent-black"> <span class="text-xs">Requis</span></label><label
                                class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                    id="p-read" class="accent-black"> <span class="text-xs">Lecture Seule</span></label>
                        </div>
                        <hr class="border-t border-border mt-2">
                    </div>
                    <div class="flex flex-col gap-3">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Apparence</span>
                        <div id="row-fill-check" class="flex items-center justify-between mb-1 hidden"><span
                                class="text-xs font-medium">Remplissage</span><label
                                class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                    id="p-has-fill" class="accent-black"> <span
                                    class="text-xs text-gray-500">Actif</span></label></div>
                        <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">Couleurs</span>
                            <div class="flex gap-2 w-full">
                                <div id="box-fill"
                                    class="flex-1 flex items-center border border-gray-300 rounded px-2 bg-white"><span
                                        class="text-[9px] mr-2 text-gray-400">FOND</span><input type="color" id="p-fill"
                                        class="w-full h-6 cursor-pointer"></div>
                                <div class="flex-1 flex items-center border border-gray-300 rounded px-2 bg-white"><span
                                        class="text-[9px] mr-2 text-gray-400">BORD</span><input type="color"
                                        id="p-stroke" class="w-full h-6 cursor-pointer"></div>
                            </div>
                        </div>
                        <div id="row-opacity" class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">Opacité</span>
                            <div class="flex items-center gap-2 w-full"><input type="range" id="p-opacity" min="0"
                                    max="1" step="0.1" class="flex-1"><span class="text-[10px] font-mono w-8 text-right"
                                    id="p-opacity-val">100%</span></div>
                        </div>
                        <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">Bordure</span>
                            <div class="flex gap-2 w-full"><input type="number" id="p-width" min="0" max="20"
                                    class="os-input w-14 text-center"><select id="p-bstyle" class="os-input flex-1">
                                    <option value="solid">Trait Plein</option>
                                    <option value="underline">Souligné</option>
                                    <option value="none">Invisible</option>
                                </select></div>
                        </div>
                    </div>
                    <div id="sub-check" class="hidden p-2 bg-gray-50 border border-gray-200 rounded"><label
                            class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                id="p-checked" class="accent-black w-4 h-4"> <span
                                class="text-xs font-bold text-gray-700">Coché par
                                défaut</span></label></div>

                    <div id="sec-dims" class="flex flex-col gap-2 pt-4 border-t border-border">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Dimensions (px)</span>
                        <div class="flex items-end gap-2">
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Largeur (W)</span>
                                <input type="number" id="p-dim-w" class="os-input w-full">
                            </div>
                            <button id="btn-ratio" onclick="Panel.toggleRatio()"
                                class="h-8 w-8 mb-[1px] rounded hover:bg-gray-100 text-gray-400 flex items-center justify-center transition"
                                title="Lier les proportions">
                                <i class="fa-solid fa-link-slash"></i>
                            </button>
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Hauteur (H)</span>
                                <input type="number" id="p-dim-h" class="os-input w-full">
                            </div>
                        </div>
                        <div class="flex items-end gap-2 mt-2">
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Pos X</span>
                                <input type="number" id="p-pos-x" class="os-input w-full">
                            </div>
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Pos Y</span>
                                <input type="number" id="p-pos-y" class="os-input w-full">
                            </div>
                        </div>
                    </div>
                    <div class="mt-auto pt-4"><button onclick="App.deleteSelection()"
                            class="w-full bg-white text-red-500 border border-red-100 hover:bg-red-50 py-2 rounded text-xs font-bold transition shadow-sm">Supprimer</button>
                    </div>
                </div>
            </div>

            <div id="view-bank" class="hidden flex-1 flex flex-col p-4 gap-4 overflow-y-auto bg-gray-50">

                <div class="bg-white border border-dashed border-blue-300 p-4 rounded-lg flex flex-col items-center justify-center text-center gap-2 hover:bg-blue-50 transition cursor-pointer"
                    onclick="document.getElementById('img-input-bank').click()">
                    <div class="h-8 w-8 bg-blue-100 rounded-full flex items-center justify-center text-blue-600">
                        <i class="fa-solid fa-cloud-arrow-up"></i>
                    </div>
                    <div class="text-[10px] text-blue-800 font-bold uppercase">Importer Image</div>
                    <p class="text-[9px] text-gray-400">JPG, PNG supportés</p>
                </div>

                <div class="bg-white border border-gray-200 p-3 rounded-lg flex flex-col gap-2">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Création</span>
                    <button onclick="Bank.addFromSelection()"
                        class="bg-black text-white text-[10px] font-bold py-2 rounded hover:bg-gray-800 transition w-full flex items-center justify-center gap-2">
                        <i class="fa-solid fa-star"></i> Sauver la sélection
                    </button>
                    <p class="text-[9px] text-gray-400 italic text-center">Sélectionnez un texte stylisé sur le PDF et
                        cliquez ici pour le garder en mémoire.</p>
                </div>

                <hr class="border-gray-200">
                <div class="flex justify-between items-center">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Ma Bibliothèque</span>
                    <div class="flex gap-1">
                        <button onclick="Bank.exportBank()"
                            class="text-[10px] text-blue-600 hover:bg-blue-50 px-2 py-0.5 rounded border border-transparent hover:border-blue-100 transition"
                            title="Exporter ma banque (.json)">
                            <i class="fa-solid fa-download"></i>
                        </button>
                        <button onclick="document.getElementById('bank-file-input').click()"
                            class="text-[10px] text-blue-600 hover:bg-blue-50 px-2 py-0.5 rounded border border-transparent hover:border-blue-100 transition"
                            title="Importer une banque">
                            <i class="fa-solid fa-upload"></i>
                        </button>
                    </div>
                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <button onclick="Bank.exportDev()"
                            class="dev-btn bg-purple-600 text-white text-[10px] font-bold py-2 rounded hover:bg-purple-700 transition w-full flex items-center justify-center gap-2 border border-purple-800 shadow-lg">
                            <i class="fa-solid fa-database"></i> COPIER TOUTE LA BANQUE (DEV)
                        </button>
                    </div>
                </div>
                <div class="flex flex-col gap-2">
                    <div id="bank-list" class="flex flex-col pb-4">
                        <div class="text-xs text-gray-400 text-center italic py-4">Vide pour l'instant</div>
                    </div>
                </div>
            </div>

            <div id="view-templates" class="hidden flex-1 flex flex-col p-4 gap-4 overflow-y-auto bg-gray-50">

                <div class="bg-white border border-blue-200 p-3 rounded-lg flex flex-col gap-2 shadow-sm">
                    <span class="text-[10px] font-bold uppercase text-blue-500">Nouveau Modèle</span>
                    <button onclick="Templates.saveFromCurrentPage()"
                        class="bg-blue-600 text-white text-[10px] font-bold py-2 rounded hover:bg-blue-700 transition w-full flex items-center justify-center gap-2">
                        <i class="fa-solid fa-floppy-disk"></i> Sauver la page actuelle
                    </button>

                    <button onclick="Templates.exportDev()"
                        class="dev-btn mt-2 bg-purple-600 text-white text-[10px] font-bold py-2 rounded hover:bg-purple-700 transition w-full flex items-center justify-center gap-2 border border-purple-800 shadow-lg">
                        <i class="fa-solid fa-code"></i> COPIER CODE (DEV)
                    </button>
                    <p class="text-[9px] text-gray-400 italic text-center">Crée un modèle à partir de votre travail
                        actuel.</p>
                </div>

                <hr class="border-gray-200">

                <div class="flex flex-col gap-2">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Bibliothèque</span>
                    <input type="text" placeholder="Rechercher..." oninput="Templates.filter(this.value)"
                        class="os-input bg-white mb-2">

                    <div id="template-list" class="grid grid-cols-1 gap-3 pb-4">
                    </div>
                </div>
            </div>

            <input type="file" id="img-input-bank" class="hidden" accept="image/png, image/jpeg, image/jpg">
        </aside>
    </div>

    <input type="file" id="file-input" class="hidden" accept="application/pdf">
    <input type="file" id="project-input" class="hidden" accept=".json">
    <input type="file" id="img-input" class="hidden" accept="image/png, image/jpeg, image/jpg">
    <div id="help-overlay"
        class="fixed inset-0 bg-black/50 z-[200] hidden flex items-center justify-center backdrop-blur-sm transition-opacity">
        <div class="bg-white rounded-xl shadow-2xl w-[600px] h-[500px] flex flex-col overflow-hidden transform scale-95 transition-transform duration-200"
            id="help-box">

            <div class="px-6 py-4 border-b border-gray-100 flex justify-between items-center bg-gray-50">
                <h3 class="font-bold text-gray-800 flex items-center gap-2"><i
                        class="fa-solid fa-graduation-cap text-blue-500"></i> Centre d'Aide</h3>
                <button onclick="App.toggleHelp()" class="text-gray-400 hover:text-black transition"><i
                        class="fa-solid fa-xmark text-lg"></i></button>
            </div>

            <div class="flex border-b border-gray-200 px-6 gap-6 text-sm font-medium text-gray-500">
                <button onclick="App.setHelpTab('tuto')" id="ht-tuto"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600 active-tab">Tutoriel</button>
                <button onclick="App.setHelpTab('shortcuts')" id="ht-shortcuts"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600">Raccourcis</button>
                <button onclick="App.setHelpTab('tools')" id="ht-tools"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600">Fonctionnalités</button>
                <button onclick="App.setHelpTab('faq')" id="ht-faq"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600">FAQ</button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 bg-white text-sm text-gray-600">

                <div id="hc-tuto" class="help-content space-y-6">
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            1</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Importer</h4>
                            <p class="text-xs text-gray-500 mt-1">Cliquez sur <b
                                    class="bg-gray-100 px-1 rounded">PDF</b> pour charger votre document, ou commencez
                                sur une page blanche.</p>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            2</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Ajouter les Champs</h4>
                            <p class="text-xs text-gray-500 mt-1">Utilisez la barre de gauche pour ajouter des zones de
                                texte, cases à cocher, etc. Placez-les là où l'utilisateur devra écrire.</p>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            3</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Définir l'Ordre</h4>
                            <p class="text-xs text-gray-500 mt-1">Activez le bouton <b
                                    class="bg-gray-100 px-1 rounded">Séquence</b> et cliquez sur vos champs dans l'ordre
                                (1, 2, 3...) pour définir le trajet de la touche Tabulation.</p>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            4</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Exporter</h4>
                            <p class="text-xs text-gray-500 mt-1">Cliquez sur <b
                                    class="bg-black text-white px-1 rounded">Export</b> pour télécharger votre PDF
                                final, prêt à être rempli !</p>
                        </div>
                    </div>
                </div>

                <div id="hc-shortcuts" class="help-content hidden space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-3 rounded border border-gray-100">
                            <span class="block text-xs font-bold text-gray-400 uppercase mb-2">Outils</span>
                            <div class="flex justify-between mb-1"><span>Sélection (Flèche)</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">V / S</code>
                            </div>
                            <div class="flex justify-between mb-1"><span>Main (Pan)</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">M</code>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded border border-gray-100">
                            <span class="block text-xs font-bold text-gray-400 uppercase mb-2">Navigation</span>
                            <div class="flex justify-between mb-1"><span>Déplacer</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Espace
                                    + Clic</code>
                            </div>
                            <div class="flex justify-between mb-1"><span>Zoomer</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Molette</code>
                            </div>
                            <div class="flex justify-between mb-1"><span>Précision</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Flèches</code>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded border border-gray-100 col-span-2">
                            <span class="block text-xs font-bold text-gray-400 uppercase mb-2">Action</span>
                            <div class="grid grid-cols-2 gap-x-8">
                                <div class="flex justify-between mb-1"><span>Annuler</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + Z</code></div>
                                <div class="flex justify-between mb-1"><span>Rétablir</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + Y</code></div>
                                <div class="flex justify-between mb-1"><span>Copier / Coller</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + C / V</code></div>
                                <div class="flex justify-between mb-1"><span>Dupliquer</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + D</code></div>
                                <div class="flex justify-between mb-1"><span>Tout Sélectionner</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + A</code></div>
                                <div class="flex justify-between mb-1"><span>Sauvegarder</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + S</code></div>
                                <div class="flex justify-between mb-1"><span>Supprimer</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Suppr</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="hc-tools" class="help-content hidden space-y-4">
                    <div class="flex gap-4">
                        <div
                            class="w-10 h-10 bg-blue-50 text-blue-600 rounded flex items-center justify-center shrink-0">
                            <i class="fa-solid fa-file-pen"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Champs de Formulaire</h4>
                            <p class="text-xs text-gray-500 mt-1 leading-relaxed">
                                Créez des champs interactifs pour le PDF final :
                                <br>• <b>Champ Texte (I)</b> : Pour les noms, adresses...
                                <br>• <b>Paragraphe (¶)</b> : Pour les textes longs (multilignes).
                                <br>• <b>Check / Radio</b> : Cases à cocher et choix uniques.
                                <br>• <b>Menu Déroulant</b> : Liste de choix.
                            </p>
                        </div>
                    </div>
                    <hr class="border-gray-100">
                    <div class="flex gap-4">
                        <div
                            class="w-10 h-10 bg-orange-100 text-orange-600 rounded flex items-center justify-center shrink-0">
                            <i class="fa-solid fa-arrow-down-1-9"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Ordre de Tabulation</h4>
                            <p class="text-xs text-gray-500 mt-1 leading-relaxed">
                                Contrôlez l'ordre dans lequel l'utilisateur passe d'un champ à l'autre (touche Tab).
                                <br>• <b>Mode Séquence</b> : Cliquez sur vos champs dans l'ordre (1, 2, 3...).
                                <br>• <b>Vue Flux (Route)</b> : Affiche des flèches bleues pour visualiser le parcours.
                                <br>• <b>Liste Latérale</b> : Glissez-déposez les calques pour réorganiser l'ordre.
                            </p>
                        </div>
                    </div>
                    <hr class="border-gray-100">
                    <div class="flex gap-4">
                        <div
                            class="w-10 h-10 bg-purple-100 text-purple-600 rounded flex items-center justify-center shrink-0">
                            <i class="fa-solid fa-shapes"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Banque & Dessin</h4>
                            <p class="text-xs text-gray-500 mt-1 leading-relaxed">
                                • <b>Dessin</b> : Ajoutez des rectangles, cercles, lignes ou images pour décorer ou
                                masquer
                                des zones.
                                <br>• <b>Banque (Modèles)</b> : Sauvegardez vos champs complexes (ex: un groupe de
                                boutons
                                Radio pré-configuré) pour les réutiliser sur d'autres pages ou projets.
                            </p>
                        </div>
                    </div>
                </div>

                <div id="hc-faq" class="help-content hidden space-y-4">
                    <div class="p-3 bg-red-50 rounded border border-red-100">
                        <h4 class="font-bold text-red-800 text-xs mb-1">Pourquoi je ne peux pas tourner les champs ?
                        </h4>
                        <p class="text-xs text-red-600">La rotation est volontairement bloquée sur les champs de
                            formulaire
                            (Input, Checkbox...) car la plupart des lecteurs PDF ne supportent pas la saisie de texte en
                            biais. Seuls les dessins (rectangles, cercles) peuvent être tournés.</p>
                    </div>
                    <div class="p-3 bg-blue-50 rounded border border-blue-100">
                        <h4 class="font-bold text-blue-800 text-xs mb-1">Champs Transparents</h4>
                        <p class="text-xs text-blue-600">Pour rendre un champ invisible à l'impression (fond
                            transparent),
                            sélectionnez-le et décochez la case <b>"Actif"</b> dans la section Remplissage (panneau de
                            droite).</p>
                    </div>
                    <div class="p-3 bg-gray-50 rounded border border-gray-200">
                        <h4 class="font-bold text-gray-800 text-xs mb-1">Sauvegarde & Export</h4>
                        <p class="text-xs text-gray-500">
                            • <b>Sauvegarder (.json)</b> : Garde tout éditable (calques, ordre, historique).
                            <br>• <b>Export PDF</b> : Génère le fichier final utilisable. Les champs seront calés au
                            pixel
                            près par rapport au fond.
                        </p>
                    </div>
                </div>

            </div>

            <div class="p-4 border-t border-gray-100 bg-gray-50 text-center">
                <button onclick="App.toggleHelp()"
                    class="bg-gray-800 hover:bg-black text-white px-6 py-2 rounded text-xs font-bold transition">Fermer</button>
            </div>
        </div>
    </div>
    <div id="context-menu"
        class="fixed bg-white shadow-xl border border-gray-200 rounded-lg py-1 z-[300] hidden w-40 text-xs">
        <button onclick="App.duplicate(); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2"><i
                class="fa-regular fa-copy"></i> Dupliquer</button>
        <button onclick="App.deleteSelection(); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-red-50 text-red-600 flex items-center gap-2"><i
                class="fa-solid fa-trash"></i> Supprimer</button>
        <div class="h-px bg-gray-100 my-1"></div>
        <button onclick="State.canvas.sendBackwards(State.canvas.getActiveObject()); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-gray-100">Reculer</button>
        <button onclick="State.canvas.bringForward(State.canvas.getActiveObject()); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-gray-100">Avancer</button>
    </div>
    <div id="toast-container"></div>
    <script>
        // --- CONFIGURATION DE LA BANQUE PAR DÉFAUT ---

        document.addEventListener('DOMContentLoaded', () => {
            App.init();
            Bank.init();
            Templates.init();
        });
        if (window.fabric) {
            fabric.Object.prototype.set({ transparentCorners: false, cornerColor: '#1c1c1e', cornerStyle: 'circle', cornerSize: 8, borderColor: '#1c1c1e' });
            fabric.Text.prototype.textBaseline = 'top'; fabric.IText.prototype.textBaseline = 'top'; fabric.Textbox.prototype.textBaseline = 'top';
        }


        const customProps = ['ctype', 'pid', 'grp', 'val', 'opts', 'bStyle', 'isChecked', 'fmt', 'tAlign', 'lockScalingX', 'lockScalingY', 'srcObj', 'id', 'isBackground', 'evented', 'selectable', 'isRequired', 'isReadOnly', 'fontWeight', 'fontStyle', 'underline', 'styles'];

        const Templates = {
            items: [],

            init: () => {
                const staticTpls = (typeof APP_MODELS !== 'undefined') ? APP_MODELS : [];
                let userTpls = [];
                try { userTpls = JSON.parse(localStorage.getItem('pdf_studio_user_templates') || '[]'); } catch (e) { }
                Templates.items = [...userTpls, ...staticTpls];
                Templates.render();
            },

            render: (filterText = '') => {
                const container = document.getElementById('template-list');
                if (!container) return;
                container.innerHTML = '';

                const list = Templates.items.filter(t => t.name.toLowerCase().includes(filterText.toLowerCase()));
                if (list.length === 0) { container.innerHTML = '<div class="text-xs text-gray-400 text-center italic">Aucun modèle</div>'; return; }

                list.forEach(tpl => {
                    const isUser = !tpl.id.startsWith('tpl_');
                    const el = document.createElement('div');
                    el.className = 'group relative bg-white border border-gray-200 rounded-lg overflow-hidden hover:shadow-md transition cursor-pointer';

                    const delBtn = isUser ? `<button onclick="event.stopPropagation(); Templates.delete('${tpl.id}')" class="absolute top-1 right-1 bg-white text-red-500 w-5 h-5 flex items-center justify-center rounded shadow opacity-0 group-hover:opacity-100 transition"><i class="fa-solid fa-trash text-[10px]"></i></button>` : '';

                    el.innerHTML = `
        <div class="h-24 bg-gray-100 overflow-hidden relative">
            <img src="${tpl.thumbnail || ''}" class="w-full h-full object-cover opacity-80 group-hover:opacity-100 transition">
            <div class="absolute bottom-0 left-0 bg-black/50 text-white text-[9px] px-2 py-0.5 rounded-tr">${tpl.category || 'Général'}</div>
        </div>
        <div class="p-2 border-t border-gray-100">
            <div class="font-bold text-xs text-gray-700 truncate">${tpl.name}</div>
            <div class="text-[9px] text-gray-400 flex justify-between mt-1"><span>${isUser ? 'Personnel' : 'Officiel'}</span><span>${tpl.objects ? tpl.objects.length : 0} objets</span></div>
        </div>${delBtn}`;
                    el.onclick = () => Templates.apply(tpl.id);
                    container.appendChild(el);
                });
            },

            // --- SAUVEGARDE ROBUSTE (BASÉE SUR LE FOND) ---
            saveFromCurrentPage: () => {
                const pageObjects = State.canvas.getObjects().filter(o => !o.isBackground && !o.isGuide);
                if (pageObjects.length === 0) { App.showToast("Page vide !", "error"); return; }

                // 1. TROUVER LE FOND BLANC (L'ANCRE)
                const bg = State.canvas.getObjects().find(o => o.isBackground);
                // Si pas de fond (cas rare), on prend 0,0
                const refX = bg ? bg.left : 0;
                const refY = bg ? bg.top : 0;

                const name = prompt("Nom du modèle :", "Mon Formulaire");
                if (!name) return;

                const thumb = State.canvas.toDataURL({ format: 'png', multiplier: 0.2 });

                // 2. CALCUL RELATIF
                const objects = pageObjects.map(o => {
                    const json = o.toObject(customProps);
                    // On enregistre la position relative au coin du fond blanc
                    json.left = o.left - refX;
                    json.top = o.top - refY;
                    return json;
                });

                const newTpl = { id: 'user_' + Date.now(), name: name, category: 'Perso', thumbnail: thumb, objects: objects };

                const userTpls = JSON.parse(localStorage.getItem('pdf_studio_user_templates') || '[]');
                userTpls.unshift(newTpl);
                localStorage.setItem('pdf_studio_user_templates', JSON.stringify(userTpls));

                App.showToast("Modèle sauvegardé !", "success");
                Templates.init();
            },

            delete: (id) => {
                App.askConfirm("Supprimer", "Voulez-vous supprimer ce modèle ?", () => {
                    let userTpls = JSON.parse(localStorage.getItem('pdf_studio_user_templates') || '[]');
                    userTpls = userTpls.filter(t => t.id !== id);
                    localStorage.setItem('pdf_studio_user_templates', JSON.stringify(userTpls));
                    Templates.init();
                    App.showToast("Modèle supprimé", "success");
                });
            },

            // --- APPLICATION ROBUSTE (BASÉE SUR LE FOND) ---
            apply: (id) => {
                const tpl = Templates.items.find(t => t.id === id);
                if (!tpl) return;

                App.askConfirm("Appliquer le modèle", "Remplacer le contenu actuel ?", () => {
                    // 1. On ferme la modale TOUT DE SUITE pour rendre la main à l'interface
                    App.closeModal();

                    try {
                        // On garde le fond existant pour récupérer ses coordonnées
                        const existingBg = State.canvas.getObjects().find(o => o.isBackground);
                        const refX = existingBg ? (existingBg.left || 0) : 0;
                        const refY = existingBg ? (existingBg.top || 0) : 0;

                        // On nettoie tout sauf le fond
                        const itemsToRemove = State.canvas.getObjects().filter(o => !o.isBackground);
                        State.canvas.remove(...itemsToRemove);

                        fabric.util.enlivenObjects(tpl.objects, (objs) => {
                            objs.forEach(o => {
                                // --- SÉCURITÉ ANTI-CRASH (C'est ce qui manque dans ton code) ---
                                // On s'assure que left et top sont bien des chiffres
                                let cleanLeft = parseFloat(o.left);
                                let cleanTop = parseFloat(o.top);

                                // Si c'est pourri (NaN), on met 0 par défaut pour éviter le freeze
                                if (isNaN(cleanLeft)) cleanLeft = 0;
                                if (isNaN(cleanTop)) cleanTop = 0;

                                // 3. RESTAURATION RELATIVE
                                o.left = cleanLeft + refX;
                                o.top = cleanTop + refY;

                                // Sécurité supplémentaire sur les dimensions
                                if (isNaN(o.width) || o.width <= 0) o.width = 50;
                                if (isNaN(o.height) || o.height <= 0) o.height = 50;

                                State.canvas.add(o);
                                Factory.ensureUniqueId(o);
                                o.setCoords();
                            });

                            State.canvas.requestRenderAll();

                            // On utilise ta fonction de réparation
                            if (App.fixImport) App.fixImport();
                            else if (App.restoreRefs) App.restoreRefs();

                            History.save();
                            App.showToast("Modèle appliqué !", "success");
                        });

                    } catch (error) {
                        console.error("Erreur critique lors de l'application du modèle :", error);
                        App.showToast("Modèle corrompu, impossible à charger.", "error");
                    }
                });
            },
            // --- EXPORT DEV (MÊME LOGIQUE) ---
            exportDev: () => {
                const pageObjects = State.canvas.getObjects().filter(o => !o.isBackground && !o.isGuide);
                if (pageObjects.length === 0) { App.showToast("Rien à exporter", "error"); return; }

                const bg = State.canvas.getObjects().find(o => o.isBackground);
                const refX = bg ? bg.left : 0;
                const refY = bg ? bg.top : 0;

                const name = prompt("Nom ?", "Nouveau Modèle");
                if (!name) return;
                const category = prompt("Catégorie ?", "Général");

                const thumb = State.canvas.toDataURL({ format: 'jpeg', quality: 0.6, multiplier: 0.2 });

                const objects = pageObjects.map(o => {
                    const json = o.toObject(customProps);
                    json.left = o.left - refX;
                    json.top = o.top - refY;
                    return json;
                });

                const codeObj = { id: "tpl_" + Date.now(), name: name, category: category, thumbnail: thumb, objects: objects };
                const jsonString = JSON.stringify(codeObj) + ",";

                navigator.clipboard.writeText(jsonString).then(() => {
                    alert("✅ CODE COPIÉ !");
                });
            }
        };

        const Bank = {
            items: [],
            storageKey: 'prof_toolbox_bank_v2',
            maxSize: 4.8 * 1024 * 1024,
            // DANS L'OBJET Bank = { ... }
            // DANS L'OBJET Bank = { ... }

            // --- OUTIL DEV OPTIMISÉ ---
            exportDev: () => {
                if (Bank.items.length === 0) {
                    App.showToast("Banque vide", "error");
                    return;
                }

                // JSON.stringify sans arguments = Compact (tout sur une ligne)
                const jsonString = JSON.stringify(Bank.items);

                navigator.clipboard.writeText(jsonString).then(() => {
                    console.log("Export Banque Compact :", jsonString.length + " caractères.");
                    alert("✅ BANQUE COMPACTE COPIÉE !\n\nTu peux le coller dans 'bank.js'.");
                });
            },
            // 1. EXPORTER LA BANQUE
            exportBank: () => {
                if (Bank.items.length === 0) {
                    App.showToast("La banque est vide, rien à exporter.", "error");
                    return;
                }

                const data = JSON.stringify(Bank.items, null, 2); // Beau JSON
                const blob = new Blob([data], { type: "application/json" });
                const link = document.createElement('a');

                // Nom du fichier avec la date
                const date = new Date().toISOString().slice(0, 10);
                link.href = URL.createObjectURL(blob);
                link.download = `pdf_studio_banque_${date}.json`;
                link.click();

                App.showToast("Banque exportée avec succès !", "success");
            },

            // 2. IMPORTER UNE BANQUE
            importBank: (input) => {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importedItems = JSON.parse(e.target.result);

                        if (!Array.isArray(importedItems)) {
                            throw new Error("Format invalide");
                        }

                        // On demande si on fusionne ou si on remplace
                        App.askConfirm(
                            "Importer la banque",
                            "Voulez-vous FUSIONNER avec votre banque actuelle ou tout REMPLACER ?",
                            () => {
                                // Action OUI : On remplace tout (Attention !)
                                // Note : Tu peux adapter la logique ici. 
                                // Pour l'instant, faisons une fusion intelligente (ajout des nouveaux)

                                let addedCount = 0;
                                importedItems.forEach(newItem => {
                                    // On vérifie si l'item existe déjà (basé sur le nom ou le contenu) pour éviter les doublons
                                    // Ici on fait simple : on ajoute tout avec un nouvel ID
                                    newItem.id = Date.now() + Math.random();
                                    Bank.items.push(newItem);
                                    addedCount++;
                                });

                                Bank.saveStorage();
                                Bank.render();
                                App.showToast(`${addedCount} éléments importés !`, "success");
                            }
                        );

                        // Si tu veux juste fusionner sans demander, tu peux simplifier le code ci-dessus.

                    } catch (err) {
                        console.error(err);
                        App.showToast("Fichier JSON invalide.", "error");
                    }
                };
                reader.readAsText(file);
                input.value = ''; // Reset pour pouvoir réimporter le même fichier
            },
            init: () => {
                Bank.load();

                // --- DÉTECTION ET REMPLISSAGE AUTOMATIQUE ---
                if (Bank.items.length === 0 && typeof DEFAULT_TEMPLATES !== 'undefined') {
                    Bank.populateDefaults();
                }
                // --------------------------------------------

                const input = document.getElementById('img-input-bank');
                if (input) {
                    input.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        Bank.compressImageFile(file, 600, 0.7, (compressedData) => {
                            Bank.add('image', compressedData, compressedData, file.name);
                        });
                        e.target.value = '';
                    });
                }
                if (typeof DropZone !== 'undefined') DropZone.init();
            },

            // --- NOUVEAU MOTEUR DE GÉNÉRATION ---
            populateDefaults: () => {
                // Canvas fantôme pour générer les objets proprement
                const tCan = new fabric.Canvas(null, { width: 400, height: 400 });

                DEFAULT_TEMPLATES.forEach(def => {
                    const objs = def.items.map(d => {
                        let o;
                        // Mapping du JSON vers la Factory
                        if (d.type === 'label') {
                            o = Factory.createLabel(d.x, d.y);
                            o.set({
                                text: d.text,
                                fontSize: d.size,
                                fill: d.color || '#000000',
                                fontWeight: d.bold ? 'bold' : 'normal'
                            });
                        }
                        else if (d.type === 'input') {
                            o = Factory.createInputGroup(d.x, d.y, d.w, d.h, d.kind);
                            if (d.fmt) o.set('fmt', d.fmt);
                            if (d.val && o.txtObj) o.txtObj.text = d.val;
                        }
                        else if (d.type === 'radio') {
                            o = Factory.createRadio(d.x, d.y);
                            o.grp = d.grp; o.val = d.val;
                        }
                        else if (d.type === 'shape') {
                            o = Factory.createShape(d.kind, d.x, d.y, d.w, d.h);
                            if (d.stroke) o.set({ stroke: d.stroke, strokeWidth: 1 });
                        }
                        return o;
                    });

                    // Création du groupe pour la miniature
                    const group = new fabric.Group(objs, { originX: 'center', originY: 'center' });
                    tCan.add(group);
                    group.setCoords();

                    // Génération Miniature + JSON
                    const preview = group.toDataURL({ format: 'png', multiplier: 0.5 });
                    const json = JSON.stringify(group.toObject(customProps));

                    Bank.add('template', json, preview, def.name);
                    tCan.clear();
                });

                tCan.dispose();
                Bank.saveStorage(); // Sauvegarde physique immédiate
                Bank.render();
            },

            load: () => {
                const saved = localStorage.getItem(Bank.storageKey);
                if (saved) { try { Bank.items = JSON.parse(saved); } catch (e) { console.error(e); } }
                Bank.render();
                Bank.updateStorageUI();
            },

            saveStorage: () => {
                try {
                    const json = JSON.stringify(Bank.items);
                    if (new Blob([json]).size > Bank.maxSize) {
                        App.showToast("Banque pleine ! Impossible de sauvegarder.", "error");
                        return false;
                    }
                    localStorage.setItem(Bank.storageKey, json);
                    Bank.updateStorageUI();
                    return true;
                } catch (e) { return false; }
            },

            compressImageFile: (file, maxWidth, quality, callback) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;
                        if (w > maxWidth) { h *= maxWidth / w; w = maxWidth; }
                        canvas.width = w; canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, w, h);
                        callback(canvas.toDataURL('image/jpeg', quality));
                    }
                };
                reader.readAsDataURL(file);
            },

            add: (type, content, preview, name = "Sans titre") => {
                const item = { id: Date.now() + Math.random(), type, content, preview, name };
                Bank.items.push(item);
                if (!Bank.saveStorage()) Bank.items.pop();
                else Bank.render();
            },

            addFromSelection: () => {
                const active = State.canvas.getActiveObject();
                if (!active) { App.showModal("Erreur", "Sélectionnez un objet."); return; }

                active.clone((cloned) => {
                    cloned.set({ left: 0, top: 0 });
                    const previewData = cloned.toDataURL({ format: 'jpeg', quality: 0.7, multiplier: 0.5, enableRetinaScaling: false });
                    const objData = cloned.toObject(customProps);
                    if (active.ctype && !objData.ctype) objData.ctype = active.ctype;
                    const json = JSON.stringify(objData);

                    let name = "Objet";
                    if (active.type === 'activeSelection') name = `Groupe (${active._objects.length})`;
                    else if (active.ctype) name = active.ctype;
                    else if (['i-text', 'text', 'textbox'].includes(active.type)) name = "Texte";

                    Bank.add('template', json, previewData, name);
                    App.showModal("Sauvegardé", "Ajouté à la bibliothèque.");
                }, customProps);
            },

            remove: (id) => {
                App.askConfirm("Suppression", "Voulez-vous supprimer cet élément de la banque ?", () => {
                    Bank.items = Bank.items.filter(i => i.id !== id);
                    Bank.saveStorage();
                    Bank.render();
                    App.showToast("Élément supprimé", "success");
                });
            },

            updateStorageUI: () => {
                const el = document.getElementById('storage-fill');
                const txt = document.getElementById('storage-text');
                if (!el) return;
                const size = new Blob([JSON.stringify(Bank.items)]).size;
                const pct = Math.min(100, (size / Bank.maxSize) * 100);
                el.style.width = pct + '%';
                el.style.backgroundColor = pct > 90 ? '#ef4444' : '#2563eb';
                if (txt) txt.innerText = `${(size / 1024).toFixed(0)} Ko`;
            },

            editName: (e, id, span) => {
                e.preventDefault(); e.stopPropagation();
                const item = Bank.items.find(i => i.id === id);
                if (!item) return;
                const input = document.createElement('input');
                input.type = 'text'; input.value = item.name; input.className = 'bank-name-input';
                const save = () => { if (input.value.trim()) { item.name = input.value.trim(); Bank.saveStorage(); } Bank.render(); };
                input.addEventListener('blur', save);
                input.addEventListener('keydown', k => { if (k.key === 'Enter') input.blur(); if (k.key === 'Escape') Bank.render(); k.stopPropagation(); });
                input.addEventListener('mousedown', ev => ev.stopPropagation());
                span.replaceWith(input); input.focus(); input.select();
            },

            render: () => {
                const container = document.getElementById('bank-list');
                if (!container) return;
                container.innerHTML = '';
                if (Bank.items.length === 0) { container.innerHTML = '<div class="text-xs text-gray-400 text-center italic py-4">Vide</div>'; return; }
                [...Bank.items].reverse().forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'bank-item group';
                    el.draggable = true;
                    const previewImg = `<img src="${item.preview}" class="bank-preview bg-gray-100 object-contain w-10 h-10 rounded pointer-events-none">`;
                    el.innerHTML = `${previewImg}<div class="flex flex-col overflow-hidden flex-1 pointer-events-none"><div class="flex items-center gap-1 w-full pointer-events-auto"><span class="text-[10px] font-bold truncate cursor-text hover:text-blue-600 px-1 transition-colors" onclick="Bank.editName(event, ${item.id}, this)">${item.name}</span></div><span class="text-[9px] text-gray-400 uppercase">${item.type === 'template' ? 'Modèle' : 'Image'}</span></div><i class="fa-solid fa-trash bank-del-btn pointer-events-auto" onclick="Bank.remove(${item.id})"></i>`;
                    el.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('application/json', JSON.stringify({ origin: 'bank', type: item.type, content: item.content }));
                        e.dataTransfer.effectAllowed = 'copy';
                    });
                    container.appendChild(el);
                });
            }
        };

        const DropZone = {
            init: () => {
                const workspace = document.getElementById('workspace');
                if (!workspace) return;

                workspace.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
                workspace.addEventListener('drop', (e) => {
                    e.preventDefault();

                    const rawData = e.dataTransfer.getData('application/json');
                    if (!rawData) return;

                    try {
                        const data = JSON.parse(rawData);
                        if (data.origin !== 'bank') return;

                        const pointer = State.canvas.getPointer(e);

                        if (data.type === 'template') {
                            const jsonContent = JSON.parse(data.content);

                            fabric.util.enlivenObjects([jsonContent], (objects) => {
                                const rootObj = objects[0];
                                if (!rootObj) return;

                                // 1. CALCUL DU DÉCALAGE
                                const currentCenter = rootObj.getCenterPoint();
                                const dx = pointer.x - currentCenter.x;
                                const dy = pointer.y - currentCenter.y;

                                // 2. PRÉPARATION DE LA LISTE
                                let finalObjects = [];

                                if (rootObj.type === 'activeSelection') {
                                    const items = rootObj.getObjects();
                                    items.forEach(child => {
                                        child.left += dx; child.top += dy;
                                        child.setCoords();
                                        finalObjects.push(child);
                                    });
                                } else if (rootObj.type === 'group' && !rootObj.ctype) {
                                    rootObj.set({ left: pointer.x, top: pointer.y, originX: 'center', originY: 'center' });
                                    rootObj.setCoords();
                                    finalObjects = [rootObj];
                                } else {
                                    rootObj.set({ left: pointer.x, top: pointer.y, originX: 'center', originY: 'center' });
                                    finalObjects = [rootObj];
                                }

                                // 3. LE CERVEAU : REMAPPING
                                const radioGroupMap = {};

                                finalObjects.forEach(obj => {
                                    // A. RESTAURATION LIENS
                                    if (obj.type === 'group' && obj.ctype) {
                                        const items = obj.getObjects();
                                        obj.bgObj = items[0];
                                        if (items[1]) {
                                            if (['textfield', 'textarea', 'dropdown'].includes(obj.ctype)) obj.txtObj = items[1];
                                            if (['checkbox', 'radio'].includes(obj.ctype)) obj.markObj = items[1];
                                        }
                                        items.forEach(k => {
                                            k.selectable = false; k.evented = false;
                                            k.lockMovementX = true; k.lockMovementY = true;
                                        });
                                        if (['textfield', 'textarea', 'checkbox', 'radio', 'dropdown', 'label'].includes(obj.ctype)) {
                                            obj.setControlsVisibility({ mtr: false });
                                            obj.lockRotation = true;
                                        }
                                    }

                                    // B. PID UNIQUE
                                    if (obj.ctype) obj.pid = Factory.getSafeId(obj.ctype);

                                    // C. RADIOS INTELLIGENTS
                                    if (obj.ctype === 'radio' && obj.grp) {
                                        const oldGrp = obj.grp;
                                        if (!radioGroupMap[oldGrp]) {
                                            radioGroupMap[oldGrp] = `${oldGrp}_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                                        }
                                        obj.grp = radioGroupMap[oldGrp];
                                    }

                                    // D. AJOUT AU CANVAS
                                    if (!obj.canvas) State.canvas.add(obj);
                                    obj.setCoords();
                                });

                                // 4. SÉLECTION FINALE
                                if (finalObjects.length > 1) {
                                    const sel = new fabric.ActiveSelection(finalObjects, { canvas: State.canvas });
                                    State.canvas.setActiveObject(sel);
                                } else if (finalObjects.length === 1) {
                                    State.canvas.setActiveObject(finalObjects[0]);
                                }

                                // --- LE FIX EST ICI ---
                                // On s'assure que les paragraphes déposés récupèrent leurs propriétés spéciales
                                // (poignées cachées, hauteur auto, etc.)
                                App.rehydrate();
                                // ----------------------

                                State.canvas.requestRenderAll();
                                Panel.update(State.canvas.getActiveObject());
                                Navigator.refresh();
                                History.save();
                            });
                        }
                        // GESTION DES IMAGES SIMPLES
                        else if (data.type === 'image') {
                            fabric.Image.fromURL(data.content, (img) => {
                                if (img.width > 300) img.scaleToWidth(300);
                                img.set({
                                    hasRotatingPoint: false,
                                    lockRotation: true,
                                    left: pointer.x, top: pointer.y,
                                    originX: 'center', originY: 'center',
                                    ctype: 'image',
                                    pid: Factory.getName('image')
                                });
                                const defaultControls = fabric.Object.prototype.controls;
                                img.controls = { ...defaultControls };  // Copie tous les contrôles par défaut
                                delete img.controls.mtr;
                                img.setControlVisible('mtr', false);
                                Factory.ensureUniqueId(img);
                                img.srcObj = data.content;
                                State.canvas.add(img);
                                State.canvas.setActiveObject(img);
                                Navigator.refresh();
                                History.save();
                            });
                        }
                    } catch (err) { console.error("Erreur Drop:", err); }
                });
            }
        };


        const History = {


            stack: [],
            idx: -1,
            max: 50,
            processing: false,

            save: () => {
                if (History.processing) return;
                if (History.idx < History.stack.length - 1) History.stack = History.stack.slice(0, History.idx + 1);

                // Gestion Undo/Redo (inchangée)
                const raw = State.canvas.toObject(customProps);
                raw.objects = raw.objects.filter(o => !o.isGuide);
                History.stack.push(JSON.stringify(raw));
                if (History.stack.length > History.max) History.stack.shift(); else History.idx++;

                // APPEL AUTO-SAVE
                App.saveAuto(); // <--- C'est ici qu'on appelle la nouvelle fonction

                Navigator.refresh();
            },
            restore: (json) => {
                History.processing = true;
                App.clearGuides();
                State.canvas.clear();

                State.canvas.loadFromJSON(json, () => {
                    // --- C'EST ICI QUE TOUT SE JOUE ---

                    // 1. On lance la réparation complète (Liens + Position + Verrous)
                    // Remplace App.restoreRefs() par ceci :
                    if (App.fixImport) {
                        App.fixImport();
                    } else {
                        // Si tu as gardé le nom 'restoreRefs', assure-toi que son code 
                        // contient bien le 'setPositionByOrigin' que je t'ai donné juste avant.
                        App.restoreRefs();
                    }

                    // 2. Reste de ta logique
                    State.canvas.renderAll();

                    if (App.rehydrate) App.rehydrate(); // Garde-le si tu l'utilises pour autre chose

                    History.processing = false;
                    Panel.update(null);
                    Navigator.refresh();
                });
            },

            undo: () => { if (History.idx > 0) { History.idx--; History.restore(History.stack[History.idx]); } },
            redo: () => { if (History.idx < History.stack.length - 1) { History.idx++; History.restore(History.stack[History.idx]); } }
        };

        const State = {
            showFlowLines: false,
            pages: [],       // Tableau qui stockera le JSON de chaque page
            currentPage: 0,  // Index de la page active (commence à 0)
            totalPages: 1,    // Nombre total de pages
            sequenceList: [], // Pour stocker l'ordre temporaire
            isSequencing: false, canvas: null, mode: 'select', snap: true, isPreview: false, pdfBytes: null, clipboard: null, counts: { textfield: 1, textarea: 1, checkbox: 1, radio: 1, dropdown: 1, label: 1, rect: 1, circle: 1, radiogroup: 1, image: 1 }, defaults: { fill: '#ffffff', stroke: '#000000', width: 1, font: 'Arial', size: 12, lock: true, defHeight: 24, boxSize: 14 }
        };

        const Navigator = {
            dom: document.getElementById('navigator-list'),
            lastSelectedIndex: -1,

            refresh: () => {
                const list = Navigator.dom;
                list.innerHTML = '';

                const allObjs = State.canvas.getObjects();
                const navObjs = allObjs.filter(o => !o.isBackground && !o.isGuide);
                const activeObjs = State.canvas.getActiveObjects();

                navObjs.forEach((o, index) => {
                    const div = document.createElement('div');
                    div.className = 'nav-item';
                    if (activeObjs.includes(o)) div.classList.add('active');

                    div.draggable = true;
                    div.dataset.canvasIndex = allObjs.indexOf(o);

                    // --- Icone et Label ---
                    let icon = 'fa-square';
                    let extra = '';
                    if (o.ctype === 'textfield') icon = 'fa-font';
                    else if (o.ctype === 'checkbox') icon = 'fa-check-square';
                    else if (o.ctype === 'radio') { icon = 'fa-circle-dot'; extra = ` (${o.grp}) - ${o.val}`; }
                    else if (o.ctype === 'image') icon = 'fa-image';

                    const label = (o.pid || (o.ctype ? o.ctype : 'Forme')) + extra;

                    // On ajoute le numéro de séquence si dispo
                    let seqBadge = '';
                    if (State.sequenceList.includes(o)) {
                        const num = State.sequenceList.indexOf(o) + 1;
                        seqBadge = `<span class="bg-blue-100 text-blue-600 text-[9px] font-bold px-1 rounded ml-auto">${num}</span>`;
                    }

                    div.innerHTML = `
                <div class="flex items-center gap-2 flex-1 overflow-hidden pointer-events-none">
                    <span class="text-gray-300 w-4 text-[9px] text-center">${index + 1}</span>
                    <i class="fa-solid ${icon} text-gray-400"></i> 
                    <span class="truncate text-[10px] font-medium">${label}</span>
                    ${seqBadge}
                </div>
            `;

                    // --- Events Clic (Selection) ---
                    div.addEventListener('click', (e) => {
                        // ... (Ton code de sélection existant, pas de changement nécessaire ici) ...
                        const currentListIndex = index;
                        let newSelection = [];
                        if (e.shiftKey && Navigator.lastSelectedIndex !== -1) {
                            const start = Math.min(Navigator.lastSelectedIndex, currentListIndex);
                            const end = Math.max(Navigator.lastSelectedIndex, currentListIndex);
                            for (let i = start; i <= end; i++) newSelection.push(navObjs[i]);
                        } else if (e.ctrlKey || e.metaKey) {
                            newSelection = [...State.canvas.getActiveObjects()];
                            if (newSelection.includes(o)) newSelection = newSelection.filter(item => item !== o);
                            else newSelection.push(o);
                            Navigator.lastSelectedIndex = currentListIndex;
                        } else {
                            newSelection = [o];
                            Navigator.lastSelectedIndex = currentListIndex;
                        }
                        State.canvas.discardActiveObject();
                        if (newSelection.length > 0) {
                            const sel = new fabric.ActiveSelection(newSelection, { canvas: State.canvas });
                            State.canvas.setActiveObject(sel);
                        } else {
                            Panel.update(null);
                        }
                        State.canvas.requestRenderAll();
                    });

                    // --- Drag & Drop (Le coeur du changement) ---
                    div.addEventListener('dragstart', (e) => {
                        const active = State.canvas.getActiveObjects();
                        let indicesToMove = active.includes(o) ? active.map(obj => allObjs.indexOf(obj)) : [allObjs.indexOf(o)];
                        e.dataTransfer.setData('application/json', JSON.stringify(indicesToMove));
                        div.classList.add('dragging');
                    });

                    div.addEventListener('dragend', () => { div.classList.remove('dragging'); });
                    div.addEventListener('dragover', (e) => { e.preventDefault(); div.style.borderTop = "2px solid #2563eb"; });
                    div.addEventListener('dragleave', () => { div.style.borderTop = "none"; });

                    div.addEventListener('drop', (e) => {
                        e.preventDefault();
                        div.style.borderTop = "none";
                        const rawData = e.dataTransfer.getData('application/json');
                        if (!rawData) return;

                        const fromIndices = JSON.parse(rawData);
                        const targetCanvasIndex = parseInt(div.dataset.canvasIndex);
                        const targetObj = allObjs[targetCanvasIndex];

                        if (fromIndices.includes(targetCanvasIndex)) return;

                        const objsToMove = fromIndices.map(i => allObjs[i]);
                        // On trie pour garder l'ordre relatif
                        objsToMove.sort((a, b) => allObjs.indexOf(a) - allObjs.indexOf(b));

                        // Déplacement Fabric (Z-Index)
                        [...objsToMove].reverse().forEach(obj => {
                            const currentTargetIndex = State.canvas.getObjects().indexOf(targetObj);
                            obj.moveTo(currentTargetIndex);
                        });

                        // --- MISE A JOUR DE LA SÉQUENCE ---
                        // C'est ici ! Une fois déplacé, on recalcule la liste de séquence.
                        App.syncSequenceFromLayers();
                        // ----------------------------------

                        State.canvas.requestRenderAll();
                        History.save();
                        Navigator.refresh();
                    });

                    list.appendChild(div);
                });
            }
        };
        const Factory = {
            createParagraph: (l, t) => {
                const obj = new fabric.Textbox("Double-cliquez pour éditer", {
                    left: l, top: t,
                    width: 300, // Largeur par défaut
                    fontSize: State.defaults.size,
                    fontFamily: 'Arial',
                    fill: '#000000',
                    splitByGrapheme: false, // Coupe les mots proprement
                    lockScalingY: false,    // Hauteur automatique
                    editable: true
                });
                obj.ctype = 'paragraph';
                // On cache les poignées haut/bas car la hauteur est auto
                obj.setControlsVisibility({ mtr: false, mt: false, mb: false, tl: false, tr: false, bl: false, br: false, ml: true, mr: true });
                return obj;
            },
            getSafeId: (type) => {
                let candidate;
                do {
                    candidate = `${type}_${State.counts[type]++}`;
                } while (State.canvas.getObjects().some(o => o.pid === candidate));
                return candidate;
            },
            getName: (t) => Factory.getSafeId(t),
            ensureUniqueId: (obj) => {
                if (obj.ctype) {
                    obj.set('pid', Factory.getSafeId(obj.ctype));
                    if (obj.ctype === 'radio') {
                        obj.set('grp', `Groupe_${State.counts.radiogroup++}`);
                    }
                }
            },


            createInputGroup: (l, t, w, h, type) => {
                // 1. ÉTAT DES CONTRÔLES
                const isLocked = document.getElementById('g-lock').checked;
                const headerHeight = parseInt(document.getElementById('g-def-height').value) || 24;
                const headerSize = parseInt(document.getElementById('g-size').value) || 14;

                let boxHeight = h;
                let fontSize = headerSize;

                // 2. LOGIQUE DE TAILLE
                if (isLocked) {
                    if (type === 'textfield' || type === 'dropdown') {
                        boxHeight = headerHeight;
                        fontSize = Math.floor(boxHeight * 0.70);
                    } else {
                        // Textarea : police fixée par le header, hauteur libre (souris)
                        fontSize = headerSize;
                    }
                } else {
                    boxHeight = h;
                    if (type === 'textfield' || type === 'dropdown') {
                        fontSize = Math.max(10, Math.floor(boxHeight * 0.70));
                    }
                }

                // 3. CRÉATION DU FOND
                const rect = new fabric.Rect({
                    width: w, height: boxHeight,
                    fill: State.defaults.fill,
                    stroke: State.defaults.stroke,
                    strokeWidth: State.defaults.width,
                    originX: 'left', originY: 'top', left: 0, top: 0
                });

                // 4. CRÉATION DU TEXTE
                let textTop = 4; // PAR DÉFAUT (Pour Textarea) : Collé en haut avec petite marge

                if (type === 'textfield' || type === 'dropdown') {
                    // Pour les champs simple ligne, on écrase la valeur pour Centrer
                    textTop = (boxHeight - fontSize) / 2;
                    textTop = Math.max(0, textTop);
                }

                const textObj = new fabric.Textbox(type === 'dropdown' ? "Option 1" : "", {
                    width: type === 'dropdown' ? w - 25 : w - 10, // Prend toute la largeur dispo
                    fontSize: fontSize,
                    fontFamily: State.defaults.font,
                    originX: 'left', originY: 'top',
                    left: 5,
                    top: textTop, // <--- Utilise la valeur calculée (4px pour textarea, Centré pour les autres)
                    splitByGrapheme: type === 'textarea', // Permet le retour à la ligne forcé si mot trop long
                    editable: type !== 'dropdown',
                    cursorColor: type === 'dropdown' ? 'transparent' : 'blue'
                });

                const items = [rect, textObj];

                // 5. SPÉCIFIQUE DROPDOWN : LA FLÈCHE ▼
                if (type === 'dropdown') {
                    const arrowSize = fontSize / 2;
                    const arrow = new fabric.Triangle({
                        width: arrowSize, height: arrowSize,
                        fill: 'black',
                        left: w - 15, top: (boxHeight / 2) - (arrowSize / 2),
                        angle: 180,
                        originX: 'center', originY: 'center'
                    });
                    items.push(arrow);
                }

                // Verrouillages internes
                items.forEach(o => {
                    o.selectable = false; o.evented = false;
                    o.lockMovementX = true; o.lockMovementY = true;
                });

                // 6. CRÉATION DU GROUPE
                const grp = new fabric.Group(items, {
                    left: l, top: t,
                    originX: 'left', originY: 'top',
                    subTargetCheck: true,
                    lockScalingY: (isLocked && (type === 'textfield' || type === 'dropdown')),
                    lockRotation: true,
                    padding: 0
                });

                grp.bgObj = rect;
                grp.txtObj = textObj;
                if (type === 'dropdown') grp.arrowObj = items[2];

                grp.set({ ctype: type, pid: Factory.getName(type) });

                // Initialisation Dropdown
                if (type === 'dropdown') {
                    grp.opts = "Option 1\nOption 2\nOption 3";
                    grp.val = "Option 1";
                }

                return grp;
            }, createCheckbox: (l, t) => {
                const s = State.defaults.boxSize;
                const rect = new fabric.Rect({
                    width: s, height: s,
                    fill: State.defaults.fill,
                    stroke: State.defaults.stroke,
                    strokeWidth: State.defaults.width,
                    originX: 'center', originY: 'center'
                });
                const mark = new fabric.Text("✕", {
                    fontSize: s - 4,
                    fontFamily: 'Arial',
                    fill: State.defaults.stroke,
                    originX: 'center', originY: 'center',
                    opacity: 0, selectable: false
                });

                rect.hasControls = false;
                rect.lockRotation = true;
                rect.selectable = false; // Par sécurité

                const locked = State.defaults.lock;

                const grp = new fabric.Group([rect, mark], {
                    left: l, top: t,
                    subTargetCheck: false,
                    lockUniScaling: true,
                    lockRotation: true
                });

                const controls = { mtr: false };

                if (locked) {
                    grp.set({ lockScalingX: true, lockScalingY: true });
                    Object.assign(controls, { tl: false, tr: false, bl: false, br: false, mt: false, mb: false, ml: false, mr: false });
                } else {
                    Object.assign(controls, { mt: false, mb: false, ml: false, mr: false });
                }

                grp.setControlsVisibility(controls);
                grp.set({ ctype: 'checkbox', pid: Factory.getName('checkbox'), isChecked: false });
                grp.bgObj = rect; grp.markObj = mark;
                return grp;
            },

            // --- RADIO ---
            createRadio: (l, t) => {
                const s = State.defaults.boxSize;
                const outer = new fabric.Circle({
                    radius: s / 2,
                    fill: State.defaults.fill,
                    stroke: State.defaults.stroke,
                    strokeWidth: State.defaults.width,
                    originX: 'center', originY: 'center'
                });
                const inner = new fabric.Circle({
                    radius: s / 4,
                    fill: State.defaults.stroke,
                    originX: 'center', originY: 'center',
                    opacity: 0, selectable: false
                });

                outer.hasControls = false;
                outer.lockRotation = true;
                outer.selectable = false; // Par sécurité

                const locked = State.defaults.lock;

                const grp = new fabric.Group([outer, inner], {
                    left: l, top: t,
                    subTargetCheck: false,
                    lockUniScaling: true,
                    lockRotation: true
                });

                const controls = { mtr: false };

                if (locked) {
                    grp.set({ lockScalingX: true, lockScalingY: true });
                    Object.assign(controls, { tl: false, tr: false, bl: false, br: false, mt: false, mb: false, ml: false, mr: false });
                } else {
                    Object.assign(controls, { mt: false, mb: false, ml: false, mr: false });
                }

                grp.setControlsVisibility(controls);
                grp.set({
                    ctype: 'radio',
                    pid: Factory.getName('radio'),
                    isChecked: false,
                    grp: `Groupe_${State.counts.radiogroup++}`,
                    val: 'A'
                });
                grp.bgObj = outer; grp.markObj = inner;
                return grp;
            },

            // --- FORMES (RECTANGLE/CERCLE/LIGNE) ---
            createShape: (type, l, t, w, h) => {
                let obj;
                const opts = { left: l, top: t, width: w, height: h, fill: 'transparent', stroke: State.defaults.stroke, strokeWidth: State.defaults.width };
                if (type === 'rect') obj = new fabric.Rect(opts);
                else if (type === 'circle') obj = new fabric.Ellipse({ ...opts, rx: w / 2, ry: h / 2 });
                else if (type === 'line') obj = new fabric.Line([l, t, l + w, t + h], { stroke: State.defaults.stroke, strokeWidth: State.defaults.width });
                const defaultControls = fabric.Object.prototype.controls;
                obj.controls = { ...defaultControls };
                delete obj.controls.mtr;
                obj.ctype = 'draw';
                return obj;
            },

            // --- LABEL ---
            // --- LABEL ---
            createLabel: (l, t) => {
                const obj = new fabric.IText("Texte", {
                    left: l,
                    top: t,
                    fontSize: State.defaults.size,
                    fontFamily: State.defaults.font,
                    fill: State.defaults.stroke,

                    // Bloque le redimensionnement
                    lockScalingX: true,
                    lockScalingY: true,

                    // Bloque la rotation
                    lockRotation: true
                });

                obj.ctype = 'label';

                // Cache visuellement les poignées de redimensionnement et de rotation
                obj.setControlsVisibility({
                    mt: false, // milieu haut
                    mb: false, // milieu bas
                    ml: false, // milieu gauche
                    mr: false, // milieu droite
                    bl: false, // bas gauche
                    br: false, // bas droite
                    tl: false, // top gauche
                    tr: false, // top droite
                    mtr: false // poignée de rotation
                });

                return obj;
            }
        };
        const App = {
            // A mettre dans ton objet App
            fixImport: () => {
                const objs = State.canvas.getObjects();
                objs.forEach(obj => {
                    if (['textfield', 'textarea', 'dropdown'].includes(obj.ctype)) {

                        // A. Reconnexion
                        const items = obj.getObjects();
                        obj.bgObj = items[0];
                        obj.txtObj = items[1];

                        // B. CORRECTION DU DÉCALAGE (Le Magic Fix)
                        // On capture la position visuelle actuelle
                        const currentPoint = obj.getPointByOrigin('left', 'top');
                        // On change l'origine interne
                        obj.set({ originX: 'left', originY: 'top' });
                        // On replace l'objet exactement au même endroit visuel
                        obj.setPositionByOrigin(currentPoint, 'left', 'top');

                        // C. Verrous
                        obj.set({
                            lockRotation: true,
                            subTargetCheck: true,
                            padding: 0,
                            lockScalingY: (obj.ctype === 'textfield')
                        });

                        // D. Contrôles
                        const controls = { mtr: false };
                        if (obj.ctype === 'textfield') Object.assign(controls, { mt: false, mb: false, ml: true, mr: true });
                        else Object.assign(controls, { mt: true, mb: true, ml: true, mr: true });
                        obj.setControlsVisibility(controls);
                    }
                });
                State.canvas.requestRenderAll();
            },

            showToast: (msg, type = 'info') => {
                const container = document.getElementById('toast-container');
                if (!container) return;

                const el = document.createElement('div');
                el.className = `toast ${type} show`; // Utilise le CSS existant
                // Icônes selon le type
                let icon = '<i class="fa-solid fa-circle-info"></i>';
                if (type === 'success') icon = '<i class="fa-solid fa-circle-check"></i>';
                if (type === 'error') icon = '<i class="fa-solid fa-triangle-exclamation"></i>';

                el.innerHTML = `${icon} <span>${msg}</span>`;
                container.appendChild(el);

                // Auto suppression après 3s
                setTimeout(() => {
                    el.classList.remove('show');
                    setTimeout(() => el.remove(), 300);
                }, 3000);
            },

            // Demande une confirmation (Remplace confirm())
            askConfirm: (title, msg, onYes) => {
                document.getElementById('modal-title').innerText = title;
                document.getElementById('modal-msg').innerText = msg;

                // Bascule l'affichage des boutons
                document.getElementById('modal-btn-info').classList.add('hidden');
                document.getElementById('modal-btn-confirm').classList.remove('hidden');

                // Setup du bouton OUI
                const btnYes = document.getElementById('btn-confirm-yes');
                // On clone le bouton pour supprimer les anciens event listeners
                const newBtn = btnYes.cloneNode(true);
                btnYes.parentNode.replaceChild(newBtn, btnYes);

                newBtn.onclick = () => {
                    onYes();
                    App.closeModal();
                };

                // Affichage
                const ov = document.getElementById('modal-overlay');
                ov.classList.remove('hidden');
                ov.classList.add('modal-enter');
                setTimeout(() => ov.classList.add('modal-enter-active'), 10);
            },

            // Modifiez showModal pour remettre les boutons par défaut
            // 1. Pour les messages simples (Information)
            // C'est celle utilisée par le bouton Séquence
            showModal: (title, msg) => {
                document.getElementById('modal-title').innerText = title;
                document.getElementById('modal-msg').innerText = msg;

                // IMPORTANT : On AFFICHE "Compris" et on CACHE "Confirmer"
                document.getElementById('modal-btn-info').classList.remove('hidden');
                document.getElementById('modal-btn-confirm').classList.add('hidden'); // <--- C'EST CETTE LIGNE QUI MANQUAIT

                const ov = document.getElementById('modal-overlay');
                ov.classList.remove('hidden');
                ov.classList.add('modal-enter');
                setTimeout(() => ov.classList.add('modal-enter-active'), 10);
            },

            // 2. Pour les actions (Confirmation)


            // DANS L'OBJET App = { ... }

            // --- FONCTION DE RÉPARATION APRÈS CHARGEMENT ---
            rehydrate: () => {
                const objs = State.canvas.getObjects();
                objs.forEach(o => {
                    // Si c'est un paragraphe, on remet les règles du jeu
                    if (o.ctype === 'paragraph') {
                        o.set({
                            editable: true,
                            lockScalingY: false,    // Hauteur auto
                            splitByGrapheme: false  // Coupe les mots proprement
                        });
                        // On cache à nouveau les poignées verticales
                        o.setControlsVisibility({
                            mtr: false, mt: false, mb: false,
                            tl: false, tr: false, bl: false, br: false,
                            ml: true, mr: true
                        });
                    }
                });
                State.canvas.requestRenderAll();
            },
            // Dans App = { ... }

            // GESTION BARRE FLOTTANTE
            // DANS L'OBJET App = { ... }

            // Dans App = { ... }

            // DANS App = { ... }

            updateFloatBar: () => {
                const bar = document.getElementById('float-bar');
                const obj = State.canvas.getActiveObject();

                if (!obj || !obj.isEditing || obj.ctype !== 'paragraph') {
                    bar.classList.add('hidden');
                    return;
                }

                // --- MISE A JOUR UI ---
                const sizeInput = document.getElementById('wysiwyg-size');
                if (sizeInput) sizeInput.value = obj.fontSize || 16;

                const fontSelect = document.getElementById('wysiwyg-font');
                if (fontSelect) fontSelect.value = obj.fontFamily || 'Arial';

                // NOUVEAU : Récupération couleur
                const colorInput = document.getElementById('wysiwyg-color');
                if (colorInput) {
                    // On regarde la couleur de la sélection, sinon la couleur globale
                    const currentStyle = obj.getSelectionStyles()[0];
                    const color = (currentStyle && currentStyle.fill) ? currentStyle.fill : obj.fill;
                    colorInput.value = App.toHex(color); // Utilise ta fonction existante ou celle par défaut
                }
                // ----------------------

                const bound = obj.getBoundingRect();
                const canvasRect = document.getElementById('c').getBoundingClientRect();
                const top = canvasRect.top + bound.top - 45;
                const left = canvasRect.left + bound.left + (bound.width / 2);

                bar.style.top = `${Math.max(10, top)}px`;
                bar.style.left = `${left}px`;
                bar.classList.remove('hidden');
            },
            // APPLICATION DU STYLE (Le moteur WYSIWYG)
            // Dans App = { ... }

            formatText: (type, val) => {
                const obj = State.canvas.getActiveObject();
                if (!obj || !obj.isEditing) return;

                if (type === 'bold') {
                    const current = obj.getSelectionStyles()[0]?.fontWeight || 'normal';
                    obj.setSelectionStyles({ fontWeight: current === 'bold' ? 'normal' : 'bold' });
                }
                else if (type === 'italic') {
                    const current = obj.getSelectionStyles()[0]?.fontStyle || 'normal';
                    obj.setSelectionStyles({ fontStyle: current === 'italic' ? 'normal' : 'italic' });
                }
                else if (type === 'underline') {
                    const current = obj.getSelectionStyles()[0]?.underline || false;
                    obj.setSelectionStyles({ underline: !current });
                }
                else if (type === 'font') {
                    // Police Globale (plus sûr pour l'instant)
                    obj.set('fontFamily', val);
                }
                else if (type === 'size') {
                    // --- NOUVEAU : TAILLE GLOBALE ---
                    const s = parseInt(val);
                    if (s > 0) {
                        obj.set('fontSize', s);
                        // On met à jour la hauteur si besoin (optionnel car lockScalingY: false gère ça)
                        obj.setCoords();
                    }
                }
                else if (type === 'color') {
                    // --- NOUVEAU : GESTION COULEUR ---
                    // Si sélection active -> Couleur locale (un mot)
                    // Sinon -> Couleur globale
                    const hasSelection = obj.selectionStart !== obj.selectionEnd;

                    if (hasSelection) {
                        obj.setSelectionStyles({ fill: val });
                    } else {
                        obj.set('fill', val);
                        // On nettoie les styles locaux pour que tout devienne uniforme
                        obj.cleanStyle('fill');
                    }
                }
                else if (type === 'align') {
                    obj.set('textAlign', val);
                    obj.tAlign = val;
                }

                State.canvas.requestRenderAll();
                // Pas de History.save() ici si on tape au clavier, mais sur un clic bouton oui
                // Pour simplifier, on sauvegarde :
                // History.save(); 
            },
            setZoom: (delta) => {
                let zoom = State.canvas.getZoom();
                zoom += delta;
                if (zoom > 5) zoom = 5;
                if (zoom < 0.1) zoom = 0.1;
                State.canvas.setZoom(zoom);
                State.canvas.requestRenderAll();
            },
            resetZoom: () => {
                State.canvas.setZoom(1);
                // Centre la vue
                State.canvas.viewportTransform[4] = (State.canvas.width - State.canvas.pageW) / 2;
                State.canvas.viewportTransform[5] = 20;
                State.canvas.requestRenderAll();
            },
            checkAutoSave: () => {
                const saved = localStorage.getItem('prof_toolbox_autosave');

                if (!saved) {
                    console.log("Aucune sauvegarde trouvée.");
                    return;
                }

                try {
                    const data = JSON.parse(saved);

                    // Vérification basique pour ne pas charger n'importe quoi
                    if (!data.pages || !Array.isArray(data.pages)) {
                        console.error("Sauvegarde corrompue");
                        return;
                    }

                    const date = new Date(data.timestamp).toLocaleString();
                    App.askConfirm(
                        "Session trouvée",
                        `Une session du ${date} a été trouvée. Voulez-vous la restaurer ?`,
                        () => {
                            // 1. Restaurer les variables d'état
                            State.pages = data.pages;
                            State.totalPages = data.totalPages || data.pages.length;

                            // 2. Restaurer les dimensions
                            if (data.dims) {
                                State.canvas.pageW = data.dims.w;
                                State.canvas.pageH = data.dims.h;
                                State.canvas.pageOffset = { x: data.dims.offX, y: data.dims.offY };
                                App.resize();
                            }

                            // 3. Charger la page
                            setTimeout(() => {
                                App.loadPage(data.currentPage || 0);
                                App.rehydrate();
                                App.showToast("Session restaurée avec succès", "success");
                            }, 100);
                        }
                    );
                } catch (e) {
                    console.error("Erreur lors de la lecture de l'auto-save", e);
                    // Si c'est planté, on nettoie pour éviter que ça replante au prochain démarrage
                    localStorage.removeItem('prof_toolbox_autosave');
                }
            },
            saveAuto: () => {
                // 1. On force la mise à jour de la page actuelle dans le tableau
                // (Sinon State.pages[current] risque d'être vide ou obsolète)
                App.saveCurrentPage();

                // 2. On prépare les données
                const data = {
                    version: "V46",
                    timestamp: Date.now(),
                    pages: State.pages,
                    currentPage: State.currentPage,
                    totalPages: State.totalPages,
                    // On sauvegarde les dimensions importantes
                    dims: {
                        w: State.canvas.pageW,
                        h: State.canvas.pageH,
                        offX: State.canvas.pageOffset.x,
                        offY: State.canvas.pageOffset.y
                    }
                };

                // 3. On écrit (avec une protection en cas de dépassement de quota)
                try {
                    const json = JSON.stringify(data);
                    localStorage.setItem('prof_toolbox_autosave', json);
                    console.log("Auto-save OK :", new Date().toLocaleTimeString());
                } catch (e) {
                    console.warn("Auto-save échoué (quota ou erreur)", e);
                }
            },
            hideCtx: () => { document.getElementById('context-menu').classList.add('hidden'); },
            // --- GESTION DE L'AIDE ---
            toggleHelp: () => {
                const el = document.getElementById('help-overlay');
                const box = document.getElementById('help-box');
                if (el.classList.contains('hidden')) {
                    el.classList.remove('hidden');
                    // Petite animation d'entrée
                    setTimeout(() => box.classList.remove('scale-95'), 10);
                } else {
                    box.classList.add('scale-95');
                    setTimeout(() => el.classList.add('hidden'), 200);
                }
            },

            setHelpTab: (tabName) => {
                // Reset Tabs
                document.querySelectorAll('.help-tab').forEach(t => t.classList.remove('active-tab'));
                document.getElementById('ht-' + tabName).classList.add('active-tab');

                // Reset Content
                document.querySelectorAll('.help-content').forEach(c => c.classList.add('hidden'));
                document.getElementById('hc-' + tabName).classList.remove('hidden');
            },
            updatePageIndicator: () => {
                const el = document.getElementById('page-indicator');
                const nav = document.getElementById('page-nav');
                if (State.totalPages > 1) nav.classList.remove('hidden'); else nav.classList.add('hidden');
                el.innerText = `Page ${State.currentPage + 1} / ${State.totalPages}`;
            },

            saveCurrentPage: () => {
                // On sauvegarde l'état actuel du canvas dans le tableau à l'index courant
                // On utilise toObject avec tes customProps
                const json = State.canvas.toObject(customProps);
                State.pages[State.currentPage] = json;
            },

            loadPage: (index) => {
                // --- CORRECTIF : ON VIDE LA MÉMOIRE DE LA SÉQUENCE ---
                State.sequenceList = [];
                State.isSequencing = false;
                // ----------------------------------------------------

                State.canvas.clear();
                const json = State.pages[index];

                if (json) {
                    State.canvas.loadFromJSON(json, () => {
                        State.canvas.renderAll();

                        // Réparation des liens (Background/Text)
                        if (App.fixImport) App.fixImport();
                        else if (App.restoreRefs) App.restoreRefs();

                        // Verrouillage du fond
                        const bg = State.canvas.getObjects().find(o => o.isBackground);
                        if (bg) {
                            bg.set({ selectable: false, evented: false, lockMovementX: true, lockMovementY: true });
                            State.canvas.sendToBack(bg);
                        }

                        Navigator.refresh();

                        // Reset visuel du bouton Séquence (au cas où il était resté orange)
                        const btnSeq = document.getElementById('btn-seq');
                        if (btnSeq) {
                            btnSeq.innerHTML = '<i class="fa-solid fa-arrow-down-1-9"></i> Séquence';
                            btnSeq.classList.remove('font-bold', 'bg-orange-100', 'px-2', 'rounded');
                        }
                    });
                } else {
                    App.loadBlank();
                }
                State.currentPage = index;
                App.updatePageIndicator();
            },
            changePage: (delta) => {
                const newIndex = State.currentPage + delta;
                // Vérification des limites (pas moins de 0, pas plus que le total)
                if (newIndex >= 0 && newIndex < State.totalPages) {
                    App.saveCurrentPage(); // Sauvegarder AVANT de partir
                    App.loadPage(newIndex); // Charger la nouvelle
                }
            },
            // --- OUTIL DE CALIBRAGE ---
            addCalibrationMarks: () => {
                // On récupère les dimensions de la page A4 (595 x 842)
                const w = State.canvas.pageW;
                const h = State.canvas.pageH;
                // On récupère le décalage de la feuille par rapport au canvas
                const offX = State.canvas.pageOffset.x;
                const offY = State.canvas.pageOffset.y;

                // Création de 4 carrés rouges de 20x20px
                const makeRect = (l, t, name) => {
                    const r = new fabric.Rect({
                        left: l + offX, // On ajoute offX pour se caler sur la feuille
                        top: t + offY,  // On ajoute offY pour se caler sur la feuille
                        width: 20,
                        height: 20,
                        fill: 'red',
                        stroke: 'black',
                        strokeWidth: 1,
                        opacity: 0.5
                    });
                    // Petit texte pour identifier le coin
                    const txt = new fabric.Text(name, {
                        left: l + offX + 2, top: t + offY + 5, fontSize: 8, fill: 'white'
                    });
                    return new fabric.Group([r, txt], { ctype: 'draw', pid: 'calib_' + name });
                };

                // 1. Coin Haut-Gauche (doit être à 0,0)
                State.canvas.add(makeRect(0, 0, "TL"));

                // 2. Coin Bas-Droite (doit être tout en bas à droite)
                // On retire 20px (taille du carré) pour qu'il soit DANS la feuille
                State.canvas.add(makeRect(w - 20, h - 20, "BR"));

                State.canvas.requestRenderAll();
                // Lance l'export tout de suite pour voir
                setTimeout(() => Exporter.download(), 500);
            },
            copyStyle: (source) => {
                if (!source) return;
                const s = source;

                // 1. Sauvegarde du style (code identique)
                State.clipboardStyle = {
                    fill: s.fill,
                    stroke: s.stroke,
                    strokeWidth: s.strokeWidth,
                    opacity: s.opacity,
                    fontFamily: (s.txtObj || s).fontFamily,
                    fontSize: (s.txtObj || s).fontSize,
                    bStyle: s.bStyle || 'solid',
                    textAlign: s.tAlign || 'left'
                };

                // 2. Mise à jour visuelle Toolbar (Header)
                document.getElementById('g-fill').value = App.toHex(State.clipboardStyle.fill);
                document.getElementById('preview-fill').style.backgroundColor = State.clipboardStyle.fill;
                document.getElementById('g-stroke').value = App.toHex(State.clipboardStyle.stroke);
                document.getElementById('preview-stroke').style.backgroundColor = State.clipboardStyle.stroke;
                document.getElementById('g-width').value = State.clipboardStyle.strokeWidth;

                // 3. NOUVEAU : On active visuellement le bouton Pinceau
                const btnPainter = document.getElementById('btn-painter');
                btnPainter.classList.remove('opacity-40');
                btnPainter.classList.add('text-blue-600'); // Optionnel : mettre en couleur pour attirer l'oeil

                // 4. UX Fluide : On passe automatiquement en mode Pinceau après la capture
                App.setTool('painter');

                // Petit feedback discret (Toast) au lieu d'une grosse modale bloquante
                // (Tu peux garder App.showModal si tu préfères, mais c'est moins fluide)
                App.showToast("Style copié !", "success");
            },
            pasteStyle: (target) => {
                if (!target || !State.clipboardStyle) return;
                const st = State.clipboardStyle;

                // On applique au conteneur (rect/circle...)
                const bg = target.bgObj || target;
                bg.set({
                    fill: st.fill,
                    stroke: st.stroke,
                    strokeWidth: st.strokeWidth,
                    opacity: st.opacity
                });

                // Gestion des bordures spéciales (pointillés)
                target.bStyle = st.bStyle;
                if (st.bStyle === 'none') bg.set({ strokeDashArray: [4, 4], stroke: '#cccccc' });
                else if (st.bStyle === 'underline') bg.set({ strokeDashArray: [10, 5] });
                else bg.set({ strokeDashArray: null });

                // On applique au texte si applicable
                const txt = target.txtObj || (target.type === 'i-text' ? target : null);
                if (txt) {
                    if (st.fontFamily) txt.set('fontFamily', st.fontFamily);
                    if (st.fontSize) txt.set('fontSize', st.fontSize);
                    if (target.ctype === 'label') target.set('fill', st.stroke); // Le label prend la couleur du trait
                    //  Panel.dom.fontSize.value = newFontSize;
                }

                // Alignement
                if (st.textAlign) {
                    target.tAlign = st.textAlign;
                    if (txt) txt.set('textAlign', st.textAlign);
                }

                State.canvas.requestRenderAll();
                History.save();
                // Optionnel : On peut rester en mode pinceau pour coller sur plusieurs objets, 
                // ou revenir en mode select. Ici je propose de rester en pinceau.
            },
            // --- DÉBUT BLOC SMART GUIDES ---
            drawSmartGuide: (ctx, x1, y1, x2, y2) => {
                ctx.save();
                ctx.strokeStyle = "#ff0055"; // Rouge 'Pro'
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]); // Pointillés
                ctx.beginPath();
                ctx.moveTo(x1 + 0.5, y1 + 0.5); // +0.5 pour des lignes nettes (anti-aliasing)
                ctx.lineTo(x2 + 0.5, y2 + 0.5);
                ctx.stroke();
                ctx.restore();
            },

            smartGuides: (target) => {
                const canvas = State.canvas;
                const threshold = 4 / canvas.getZoom();

                // 1. On vide la liste au début (pour effacer les guides précédents)
                State.snapLines = [];

                if (!State.snap) return { x: 0, y: 0 };

                const tBR = target.getBoundingRect(true, true);
                const tPoints = {
                    h: [tBR.top, tBR.top + tBR.height / 2, tBR.top + tBR.height],
                    v: [tBR.left, tBR.left + tBR.width / 2, tBR.left + tBR.width]
                };

                const candidates = canvas.getObjects().filter(o => {
                    return o !== target && o.visible && !o.isGuide && !o.isBackground &&
                        !(target.type === 'activeSelection' && target.contains(o));
                });

                let dx = 0, dy = 0;
                let snappedH = false, snappedV = false;

                for (let cand of candidates) {
                    if (snappedH && snappedV) break;

                    const cBR = cand.getBoundingRect(true, true);
                    const cPoints = {
                        h: [cBR.top, cBR.top + cBR.height / 2, cBR.top + cBR.height],
                        v: [cBR.left, cBR.left + cBR.width / 2, cBR.left + cBR.width]
                    };

                    // Alignement Horizontal
                    if (!snappedH) {
                        for (let tp of tPoints.h) {
                            for (let cp of cPoints.h) {
                                if (Math.abs(tp - cp) < threshold) {
                                    dy = cp - tp;
                                    State.snapLines.push({ vertical: false, y: cp });
                                    snappedH = true; break;
                                }
                            }
                            if (snappedH) break;
                        }
                    }

                    // Alignement Vertical
                    if (!snappedV) {
                        for (let tp of tPoints.v) {
                            for (let cp of cPoints.v) {
                                if (Math.abs(tp - cp) < threshold) {
                                    dx = cp - tp;
                                    State.snapLines.push({ vertical: true, x: cp });
                                    snappedV = true; break;
                                }
                            }
                            if (snappedV) break;
                        }
                    }
                }

                // --- CORRECTION EST ICI ---
                // On demande TOUJOURS le redessin à la fin de la fonction.
                // Si State.snapLines est vide, after:render ne dessinera rien 
                // et le rafraîchissement effacera les anciennes lignes rouges.
                canvas.requestRenderAll();

                return { x: dx, y: dy };
            },
            // --- FIN BLOC SMART GUIDES ---
            toggleSequenceMode: () => {

                State.isSequencing = !State.isSequencing;
                const btn = document.getElementById('btn-seq');

                if (State.isSequencing) {
                    // ACTIVATION
                    State.mode = 'sequence'; // Bloque les autres outils
                    State.sequenceList = []; // On reset la liste temporaire
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                    State.canvas.defaultCursor = 'crosshair'; // Curseur cible

                    btn.innerHTML = '<i class="fa-solid fa-check"></i> Terminer';
                    btn.classList.add('font-bold', 'bg-orange-100', 'px-2', 'rounded');
                    App.showModal("Mode Séquence", "Cliquez sur les champs un par un dans l'ordre souhaité (1, 2, 3...).\nLes champs déjà cliqués deviendront verts.");
                } else {
                    // DÉSACTIVATION & APPLICATION
                    State.mode = 'select';
                    State.canvas.defaultCursor = 'default';

                    btn.innerHTML = '<i class="fa-solid fa-arrow-down-1-9"></i> Séquence';
                    btn.classList.remove('font-bold', 'bg-orange-100', 'px-2', 'rounded');

                    // On réorganise vraiment les objets maintenant
                    if (State.sequenceList.length > 0) {
                        // 1. On sépare les objets non concernés (Background, images déco...)
                        const allObjs = State.canvas.getObjects();
                        const background = allObjs.filter(o => o.isBackground);
                        const others = allObjs.filter(o => !State.sequenceList.includes(o) && !o.isBackground);

                        // 2. On vide le canvas (sans effacer le contexte, juste la liste)
                        State.canvas.remove(...allObjs);

                        // 3. On remet tout dans le bon ordre : 
                        // Fond -> Objets non triés -> Objets triés (1, 2, 3...)
                        background.forEach(o => State.canvas.add(o));
                        others.forEach(o => State.canvas.add(o));
                        State.sequenceList.forEach(o => State.canvas.add(o));

                        State.canvas.requestRenderAll();
                        History.save();
                        Navigator.refresh();
                    }
                }
            },
            stringToColor: (str) => {
                let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); }
                const c = (hash & 0x00FFFFFF).toString(16).toUpperCase(); return '#' + "00000".substring(0, 6 - c.length) + c;
            },
            init: () => {
                // 0. (NOUVEAU) MODE SILENCIEUX PDF.JS
                // On dit à PDF.js de ne signaler que les erreurs critiques, pas les warnings de polices.
                if (window.pdfjsLib) {
                    window.pdfjsLib.GlobalWorkerOptions.verbosity = window.pdfjsLib.VerbosityLevel.ERRORS;
                }

                // 1. Initialisation du Canvas
                State.canvas = new fabric.Canvas('c', {
                    preserveObjectStacking: true,
                    fireRightClick: true,
                    stopContextMenu: true,
                    backgroundColor: null
                });

                // 2. Gestion du redimensionnement & SCROLL (CORRECTIF BUG SÉLECTION)
                App.resize();
                window.addEventListener('resize', () => {
                    App.resize();
                    State.canvas.calcOffset(); // Recalcule la position après resize
                });

                // --> C'EST ICI LA MAGIE POUR LE CLIC QUI RATE <--
                window.addEventListener('scroll', () => {
                    if (State.canvas) State.canvas.calcOffset();
                }, { passive: true });

                // 3. Gestion du Clic Droit (Menu Contextuel)
                State.canvas.upperCanvasEl.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    const target = State.canvas.findTarget(e);
                    if (target && !target.isBackground) {
                        State.canvas.setActiveObject(target);
                        const menu = document.getElementById('context-menu');
                        menu.style.left = e.clientX + 'px';
                        menu.style.top = e.clientY + 'px';
                        menu.classList.remove('hidden');
                    }
                });

                // Cache le menu quand on clique ailleurs
                document.addEventListener('click', () => App.hideCtx());

                // 4. Chargement de la page blanche par défaut
                App.loadBlank();

                // 5. Écouteurs d'événements Fabric
                State.canvas.on('object:modified', History.save);
                // GESTION DU REDIMENSIONNEMENT (Panel + Anti-Distortion)
                // GESTION DU REDIMENSIONNEMENT INTELLIGENT
                // DANS App.init() ... State.canvas.on('object:scaling', ...)

                State.canvas.on('object:scaling', function (e) {
                    const target = e.target;
                    // On vérifie si c'est un de nos objets gérés
                    if (!target || !['textfield', 'textarea', 'dropdown'].includes(target.ctype)) return;

                    // 1. Calcul des vraies dimensions en pixels (pour éviter l'effet d'étirement)
                    const finalW = Math.round(target.width * target.scaleX);
                    const finalH = Math.round(target.height * target.scaleY);

                    // 2. On applique les dimensions et on remet l'échelle à 1
                    target.set({ width: finalW, height: finalH, scaleX: 1, scaleY: 1 });

                    // 3. Mise à jour du fond (Rectangle)
                    if (target.bgObj) {
                        target.bgObj.set({
                            width: finalW, height: finalH,
                            left: -finalW / 2, top: -finalH / 2
                        });
                    }

                    // 4. Mise à jour du Texte (C'EST ICI QUE LA MAGIE OPÈRE)
                    if (target.txtObj) {

                        if (target.ctype === 'textfield' || target.ctype === 'dropdown') {
                            // --- CAS A : TextField / Dropdown ---
                            // On force le recalcul de la police selon la nouvelle hauteur
                            const newFontSize = Math.floor(finalH * 0.70);
                            target.txtObj.set('fontSize', newFontSize);

                            // On recentre verticalement avec cette nouvelle police
                            const textTop = (finalH - newFontSize) / 2;

                            target.txtObj.set({
                                width: finalW - 8,
                                left: (-finalW / 2) + 4,
                                top: (-finalH / 2) + Math.max(0, textTop)
                            });
                        } else {
                            // --- CAS B : TextArea ---
                            // On ne touche PAS à la police, on ajuste juste la largeur de la zone
                            target.txtObj.set({
                                width: finalW - 8,
                                left: (-finalW / 2) + 4,
                                top: (-finalH / 2) + 4 // Toujours calé en haut
                            });
                        }
                    }
                    if (target.ctype === 'dropdown' && target.arrowObj) {
                        // La flèche doit être calée à droite
                        // Coordonnée X = (Largeur / 2) - Marge (15px)
                        // Rappel : Dans un groupe, 0 est le centre. Donc le bord droit est à +Width/2

                        const arrowSize = target.txtObj.fontSize / 2; // Taille proportionnelle ou fixe selon ton choix

                        target.arrowObj.set({
                            width: arrowSize,
                            height: arrowSize,
                            left: (finalW / 2) - 15, // Toujours à 15px du bord droit
                            top: 0 // Centré verticalement (0 est le centre du groupe)
                            // Si le pivot de ta flèche n'est pas center/center, ajuste 'top'
                        });

                        // Si tu veux que la flèche change de taille avec la hauteur :
                        // target.arrowObj.scaleToWidth(newFontSize / 2);
                    }

                    target.setCoords();
                    Panel.update(target); // Met à jour le panneau de droite en direct
                });
                State.canvas.on('mouse:down', function (opt) {

                    const evt = opt.e;
                    if (State.mode === 'hand' || evt.altKey || evt.code === 'Space') {
                        this.isDragging = true;
                        this.selection = false;
                        this.lastPosX = evt.clientX;
                        this.lastPosY = evt.clientY;
                        this.setCursor('grabbing');
                    }
                });

                State.canvas.on('mouse:move', function (opt) {
                    if (this.isDragging) {
                        const e = opt.e;
                        const delta = {
                            x: e.clientX - this.lastPosX,
                            y: e.clientY - this.lastPosY
                        };
                        this.relativePan(delta);
                        this.lastPosX = e.clientX;
                        this.lastPosY = e.clientY;
                        // Optionnel mais fluide : force le rendu pendant le drag
                        this.requestRenderAll();
                    }
                });

                State.canvas.on('mouse:up', function (opt) {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.selection = true;
                        this.setCursor(State.mode === 'hand' ? 'grab' : 'default');


                    }
                    State.snapLines = [];
                    State.canvas.requestRenderAll();
                    // ← LA CORRECTION CLÉ : Nettoie les résidus de smart guides
                    this.clearContext(this.contextTop);
                    this.requestRenderAll();
                });
                // Rendu visuel (Lignes Radio + Numéros Séquence + Coordonnées corrigées)
                // Rendu visuel (Lignes Radio + Numéros Séquence + Guides Magnétiques)
                State.canvas.on('after:render', ctx => {
                    if (State.isPreview) return;

                    const ctx2 = State.canvas.getContext();
                    const vpt = State.canvas.viewportTransform;
                    const pixelRatio = State.canvas.getRetinaScaling();

                    const getCoords = (o) => {
                        if (!o) return { x: 0, y: 0 };
                        let p = o.getPointByOrigin('left', 'top');
                        if (o.group) p = fabric.util.transformPoint(p, o.group.calcTransformMatrix());
                        return { x: p.x * vpt[0] + vpt[4], y: p.y * vpt[3] + vpt[5] };
                    };

                    // --- A. LIGNES (Si activé via Header) ---
                    if (State.showFlowLines && State.sequenceList && State.sequenceList.length > 1) {
                        ctx2.save();
                        ctx2.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                        ctx2.lineWidth = 2;
                        ctx2.strokeStyle = "#3b82f6"; // Bleu
                        ctx2.setLineDash([5, 5]);

                        for (let i = 0; i < State.sequenceList.length - 1; i++) {
                            const cur = State.sequenceList[i];
                            const next = State.sequenceList[i + 1];

                            // Si un objet a été supprimé ou n'est plus sur le canvas, on ignore
                            if (!cur || !next || !State.canvas.contains(cur) || !State.canvas.contains(next)) continue;

                            const p1 = getCoords(cur);
                            const p2 = getCoords(next);

                            ctx2.beginPath();
                            ctx2.moveTo(p1.x, p1.y);
                            ctx2.lineTo(p2.x, p2.y);
                            ctx2.stroke();
                        }
                        ctx2.restore();
                    }

                    // --- B. PASTILLES ---
                    const inputs = State.canvas.getObjects().filter(o => ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(o.ctype));

                    inputs.forEach((o, i) => {
                        const pos = getCoords(o);
                        const seqIndex = State.sequenceList ? State.sequenceList.indexOf(o) : -1;

                        let badgeColor = "#2563eb";
                        let text = i + 1; // Par défaut : ordre de création (calque)

                        // 1. Si on est en mode "Édition Séquence" (1-9)
                        if (State.isSequencing) {
                            if (seqIndex !== -1) {
                                badgeColor = "#16a34a"; // Vert
                                text = seqIndex + 1;
                            } else {
                                badgeColor = "#9ca3af"; // Gris
                                text = "?";
                            }
                        }
                        // 2. Si on est en mode "Vue Flux" (Route)
                        else if (State.showFlowLines) {
                            // On affiche le numéro de la séquence pour suivre le fil
                            if (seqIndex !== -1) {
                                text = seqIndex + 1;
                            } else {
                                // Si l'objet n'est pas dans la liste (ex: ajouté après), on le signale discrètement
                                text = "+";
                                badgeColor = "#9ca3af";
                            }
                        }

                        ctx2.save();
                        ctx2.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                        ctx2.translate(pos.x, pos.y);

                        ctx2.fillStyle = badgeColor;
                        ctx2.beginPath();
                        ctx2.arc(0, 0, 9, 0, 2 * Math.PI);
                        ctx2.fill();

                        ctx2.fillStyle = "white";
                        ctx2.font = "bold 11px sans-serif";
                        ctx2.textAlign = "center";
                        ctx2.textBaseline = "middle";
                        ctx2.fillText(text, 0, 1);
                        ctx2.restore();
                    });


                });         // 6. Bindings globaux
                App.bindEvents();
                App.bindKeys();

                // 7. VÉRIFICATION AUTO-SAVE
                setTimeout(() => {
                    App.checkAutoSave();
                }, 500);
            },

            closeModal: () => {
                const ov = document.getElementById('modal-overlay');
                ov.classList.remove('modal-enter-active');
                ov.classList.add('modal-exit');
                setTimeout(() => {
                    ov.classList.add('hidden');
                    ov.classList.remove('modal-exit', 'modal-enter');
                }, 200);
            },
            resize: () => { const el = document.getElementById('workspace'); State.canvas.setWidth(el.clientWidth); State.canvas.setHeight(el.clientHeight); State.canvas.calcOffset(); },
            loadBlank: () => {
                // --- 1. LE FIX EST ICI (AJOUTEZ CES 2 LIGNES) ---
                State.sequenceList = [];    // On vide la mémoire des séquences
                State.isSequencing = false; // On désactive le mode séquence
                // ------------------------------------------------

                State.canvas.clear();

                // Dimensions A4 standard
                const w = 595, h = 842;
                State.canvas.pageW = w;
                State.canvas.pageH = h;

                const cx = (State.canvas.width / 2 - w / 2), cy = 20;
                State.canvas.pageOffset = { x: cx, y: cy };

                // Création du fond blanc
                const bg = new fabric.Rect({
                    width: w, height: h,
                    fill: 'white',
                    shadow: { color: 'rgba(0,0,0,0.1)', blur: 10 },
                    selectable: false, evented: false, hasControls: false,
                    lockMovementX: true, lockMovementY: true,
                    isBackground: true,
                    left: cx, top: cy
                });

                State.canvas.add(bg);
                State.canvas.sendToBack(bg);

                // --- NOUVEAU : INITIALISATION MULTI-PAGES ---
                State.pages = []; // On vide tout
                State.totalPages = 1;
                State.currentPage = 0;

                // On sauvegarde immédiatement cette page blanche comme "Page 1"
                const json = State.canvas.toObject(customProps);
                State.pages[0] = json;

                App.updatePageIndicator();
                State.canvas.requestRenderAll();
            },            // Appelle cette fonction juste après loadFromJSON
            restoreRefs: () => {
                const objs = State.canvas.getObjects();

                objs.forEach(obj => {
                    // On cible uniquement nos champs
                    if (['textfield', 'textarea', 'dropdown'].includes(obj.ctype)) {

                        // 1. On reconnecte les fils
                        const items = obj.getObjects();
                        obj.bgObj = items[0]; // Le rect est toujours le 1er
                        obj.txtObj = items[1]; // Le texte est toujours le 2ème

                        // 2. Sécurité : On s'assure que Fabric n'a pas remis "Center" par défaut
                        if (obj.originX !== 'left') {
                            // Astuce : On remet en left sans bouger l'objet visuellement
                            const p = obj.getPointByOrigin('left', 'top');
                            obj.set({ originX: 'left', originY: 'top' });
                            obj.setPositionByOrigin(p, 'left', 'top');
                        }

                        // 3. On remet les contrôles (Cachés par défaut à l'import)
                        const controls = { mtr: false }; // Pas de rotation
                        if (obj.ctype === 'textfield') {
                            Object.assign(controls, { mt: false, mb: false, ml: true, mr: true });
                            obj.set('lockScalingY', true);
                        } else {
                            Object.assign(controls, { mt: true, mb: true, ml: true, mr: true });
                        }
                        obj.setControlsVisibility(controls);
                    }
                });

                State.canvas.requestRenderAll();
            },
            setSideTab: (tab) => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-btn-' + tab).classList.add('active');
                document.getElementById('view-props').classList.add('hidden');
                document.getElementById('view-bank').classList.add('hidden');
                document.getElementById('view-templates').classList.add('hidden');
                document.getElementById('view-' + tab).classList.remove('hidden');
                if (tab === 'props') Panel.update(State.canvas.getActiveObject());
            },
            togglePreview: () => {
                State.isPreview = !State.isPreview;
                const btn = document.getElementById('btn-preview');
                const tb = document.getElementById('toolbar-main');
                const side = document.getElementById('sidebar-tools');
                const props = document.getElementById('panel-right');

                if (State.isPreview) {
                    btn.classList.add('bg-blue-100', 'text-blue-600');
                    tb.style.opacity = '0'; tb.style.pointerEvents = 'none';
                    side.style.transform = 'translateX(-100%)';
                    props.style.transform = 'translateX(100%)';
                    State.canvas.discardActiveObject();
                    State.canvas.getObjects().forEach(o => o.selectable = false);
                } else {
                    btn.classList.remove('bg-blue-100', 'text-blue-600');
                    tb.style.opacity = '1'; tb.style.pointerEvents = 'all';
                    side.style.transform = 'translateX(0)';
                    props.style.transform = 'translateX(0)';
                    State.canvas.getObjects().forEach(o => { if (!o.isBackground) o.selectable = true; });
                }
                State.canvas.requestRenderAll();
            },
            syncSequenceFromDOM: function () {
                // 1. On récupère tous les éléments de la liste dans leur NOUVEL ORDRE visuel
                // (Adaptez '.layer-item' sélecteur CSS de vos éléments de liste)
                const listItems = document.querySelectorAll('#layer-list .layer-item');

                const newOrder = [];

                listItems.forEach(item => {
                    // On récupère l'ID stocké dans le HTML
                    const targetId = item.getAttribute('data-id');

                    // On cherche l'objet correspondant dans le Canvas
                    // Note: Assurez-vous que vos objets Fabric ont bien une propriété .id ou .name unique
                    const obj = State.canvas.getObjects().find(o => o.id === targetId);

                    if (obj) {
                        newOrder.push(obj);
                    }
                });

                // 2. On met à jour la liste officielle de séquence
                State.sequenceList = newOrder;

                // 3. On redessine le canvas pour mettre à jour les numéros et les flèches
                State.canvas.requestRenderAll();
            },
            // AJOUTER DANS L'OBJET App = { ... }

            toggleFlowLines: function () {
                State.showFlowLines = !State.showFlowLines;

                // 1. Initialisation automatique si la liste est vide
                if (State.showFlowLines && (!State.sequenceList || State.sequenceList.length === 0)) {
                    // On prend tous les champs valides et on les trie par leur position Z (Ordre des calques)
                    // car c'est l'ordre par défaut de Tabulation dans un PDF.
                    const inputs = State.canvas.getObjects().filter(o => ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(o.ctype));
                    State.sequenceList = inputs;
                }

                // 2. Gestion visuelle du bouton
                const btn = document.getElementById('btn-flow-toggle');
                if (btn) {
                    if (State.showFlowLines) {
                        btn.classList.remove('bg-white', 'text-gray-500', 'border-gray-200');
                        btn.classList.add('bg-blue-50', 'text-blue-600', 'border-blue-400', 'ring-1', 'ring-blue-200');
                    } else {
                        btn.classList.add('bg-white', 'text-gray-500', 'border-gray-200');
                        btn.classList.remove('bg-blue-50', 'text-blue-600', 'border-blue-400', 'ring-1', 'ring-blue-200');
                    }
                }
                State.canvas.requestRenderAll();
            },

            syncSequenceFromLayers: function () {
                // Cette fonction synchronise la liste de séquence avec l'ordre visuel des calques (Navigator)
                const allObjs = State.canvas.getObjects();

                // On ne garde que les champs de formulaire
                const inputs = allObjs.filter(o => ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(o.ctype));

                // On met à jour la liste officielle. 
                // Comme canvas.getObjects() retourne les objets du bas vers le haut (0 = fond, N = premier plan),
                // et que l'ordre de tabulation suit souvent cet ordre (ou l'inverse), on aligne les deux.
                State.sequenceList = inputs;

                // On peut aussi trier par position visuelle (Haut -> Bas) si tu préfères :
                // App.autoSort(); 
            },


            autoSort: () => {
                const objs = State.canvas.getObjects();
                const formItems = objs.filter(o => o.ctype && !o.isBackground && !o.isGuide);
                const others = objs.filter(o => !formItems.includes(o) && !o.isBackground);
                formItems.sort((a, b) => {
                    const ay = Math.round(a.top / 10), by = Math.round(b.top / 10);
                    if (ay !== by) return ay - by;
                    return a.left - b.left;
                });
                State.canvas.remove(...objs);
                const bg = objs.find(o => o.isBackground);
                if (bg) State.canvas.add(bg);
                others.forEach(o => State.canvas.add(o));
                formItems.forEach(o => State.canvas.add(o));
                State.canvas.requestRenderAll();
                History.save();
                App.showModal("Tri Automatique", "L'ordre de tabulation a été réorganisé de haut en bas.");
            },
            align: (mode) => {
                const selection = State.canvas.getActiveObjects();
                if (selection.length < 2) return;

                State.canvas.discardActiveObject();

                const minX = Math.min(...selection.map(o => o.left));
                const maxX = Math.max(...selection.map(o => o.left + o.getScaledWidth()));

                const minY = Math.min(...selection.map(o => o.top));
                const maxY = Math.max(...selection.map(o => o.top + o.getScaledHeight()));

                if (mode === 'left') {
                    selection.forEach(o => o.set('left', minX));
                } else if (mode === 'center') {
                    const centerX = minX + (maxX - minX) / 2;
                    selection.forEach(o => o.set('left', centerX - o.getScaledWidth() / 2));
                } else if (mode === 'right') {
                    selection.forEach(o => o.set('left', maxX - o.getScaledWidth()));
                } else if (mode === 'top') {
                    selection.forEach(o => o.set('top', minY));
                } else if (mode === 'middle') {
                    const centerY = minY + (maxY - minY) / 2;
                    selection.forEach(o => o.set('top', centerY - o.getScaledHeight() / 2));
                } else if (mode === 'bottom') {
                    selection.forEach(o => o.set('top', maxY - o.getScaledHeight()));
                } else if (mode === 'dist-v') {
                    selection.sort((a, b) => a.top - b.top);
                    const first = selection[0]; const last = selection[selection.length - 1];
                    const totalH = last.top - first.top;
                    const gap = totalH / (selection.length - 1);
                    selection.forEach((o, i) => { if (i > 0 && i < selection.length - 1) o.set('top', first.top + (gap * i)); });
                } else if (mode === 'dist-h') {
                    selection.sort((a, b) => a.left - b.left);
                    const first = selection[0]; const last = selection[selection.length - 1];
                    const distance = (last.left - first.left) / (selection.length - 1);
                    selection.forEach((o, i) => { if (i > 0 && i < selection.length - 1) o.set('left', first.left + (distance * i)); });
                }

                const sel = new fabric.ActiveSelection(selection, { canvas: State.canvas });
                State.canvas.setActiveObject(sel);
                State.canvas.requestRenderAll();
                History.save();
            },
            applyBatchGroup: () => {
                const name = document.getElementById('batch-grp-name').value;
                if (!name) return;
                const active = State.canvas.getActiveObject();
                if (active && active.type === 'activeSelection') {
                    active.forEachObject(o => {
                        if (o.ctype === 'radio') {
                            o.set('grp', name);
                        }
                    });
                    State.canvas.requestRenderAll();
                    History.save();
                    App.showModal("Groupe Radio", "Le groupe '" + name + "' a été appliqué avec succès.");
                }
            },
            copy: () => {
                const active = State.canvas.getActiveObject();
                if (!active || active.isBackground) return;
                active.clone(cloned => { State.clipboard = cloned; }, customProps);
            },
            paste: () => {
                if (!State.clipboard) return;
                State.clipboard.clone(cloned => {
                    State.canvas.discardActiveObject();
                    cloned.set({ left: cloned.left + 10, top: cloned.top + 10, evented: true });
                    const assignIds = (o) => { Factory.ensureUniqueId(o); };
                    if (cloned.type === 'activeSelection') {
                        cloned.canvas = State.canvas; cloned.forEachObject(assignIds); cloned.forEachObject(o => State.canvas.add(o)); cloned.setCoords();
                    } else {
                        assignIds(cloned); State.canvas.add(cloned);
                    }
                    State.canvas.setActiveObject(cloned); State.canvas.requestRenderAll(); App.restoreRefs(); History.save();
                }, customProps);
            },
            duplicate: () => { App.copy(); App.paste(); },
            setTool: (t) => {
                // 0. LOGIQUE TOGGLE (INTERRUPTEUR)
                // Si je clique sur le 'size-painter' alors qu'il est déjà actif, 
                // je décide basculer vers 'select' (ce qui va éteindre le pinceau)
                if (t === 'size-painter' && State.mode === 'size-painter') {
                    t = 'select';
                }

                // 1. RESET VISUEL (On éteint toujours le bouton avant d'aller plus loin)
                // Cela garantit qu'il s'éteindra si on repasse en 'select'
                const sizeBtn = document.getElementById('btn-size-painter');
                if (sizeBtn) {
                    sizeBtn.classList.remove('bg-black', 'text-white');
                    sizeBtn.classList.add('bg-gray-100', 'text-gray-500');
                }

                // 2. GESTION DES OUTILS DE GAUCHE
                if (t === 'select') {
                    State.mode = 'select';
                    _uiActiveTool(t); // Active l'icône flèche à gauche
                    State.canvas.defaultCursor = 'default';
                    State.canvas.selection = true;
                }
                else if (t === 'hand') {
                    State.mode = 'hand';
                    _uiActiveTool(t);
                    State.canvas.defaultCursor = 'grab';
                    State.canvas.selection = false;
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                }
                else if (t === 'picker') {
                    State.mode = 'picker';
                    _uiActiveTool(t);
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                    State.canvas.defaultCursor = 'crosshair';
                }
                else if (t === 'painter') {
                    State.mode = 'painter';
                    _uiActiveTool(t);
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                    State.canvas.defaultCursor = 'copy';
                }

                // 3. GESTION DU PINCEAU DE TAILLE (HAUT)
                else if (t === 'size-painter') {
                    State.mode = 'size-painter';

                    // On désactive tout à gauche
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));

                    // On active visuellement le bouton du haut (Noir)
                    if (sizeBtn) {
                        sizeBtn.classList.remove('bg-gray-100', 'text-gray-500');
                        sizeBtn.classList.add('bg-black', 'text-white');
                    }

                    State.canvas.defaultCursor = 'cell';
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                }

                // 4. AUTRES OUTILS (Formes, etc.)
                else {
                    State.mode = t;
                    _uiActiveTool(t);
                    State.canvas.defaultCursor = 'crosshair';
                    State.canvas.selection = false;
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                }
            },

            setStyle: (key, val) => {
                // 1. Conversions de type
                if (key === 'size' || key === 'width') val = parseInt(val);
                if (key === 'lock') State.defaults.lock = val;
                else State.defaults[key] = val;

                // 2. Mise à jour UI des couleurs
                if (key === 'fill') document.getElementById('preview-fill').style.backgroundColor = val;
                if (key === 'stroke') document.getElementById('preview-stroke').style.backgroundColor = val;

                const objs = State.canvas.getActiveObjects();

                objs.forEach(obj => {
                    const target = obj.bgObj || obj;
                    const txt = obj.txtObj || (obj.type === 'i-text' ? obj : null);

                    if (key === 'size' && txt) {
                        // --- MODIFICATION ICI ---
                        // On applique la taille SAUF si c'est un TextField ou Dropdown
                        // (car pour eux, la taille est pilotée par la hauteur)
                        if (obj.ctype !== 'textfield' && obj.ctype !== 'dropdown' && obj.ctype !== 'textarea') {
                            txt.set('fontSize', val);
                        }

                        // Gestion de la géométrie interne des groupes
                        if (obj.ctype === 'textarea') {
                            // --- CORRECTION ICI ---
                            // (0,0) est le centre. Le haut est à -height/2.
                            // On place le texte tout en haut + 4px de marge.
                            txt.set({
                                top: (-obj.height / 2) + 4,
                                width: obj.width - 8
                            });
                        }
                    }
                    // -----------------------------------------

                    if (key === 'fill') target.set('fill', val);

                    if (key === 'stroke') {
                        target.set('stroke', val);
                        if (obj.ctype === 'label') obj.set('fill', val);
                    }

                    if (key === 'width') target.set('strokeWidth', val);
                    if (key === 'font' && txt) txt.set('fontFamily', val);

                    // Gestion du verrouillage (inchangée)
                    if (key === 'lock') {
                        if (obj.ctype === 'textfield') {
                            obj.set('lockScalingY', val);
                            if (val) obj.setControlsVisibility({ mt: false, mb: false });
                            else obj.setControlsVisibility({ mt: true, mb: true });
                        }
                        if (['checkbox', 'radio'].includes(obj.ctype)) {
                            obj.set({ lockScalingX: val, lockScalingY: val });
                            if (val) {
                                obj.setControlsVisibility({ tl: false, tr: false, bl: false, br: false, mtr: false, mt: false, mb: false, ml: false, mr: false });
                            } else {
                                obj.setControlsVisibility({ tl: true, tr: true, bl: true, br: true, mtr: false, mt: false, mb: false, ml: false, mr: false });
                            }
                        }
                    }
                });

                if (objs.length) {
                    State.canvas.requestRenderAll();
                    History.save();
                    Panel.update(objs[0]);
                }
            },
            deleteSelection: () => {
                const a = State.canvas.getActiveObjects().filter(o => !o.isBackground);
                if (a.length) { State.canvas.discardActiveObject(); State.canvas.remove(...a); Panel.update(null); History.save(); }
            },
            getSnapLines: (target) => {
                const zoom = State.canvas.getZoom();
                const snapDist = 10 / zoom;
                let vertical = [], horizontal = [];

                const tRect = target.getBoundingRect ? target.getBoundingRect(true, true) : { left: target.left, top: target.top, width: 0, height: 0 };
                const tCenter = { x: tRect.left + tRect.width / 2, y: tRect.top + tRect.height / 2 };

                State.canvas.getObjects().forEach(o => {
                    if (o === target || !o.visible || o.isGuide || o.isBackground || (target.type === 'activeSelection' && target.contains(o))) return;

                    const oRect = o.getBoundingRect(true, true);
                    const oCenter = { x: oRect.left + oRect.width / 2, y: oRect.top + oRect.height / 2 };

                    [oRect.left, oRect.left + oRect.width, oCenter.x].forEach(val => vertical.push(val));
                    [oRect.top, oRect.top + oRect.height, oCenter.y].forEach(val => horizontal.push(val));
                });
                return { vertical, horizontal, tRect, tCenter, snapDist };
            },
            snapMove: (target) => {
                if (!State.snap) return { x: 0, y: 0 };

                const { vertical, horizontal, tRect, tCenter, snapDist } = App.getSnapLines(target);
                let dx = 0, dy = 0; App.clearGuides();

                for (let v of vertical) {
                    if (Math.abs(tRect.left - v) < snapDist) { dx = v - tRect.left; App.drawGuide('v', v); break; }
                    if (Math.abs((tRect.left + tRect.width) - v) < snapDist) { dx = v - (tRect.left + tRect.width); App.drawGuide('v', v); break; }
                    if (Math.abs(tCenter.x - v) < snapDist) { dx = v - tCenter.x; App.drawGuide('v', v); break; }
                }

                for (let h of horizontal) {
                    if (Math.abs(tRect.top - h) < snapDist) { dy = h - tRect.top; App.drawGuide('h', h); break; }
                    if (Math.abs((tRect.top + tRect.height) - h) < snapDist) { dy = h - (tRect.top + tRect.height); App.drawGuide('h', h); break; }
                    if (Math.abs(tCenter.y - h) < snapDist) { dy = h - tCenter.y; App.drawGuide('h', h); break; }
                }

                return { x: dx, y: dy };
            },
            snapScale: (target, corner) => {
                if (!State.snap) return;
                const { vertical, horizontal, tRect, snapDist } = App.getSnapLines(target);
                App.clearGuides();
                if (corner.includes('r')) {
                    const match = vertical.find(v => Math.abs((tRect.left + tRect.width) - v) < snapDist);
                    if (match) { App.drawGuide('v', match); target.set('scaleX', (match - target.left) / target.width); }
                }
                if (corner.includes('b')) {
                    const match = horizontal.find(h => Math.abs((tRect.top + tRect.height) - h) < snapDist);
                    if (match) { App.drawGuide('h', match); target.set('scaleY', (match - target.top) / target.height); }
                }
            },
            drawGuide: (type, pos) => {
                const coords = type === 'v' ? [pos, -10000, pos, 10000] : [-10000, pos, 10000, pos];
                const exist = State.canvas.getObjects().find(o => o.isGuide && o.guideType === type && (type === 'v' ? Math.abs(o.x1 - pos) < 1 : Math.abs(o.y1 - pos) < 1));
                if (exist) return;
                const line = new fabric.Line(coords, { stroke: '#ff0055', strokeWidth: 1 / State.canvas.getZoom(), strokeDashArray: [4, 4], selectable: false, evented: false, excludeFromExport: true, opacity: 0.8 });
                line.isGuide = true; line.guideType = type; State.canvas.add(line);
            },
            clearGuides: () => { const guides = State.canvas.getObjects().filter(o => o.isGuide); if (guides.length) State.canvas.remove(...guides); },
            bindEvents: () => {
                let isDrawing = false, sx, sy, ghost;
                const C = State.canvas;
                let isDragging = false;

                // --- SÉCURITÉ ---
                let ignoreClick = false; // Le drapeau de sécurité

                // ============================================================
                // 1. GESTION DE LA BARRE FLOTTANTE (WYSIWYG)
                // ============================================================
                C.on('text:editing:entered', () => {
                    App.updateFloatBar();
                });

                C.on('text:editing:exited', () => {
                    document.getElementById('float-bar').classList.add('hidden');

                    // --- SÉCURITÉ ACTIVÉE ---
                    // On vient de sortir d'un texte, on interdit le dessin pendant 0.2s
                    // pour éviter que ce clic ne crée un nouvel objet
                    ignoreClick = true;
                    setTimeout(() => { ignoreClick = false; }, 200);
                });

                C.on('text:changed', () => {
                    App.updateFloatBar();
                });

                // ============================================================
                // 2. LE GARDIEN (UI)
                // ============================================================
                const checkRotation = () => {
                    const target = C.getActiveObject();
                    if (!target) { Panel.update(null); return; }

                    // Liste des types basiques interdits
                    const noRotationTypes = ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown', 'label', 'paragraph'];

                    let shouldBan = false;

                    if (target.type === 'activeSelection') {
                        // Si la sélection multiple contient un élément interdit (dont le rectangle), on bloque tout
                        shouldBan = target.getObjects().some(o =>
                            noRotationTypes.includes(o.ctype) || o.type === 'rect' // <--- AJOUT : Bloque les Rectangles
                        );
                    } else {
                        // 1. Vérification par type de formulaire (ctype)
                        if (noRotationTypes.includes(target.ctype)) shouldBan = true;

                        // 2. Vérification spécifique pour le RECTANGLE (type Fabric)
                        if (target.type === 'rect') shouldBan = true; // <--- C'EST ICI QUE CA SE JOUE
                    }

                    // Application : On cache (false) ou affiche (true) la poignée 'mtr'
                    target.setControlsVisibility({ mtr: !shouldBan });
                    target.lockRotation = shouldBan;

                    Panel.update(target);
                    Navigator.refresh();
                    C.requestRenderAll();
                };

                // ============================================================
                // 3. EVENTS SOURIS
                // ============================================================
                C.on('mouse:wheel', opt => {
                    if (opt.e.ctrlKey) return;
                    var d = opt.e.deltaY; var z = C.getZoom() * 0.999 ** d;
                    if (z > 20) z = 20; if (z < 0.01) z = 0.01;
                    C.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, z);
                    opt.e.preventDefault(); opt.e.stopPropagation();
                });

                C.on('mouse:down', function (opt) {

                    // --- VÉRIFICATION SÉCURITÉ ---
                    if (ignoreClick) return; // Si on vient de valider un texte, on arrête tout ici.

                    // SÉQUENCE
                    if (State.isSequencing) {
                        if (opt.target && ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(opt.target.ctype)) {
                            if (!State.sequenceList.includes(opt.target)) {
                                State.sequenceList.push(opt.target);
                                C.requestRenderAll();
                            }
                        }
                        return;
                    }

                    // MAIN / PAN
                    var e = opt.e;
                    if (e.altKey || e.code === 'Space' || State.mode === 'hand') {
                        this.isDragging = true;
                        this.selection = false;
                        this.lastPosX = e.clientX;
                        this.lastPosY = e.clientY;
                        this.setCursor('grabbing');
                        return;
                    }

                    // PAINTER
                    if (State.mode === 'size-painter') return;

                    if (opt.e.shiftKey || opt.e.ctrlKey || opt.e.metaKey) return;

                    // DESSIN
                    if (State.mode !== 'select' && State.mode !== 'hand' && State.mode !== 'picker' && State.mode !== 'painter' && !opt.target) {
                        isDrawing = true;
                        const ptr = C.getPointer(opt.e);
                        const fakeStart = { left: ptr.x, top: ptr.y, width: 0, height: 0, getBoundingRect: function () { return this; }, set: function () { } };
                        const startSnap = App.snapMove(fakeStart);
                        sx = ptr.x + startSnap.x; sy = ptr.y + startSnap.y;

                        if (['textfield', 'textarea', 'dropdown', 'rect', 'paragraph'].includes(State.mode)) {
                            ghost = new fabric.Rect({ left: sx, top: sy, width: 0, height: 0, fill: 'rgba(37,99,235,0.1)', stroke: '#2563eb', strokeWidth: 1, strokeDashArray: [4, 4], opacity: 1 });
                        }
                        else if (State.mode === 'circle') {
                            ghost = new fabric.Ellipse({ left: sx, top: sy, rx: 0, ry: 0, fill: 'rgba(37,99,235,0.1)', stroke: '#2563eb', strokeWidth: 1, strokeDashArray: [4, 4], opacity: 1 });
                        }
                        else if (State.mode === 'line') {
                            ghost = new fabric.Line([sx, sy, sx, sy], { stroke: '#2563eb', strokeWidth: 1, strokeDashArray: [4, 4] });
                        }

                        if (ghost) C.add(ghost);
                    }
                });

                C.on('mouse:move', function (opt) {
                    if (this.isDragging) {
                        var e = opt.e;
                        var v = this.viewportTransform;
                        v[4] += e.clientX - this.lastPosX;
                        v[5] += e.clientY - this.lastPosY;
                        this.requestRenderAll();
                        this.lastPosX = e.clientX;
                        this.lastPosY = e.clientY;
                        return;
                    }

                    const coord = document.getElementById('coord-display');
                    if (coord) coord.innerText = `x: ${Math.round(opt.pointer.x)} | y: ${Math.round(opt.pointer.y)}`;

                    if (isDrawing && ghost) {
                        const ptr = C.getPointer(opt.e);
                        let destX = ptr.x; let destY = ptr.y;
                        const mouseTarget = { left: destX, top: destY, width: 0, height: 0, getBoundingRect: function () { return this; } };
                        const snapD = App.snapMove(mouseTarget);
                        destX += snapD.x; destY += snapD.y;

                        let w = Math.abs(sx - destX); let h = Math.abs(sy - destY);
                        let l = Math.min(sx, destX); let t = Math.min(sy, destY);

                        if (State.defaults.lock) {
                            if (State.mode === 'textfield') { h = State.defaults.defHeight; t = (destY < sy) ? sy - h : sy; }
                            if (['checkbox', 'radio'].includes(State.mode)) { w = State.defaults.boxSize; h = State.defaults.boxSize; t = (destY < sy) ? sy - h : sy; l = (destX < sx) ? sx - w : sx; }
                        }

                        if (State.mode === 'line') { ghost.set({ x2: destX, y2: destY }); }
                        else if (State.mode === 'circle') { ghost.set({ rx: w / 2, ry: h / 2, left: l, top: t }); }
                        else { ghost.set({ width: w, height: h, left: l, top: t }); }
                        C.requestRenderAll();

                    } else if (!isDrawing && State.mode !== 'select' && State.mode !== 'hand' && State.mode !== 'size-painter') {
                        App.clearGuides();
                        const ptr = C.getPointer(opt.e);
                        const fakeTarget = { left: ptr.x, top: ptr.y, width: 0, height: 0, getBoundingRect: function () { return this; }, set: function () { } };
                        App.snapMove(fakeTarget);
                    } else if (State.mode === 'select') {
                        App.clearGuides();
                    }
                });

                C.on('mouse:up', function (opt) {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.selection = true;
                        this.setCursor(State.mode === 'hand' ? 'grab' : 'default');
                        return;
                    }

                    // PAINTER
                    if (State.mode === 'size-painter' && opt.target) {
                        const t = opt.target;
                        if (['checkbox', 'radio'].includes(t.ctype)) {
                            t.scaleToWidth(State.defaults.boxSize);
                            t.scaleToHeight(State.defaults.boxSize);
                        } else if (['textfield', 'dropdown', 'textarea'].includes(t.ctype)) {
                            t.scaleToHeight(State.defaults.defHeight);
                        }
                        t.setCoords(); C.requestRenderAll(); Panel.update(t); History.save();
                        return;
                    }

                    if (isDrawing) {
                        isDrawing = false; App.clearGuides(); const ptr = C.getPointer(opt.e);
                        let l, t, w, h;
                        if (ghost) { l = ghost.left; t = ghost.top; w = ghost.width * ghost.scaleX; h = ghost.height * ghost.scaleY; C.remove(ghost); ghost = null; }
                        else { l = sx; t = sy; w = 0; h = 0; }

                        const isClick = w < 5 && h < 5;
                        if (isClick) {
                            if (['textfield', 'dropdown'].includes(State.mode)) { w = 150; h = State.defaults.defHeight; }
                            else if (State.mode === 'textarea') { w = 250; h = State.defaults.defHeight * 3; }
                            else if (State.mode === 'paragraph') { w = 300; h = 100; }
                            else if (['rect', 'circle'].includes(State.mode)) { w = 100; h = 100; }
                            else if (State.mode === 'line') { w = 100; h = 0; }
                            else if (['checkbox', 'radio'].includes(State.mode)) { w = State.defaults.boxSize; h = State.defaults.boxSize; }
                        } else if (State.mode === 'textarea') h = Math.max(h, 50);

                        if (State.defaults.lock) {
                            if (State.mode === 'textfield') h = State.defaults.defHeight;
                            if (['checkbox', 'radio'].includes(State.mode)) { w = State.defaults.boxSize; h = State.defaults.boxSize; }
                        }

                        let obj = null;
                        if (['textfield', 'textarea', 'dropdown'].includes(State.mode)) obj = Factory.createInputGroup(l, t, w, h, State.mode);
                        else if (State.mode === 'paragraph') obj = Factory.createParagraph(l, t);
                        else if (State.mode === 'checkbox') obj = Factory.createCheckbox(l, t);
                        else if (State.mode === 'radio') obj = Factory.createRadio(l, t);
                        else if (State.mode === 'label') obj = Factory.createLabel(l, t);
                        else if (['rect', 'circle', 'line'].includes(State.mode)) {
                            if (State.mode === 'line') obj = Factory.createShape(State.mode, sx, sy, ptr.x - sx, ptr.y - sy);
                            else obj = Factory.createShape(State.mode, l, t, w, h);
                        }

                        if (obj) {
                            C.add(obj);
                            C.setActiveObject(obj);
                            Panel.update(obj);
                            History.save();

                            // J'AI ENLEVÉ App.setTool('select') ICI.
                            // L'outil reste actif, mais le flag ignoreClick protège la sortie de texte.
                        }
                    }

                    if (State.mode === 'select') C.selection = true;
                    State.canvas.clearContext(State.canvas.contextTop);
                    checkRotation();
                });

                C.on('object:moving', e => {
                    const target = e.target;
                    const snapD = App.snapMove(target);
                    target.left += snapD.x; target.top += snapD.y;
                    const smartD = App.smartGuides(target);
                    target.left -= snapD.x; target.top -= snapD.y;
                    if (smartD.x !== 0) target.left += smartD.x; else target.left += snapD.x;
                    if (smartD.y !== 0) target.top += smartD.y; else target.top += snapD.y;
                    Panel.update(target);
                });

                C.on('object:scaling', e => { if (e.transform && e.transform.corner) App.snapScale(e.target, e.transform.corner); });
                C.on('object:modified', () => App.clearGuides());

                // DANS App.bindEvents ...



                State.canvas.on('mouse:dblclick', (e) => {
                    const t = e.target;
                    if (!t) return;

                    // 1. Dropdown : Pas d'édition
                    if (t.ctype === 'dropdown') return;

                    // 2. Checkbox / Radio
                    if (t.ctype === 'checkbox' || t.ctype === 'radio') {
                        t.isChecked = !t.isChecked;
                        if (t.markObj) t.markObj.set('opacity', t.isChecked ? 1 : 0);
                        State.canvas.requestRenderAll();
                        Panel.update(t);
                        History.save();
                    }
                    // 3. Label
                    else if (t.ctype === 'label') {
                        t.enterEditing();
                        t.selectAll();
                    }
                    // 4. TEXTFIELD / TEXTAREA (Correction avec ignoreClick)
                    else if (t.txtObj && (t.ctype === 'textfield' || t.ctype === 'textarea')) {
                        const textObj = t.txtObj;

                        // Calcul position absolue
                        const matrix = t.calcTransformMatrix();
                        const absPos = fabric.util.transformPoint({ x: textObj.left, y: textObj.top }, matrix);

                        // On cache le vrai texte
                        textObj.set('opacity', 0);
                        t.addWithUpdate();

                        // Création du clone
                        const tempText = new fabric.Textbox(textObj.text, {
                            left: absPos.x,
                            top: absPos.y,
                            width: textObj.width * t.scaleX,
                            fontSize: textObj.fontSize * t.scaleY,
                            fontFamily: textObj.fontFamily,
                            textAlign: textObj.textAlign,
                            splitByGrapheme: t.ctype === 'textarea',
                            editable: true,
                            hasControls: false,
                            lockMovementX: true, lockMovementY: true,
                            cursorColor: 'blue'
                        });

                        State.canvas.add(tempText);
                        State.canvas.setActiveObject(tempText);
                        tempText.enterEditing();
                        tempText.selectAll();

                        // --- QUAND L'ÉDITION SE TERMINE ---
                        tempText.on('editing:exited', () => {
                            // A. ACTIVER LA SÉCURITÉ ANTI-CRÉATION
                            // On dit "Attention, je viens de finir d'éditer, ignore le prochain clic"
                            ignoreClick = true;

                            // B. Mise à jour du vrai texte
                            textObj.set('text', tempText.text);
                            textObj.set('opacity', 1);

                            // C. Nettoyage
                            State.canvas.remove(tempText);
                            t.addWithUpdate();
                            t.dirty = true;
                            State.canvas.requestRenderAll();
                            State.canvas.setActiveObject(t);
                            History.save();

                            // D. DÉSACTIVER LA SÉCURITÉ APRÈS UN COURT DÉLAI
                            // Ce délai de 200ms permet au clic "mouse:down" (qui a déclenché la fin de l'édition)
                            // d'être ignoré avant qu'on autorise à nouveau la création.
                            setTimeout(() => {
                                ignoreClick = false;
                            }, 200);
                        });
                    }
                });



                C.on('selection:created', checkRotation);
                C.on('selection:updated', checkRotation);
                C.on('selection:cleared', () => { Panel.update(null); Navigator.refresh(); });
            }

            , bindKeys: () => {
                document.addEventListener('keydown', e => {

                    // ------------------------------------------------------------
                    // 1. SÉCURITÉ : STOP si on est en train d'écrire
                    // ------------------------------------------------------------

                    // A. Vérification des Inputs HTML (Panneau de droite, Titre...)
                    const tag = e.target.tagName.toUpperCase();
                    // On bloque si c'est un INPUT (sauf checkbox/radio) ou un TEXTAREA
                    const isHtmlInput = (tag === 'INPUT' && !['CHECKBOX', 'RADIO', 'RANGE', 'COLOR'].includes(e.target.type.toUpperCase())) || tag === 'TEXTAREA';

                    // B. Vérification de l'édition sur le Canvas (FabricJS)
                    const activeObj = State.canvas.getActiveObject();
                    const isCanvasEditing = activeObj && (activeObj.isEditing || (activeObj.type === 'i-text' && activeObj.isEditing));
                    if (isCanvasEditing && e.key === 'Enter') {
                        // Si c'est un champ marqué "Ligne Unique", on valide et on sort
                        if (activeObj.isSingleLine) {
                            e.preventDefault(); // Empêche le saut de ligne
                            activeObj.exitEditing(); // Sort du mode édition
                            return;
                        }
                    }
                    // Si l'une des conditions est vraie, on arrête tout (la touche fera son action par défaut : écrire)
                    if (isHtmlInput || isCanvasEditing) return;


                    // ------------------------------------------------------------
                    // 2. DÉPLACEMENT AU CLAVIER (FLÈCHES)
                    // ------------------------------------------------------------
                    if (activeObj && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault(); // Empêche le scroll de la page web

                        const step = e.shiftKey ? 10 : 1; // Shift = Grand pas (10px)

                        if (e.key === 'ArrowUp') activeObj.top -= step;
                        if (e.key === 'ArrowDown') activeObj.top += step;
                        if (e.key === 'ArrowLeft') activeObj.left -= step;
                        if (e.key === 'ArrowRight') activeObj.left += step;

                        activeObj.setCoords(); // Recalcule la zone de clic
                        State.canvas.requestRenderAll();

                        // Mise à jour des valeurs X/Y dans le panneau de droite en temps réel
                        Panel.update(activeObj);

                        // Note : On ne sauvegarde pas l'historique à chaque pixel pour ne pas saturer le Undo
                        return;
                    }


                    // ------------------------------------------------------------
                    // 3. AUTRES RACCOURCIS
                    // ------------------------------------------------------------

                    // Outils
                    if (e.key.toLowerCase() === 'm') App.setTool('hand');
                    if (e.key.toLowerCase() === 'v' || e.key.toLowerCase() === 's' || e.key === 'Escape') App.setTool('select');

                    // Suppression
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        e.preventDefault();
                        App.deleteSelection();
                    }

                    // Main temporaire (Espace)
                    if (e.code === 'Space') {
                        if (State.mode !== 'hand') State.canvas.defaultCursor = 'grab';
                    }

                    // Combinaisons CTRL / CMD
                    const isCtrl = e.ctrlKey || e.metaKey;
                    if (isCtrl) {
                        if (e.key === 'z') { e.preventDefault(); History.undo(); }
                        else if (e.key === 'y') { e.preventDefault(); History.redo(); }
                        else if (e.key === 'c') { e.preventDefault(); App.copy(); }
                        else if (e.key === 'v') { e.preventDefault(); App.paste(); }
                        else if (e.key === 'd') { e.preventDefault(); App.duplicate(); }
                        else if (e.key === 's') { e.preventDefault(); Project.save(); }
                        else if (e.key === 'a') {
                            e.preventDefault();
                            // Tout sélectionner sauf le fond et les guides
                            const targets = State.canvas.getObjects().filter(o => !o.isBackground && !o.isGuide);
                            if (targets.length) {
                                const sel = new fabric.ActiveSelection(targets, { canvas: State.canvas });
                                State.canvas.setActiveObject(sel);
                                State.canvas.requestRenderAll();
                            }
                        }
                    }
                });

                // Relâchement Espace
                document.addEventListener('keyup', e => {
                    if (e.code === 'Space') {
                        // Retour au curseur de l'outil actif
                        if (State.mode === 'select') State.canvas.defaultCursor = 'default';
                        else if (State.mode === 'hand') State.canvas.defaultCursor = 'grab';
                        else State.canvas.defaultCursor = 'crosshair';

                        State.canvas.requestRenderAll();
                    }
                    // Sauvegarde intelligente : on sauve l'historique quand on relâche la flèche
                    // Cela évite d'avoir 50 étapes d'historique pour un déplacement de 50px
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        History.save();
                    }
                });
            }
        };


        function _uiActiveTool(t) { document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); const btn = document.getElementById('btn-' + t); if (btn) btn.classList.add('active'); }

        const Project = {
            // --- NOUVELLE FONCTION ---
            new: () => {
                App.askConfirm(
                    "Nouveau Projet",
                    "Tout travail non sauvegardé sera perdu. Voulez-vous vraiment effacer tout ?",
                    () => {
                        // ... (Le reste de votre code de réinitialisation ici) ...
                        State.pages = [];
                        State.currentPage = 0;
                        State.totalPages = 1;
                        State.pdfBytes = null;
                        State.sequenceList = [];
                        State.history = { stack: [], idx: -1 };
                        State.counts = { textfield: 1, textarea: 1, checkbox: 1, radio: 1, dropdown: 1, label: 1, rect: 1, circle: 1, radiogroup: 1, image: 1 };
                        document.getElementById('doc-title').value = "Nouveau_Projet";
                        App.loadBlank();
                        Navigator.refresh();
                        Panel.update(null);
                        localStorage.removeItem('prof_toolbox_autosave');

                        App.showToast("Nouveau projet créé", "info");
                    }
                );
            },
            // -------------------------

            save: () => {
                App.saveCurrentPage();
                const data = {
                    version: "V46_Studio",
                    timestamp: Date.now(),
                    pages: State.pages,
                    dims: { w: State.canvas.pageW, h: State.canvas.pageH, offX: State.canvas.pageOffset.x, offY: State.canvas.pageOffset.y }
                };
                const json = JSON.stringify(data);
                const blob = new Blob([json], { type: "application/json" });
                let filename = document.getElementById('doc-title').value.trim() || "projet";
                if (filename.toLowerCase().endsWith('.pdf')) filename = filename.slice(0, -4);
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `${filename}_projet.json`;
                link.click();
            },

            load: (e) => {
                const f = e.target.files[0];
                if (!f) return;
                const r = new FileReader();
                r.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!data.pages && data.objects) { State.pages = [data]; } else { State.pages = data.pages; }
                        if (data.dims) {
                            State.canvas.pageW = data.dims.w;
                            State.canvas.pageH = data.dims.h;
                            State.canvas.pageOffset = { x: data.dims.offX, y: data.dims.offY };
                            App.resize();
                        }
                        State.totalPages = State.pages.length;
                        State.currentPage = 0;

                        // Si on charge un projet, on considère qu'on n'a plus le PDF d'origine en mémoire binaire
                        // (Sauf si on voulait stocker le PDF en base64 dans le JSON, mais ça ferait des fichiers énormes)
                        State.pdfBytes = null;

                        App.loadPage(0);
                        //App.showModal("Projet chargé", `${State.totalPages} page(s) récupérée(s).`);
                        App.showToast("Projet chargé !", "");
                    } catch (err) {
                        console.error(err);
                        App.showModal("Erreur", "Fichier projet invalide.");
                    }
                };
                r.readAsText(f);
                e.target.value = '';
            }
        };


        document.getElementById('project-input').addEventListener('change', Project.load);

        document.getElementById('img-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (f) => {
                const data = f.target.result;
                fabric.Image.fromURL(data, (img) => {
                    const maxWidth = 200;
                    if (img.width > maxWidth) img.scaleToWidth(maxWidth);
                    img.set({ left: 50, top: 50 });
                    img.set({
                        hasRotatingPoint: false,
                        lockRotation: true
                    });
                    const defaultControls = fabric.Object.prototype.controls;
                    img.controls = { ...defaultControls };  // Copie tous les contrôles par défaut
                    delete img.controls.mtr;
                    img.set('ctype', 'image');
                    img.set('pid', Factory.getName('image'));
                    img.setControlVisible('mtr', false);
                    Factory.ensureUniqueId(img);
                    img.srcObj = data;
                    State.canvas.add(img);
                    State.canvas.setActiveObject(img);
                    App.setSideTab('props');
                    Panel.update(img);
                    History.save();
                });
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });


        const Panel = {
            ratioLocked: false,
            dom: {
                dropdownVal: document.getElementById('p-dropdown-val'),
                empty: document.getElementById('panel-empty'),
                content: document.getElementById('panel-content'),
                secConfig: document.getElementById('sec-config'),
                secAlign: document.getElementById('sec-align'),
                batchRadio: document.getElementById('batch-radio-section'),
                rowFillCheck: document.getElementById('row-fill-check'),
                hasFill: document.getElementById('p-has-fill'),
                boxFill: document.getElementById('box-fill'),
                rowOpacity: document.getElementById('row-opacity'),
                id: document.getElementById('p-id'),
                rowFontSize: document.getElementById('row-font-size'),
                fontSize: document.getElementById('p-font-size'),
                fill: document.getElementById('p-fill'),
                stroke: document.getElementById('p-stroke'),
                width: document.getElementById('p-width'),
                bstyle: document.getElementById('p-bstyle'),
                opacity: document.getElementById('p-opacity'),
                opacityVal: document.getElementById('p-opacity-val'),
                subRadio: document.getElementById('sub-radio'),
                subCheck: document.getElementById('sub-check'),
                subDrop: document.getElementById('sub-dropdown'),
                req: document.getElementById('p-req'),   // Case "Requis"
                read: document.getElementById('p-read'), // Case "Lecture Seule"
                grp: document.getElementById('p-grp'),
                val: document.getElementById('p-val'),
                checked: document.getElementById('p-checked'),
                fmt: document.getElementById('p-fmt'),
                rowFmt: document.getElementById('row-format'),
                rowAlign: document.getElementById('row-align'),
                dimW: document.getElementById('p-dim-w'),
                dimH: document.getElementById('p-dim-h'),
                posX: document.getElementById('p-pos-x'),
                posY: document.getElementById('p-pos-y'),
                secDims: document.getElementById('sec-dims'),

            },
            toggleRatio: () => {
                Panel.ratioLocked = !Panel.ratioLocked;
                const btn = document.getElementById('btn-ratio');
                if (Panel.ratioLocked) {
                    btn.innerHTML = '<i class="fa-solid fa-link"></i>';
                    btn.classList.add('text-blue-600', 'bg-blue-50');
                    btn.classList.remove('text-gray-400');
                } else {
                    btn.innerHTML = '<i class="fa-solid fa-link-slash"></i>';
                    btn.classList.remove('text-blue-600', 'bg-blue-50');
                    btn.classList.add('text-gray-400');
                }
            },
            // DANS L'OBJET Panel = { ... }

            update: (obj) => {
                // 1. Gestion des groupes Radio (inchangée)
                Panel.dom.batchRadio.classList.add('hidden');
                if (obj && obj.type === 'activeSelection') {
                    // ... (votre code existant pour la multisélection) ...
                    Panel.dom.empty.style.display = 'none';
                    Panel.dom.content.style.display = 'flex';
                    Panel.dom.secConfig.style.display = 'none';
                    Panel.dom.secDims.classList.add('hidden');
                    Panel.dom.secAlign.style.display = 'flex';
                    const allRadios = obj._objects.every(o => o.ctype === 'radio');
                    if (allRadios) {
                        Panel.dom.batchRadio.classList.remove('hidden');
                        document.getElementById('batch-grp-name').value = obj._objects[0].grp;
                    }
                    return;
                }
                Panel.dom.secAlign.style.display = 'none';

                // 2. Si rien n'est sélectionné
                if (!obj) {
                    Panel.dom.empty.style.display = 'flex';
                    Panel.dom.content.style.display = 'none';
                    return;
                }

                // 3. Affichage du panneau
                Panel.dom.empty.style.display = 'none';
                Panel.dom.content.style.display = 'flex';

                // === C'EST ICI LA NOUVEAUTÉ : MISE A JOUR DU HEADER ===
                const txtTarget = obj.txtObj || (obj.type === 'i-text' ? obj : null);
                const bgTarget = obj.bgObj || obj;

                if (txtTarget) {
                    Panel.dom.rowFontSize.style.display = 'grid';
                    Panel.dom.fontSize.value = txtTarget.fontSize || 12;

                    // CONDITION CLÉ :
                    // Si c'est Textfield ou Dropdown -> Lecture Seule (Grisé)
                    // Si c'est Textarea -> Modifiable
                    if (['textfield', 'dropdown'].includes(obj.ctype)) {
                        Panel.dom.fontSize.disabled = true;
                        Panel.dom.fontSize.classList.add('bg-gray-100', 'text-gray-500');
                        Panel.dom.fontSize.classList.remove('bg-white');
                    } else {
                        Panel.dom.fontSize.disabled = false;
                        Panel.dom.fontSize.classList.remove('bg-gray-100', 'text-gray-500');
                        Panel.dom.fontSize.classList.add('bg-white');
                    }

                } else {
                    Panel.dom.rowFontSize.style.display = 'none';
                }
                Panel.dom.subDrop.classList.add('hidden');

                if (obj.ctype === 'dropdown') {
                    Panel.dom.subDrop.classList.remove('hidden');
                    const optsArea = document.getElementById('p-opts');
                    const valSelect = Panel.dom.dropdownVal;

                    // Remplir TextArea
                    optsArea.value = obj.opts || '';

                    // Remplir Select
                    valSelect.innerHTML = '';
                    const options = (obj.opts || '').split('\n').filter(x => x.trim() !== '');

                    if (options.length === 0) {
                        const opt = document.createElement('option'); opt.text = "(Vide)"; valSelect.add(opt);
                    } else {
                        options.forEach(optText => {
                            const opt = document.createElement('option');
                            opt.value = optText; opt.text = optText;
                            valSelect.add(opt);
                        });
                    }
                    // Sélectionner valeur actuelle
                    valSelect.value = obj.val || (obj.txtObj ? obj.txtObj.text : '');
                }
                if (txtTarget) {
                    Panel.dom.rowFontSize.style.display = 'grid';
                    Panel.dom.fontSize.value = txtTarget.fontSize || 14;
                } else {
                    Panel.dom.rowFontSize.style.display = 'none';
                }
                // A. Mise à jour de la Taille (g-size)
                const gSize = document.getElementById('g-size');
                if (gSize) {
                    // Si c'est un objet texte (textarea, textfield...), on prend sa taille
                    if (txtTarget) gSize.value = txtTarget.fontSize || 12;
                    // Sinon (rectangle, cercle...), on laisse la valeur par défaut ou on grise
                }

                // B. Mise à jour de la Police (g-font)
                const gFont = document.getElementById('g-font');
                if (gFont && txtTarget) {
                    gFont.value = txtTarget.fontFamily || 'Arial';
                }

                // C. Mise à jour des Couleurs et Bordures (g-fill, g-stroke, g-width)
                const gFill = document.getElementById('g-fill');
                const prevFill = document.getElementById('preview-fill');
                if (gFill && prevFill) {
                    const c = App.toHex(bgTarget.fill);
                    gFill.value = c;
                    prevFill.style.backgroundColor = c;
                }

                const gStroke = document.getElementById('g-stroke');
                const prevStroke = document.getElementById('preview-stroke');
                if (gStroke && prevStroke) {
                    const c = App.toHex(bgTarget.stroke);
                    gStroke.value = c;
                    prevStroke.style.backgroundColor = c;
                }

                const gWidth = document.getElementById('g-width');
                if (gWidth) {
                    gWidth.value = bgTarget.strokeWidth || 0;
                }
                // =======================================================


                // ... LE RESTE DE VOTRE FONCTION RESTE INCHANGÉ ...
                // (Gestion de l'affichage du panneau de droite)
                const isDraw = obj.ctype === 'draw' || obj.ctype === 'image';
                Panel.dom.secConfig.style.display = isDraw ? 'none' : 'flex';
                // ... etc ...
                Panel.dom.rowOpacity.style.display = isDraw ? 'grid' : 'grid';
                document.getElementById('toolbar-font').style.display = isDraw ? 'none' : 'flex';

                Panel.dom.rowFillCheck.classList.add('hidden');
                if ((obj.ctype === 'draw' && obj.type !== 'line') || ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(obj.ctype)) {
                    Panel.dom.rowFillCheck.classList.remove('hidden');
                    const t = obj.bgObj || obj;
                    const isTransparent = !t.fill || t.fill === 'transparent';
                    Panel.dom.hasFill.checked = !isTransparent;
                    Panel.dom.boxFill.style.opacity = !isTransparent ? '1' : '0.3';
                }

                if (Panel.dom.req) Panel.dom.req.checked = obj.isRequired || false;
                if (Panel.dom.read) Panel.dom.read.checked = obj.isReadOnly || false;

                const target = obj.bgObj || obj;
                Panel.dom.id.value = obj.pid || '';
                Panel.dom.fill.value = App.toHex(target.fill);
                Panel.dom.stroke.value = App.toHex(target.stroke);
                Panel.dom.width.value = target.strokeWidth || 0;
                const op = target.opacity !== undefined ? target.opacity : 1; Panel.dom.opacity.value = op; Panel.dom.opacityVal.innerText = Math.round(op * 100) + '%';
                if (obj.bStyle) Panel.dom.bstyle.value = obj.bStyle; else Panel.dom.bstyle.value = 'solid';

                Panel.dom.rowFmt.style.display = (obj.ctype === 'textfield') ? 'grid' : 'none';
                Panel.dom.rowAlign.style.display = (obj.ctype === 'textfield' || obj.ctype === 'textarea') ? 'grid' : 'none';
                if (obj.ctype === 'textfield') Panel.dom.fmt.value = obj.fmt || 'text';

                if (obj.ctype === 'textfield' || obj.ctype === 'textarea') {
                    const align = obj.tAlign || 'left';
                    ['left', 'center', 'right'].forEach(a => {
                        const btn = document.getElementById('p-align-' + a);
                        if (align === a) btn.classList.add('selected'); else btn.classList.remove('selected');
                    });
                }

                Panel.dom.subRadio.classList.add('hidden'); Panel.dom.subCheck.classList.add('hidden'); Panel.dom.subDrop.classList.add('hidden');
                if (obj.ctype === 'radio') { Panel.dom.subRadio.classList.remove('hidden'); Panel.dom.subCheck.classList.remove('hidden'); Panel.dom.grp.value = obj.grp || ''; Panel.dom.val.value = obj.val || ''; Panel.dom.checked.checked = obj.isChecked; }
                else if (obj.ctype === 'checkbox') { Panel.dom.subCheck.classList.remove('hidden'); Panel.dom.checked.checked = obj.isChecked; }
                else if (obj.ctype === 'dropdown') { Panel.dom.subDrop.classList.remove('hidden'); document.getElementById('p-opts').value = obj.opts || ''; }

                Panel.dom.secDims.classList.remove('hidden');
                Panel.dom.dimW.value = Math.round(obj.getScaledWidth());
                Panel.dom.dimH.value = Math.round(obj.getScaledHeight());
                Panel.dom.posX.value = Math.round(obj.left);
                Panel.dom.posY.value = Math.round(obj.top);
            },
            apply: (key, val) => {
                const objs = State.canvas.getActiveObjects();
                if (!objs.length) return;

                objs.forEach(obj => {
                    const target = obj.bgObj || obj;
                    const txt = obj.txtObj || (obj.type === 'i-text' ? obj : null);
                    if (key === 'dropdownVal') {
                        obj.val = val;                          // Sauvegarde la valeur par défaut
                        if (obj.txtObj) {
                            obj.txtObj.set('text', val);        // Met à jour le texte visible
                            obj.txtObj.setCoords();             // Recalcule la position du texte dans le groupe
                        }
                        obj.dirty = true;                       // Indique au groupe qu'il a changé
                        if (obj.type === 'group') {
                            obj.addWithUpdate();                // Force le recalcul complet du groupe
                        }
                    }

                    // --- OPTIONS DU DROPDOWN (quand on modifie la textarea) ---
                    if (key === 'opts') {
                        obj.opts = val;
                        // Si la valeur par défaut actuelle n'existe plus dans les nouvelles options,
                        // on la remet sur la première option (ou on garde l'ancien texte si liste vide)
                        const newOptions = val.split('\n').map(o => o.trim()).filter(o => o !== '');
                        if (newOptions.length > 0 && !newOptions.includes(obj.val)) {
                            obj.val = newOptions[0];
                            if (obj.txtObj) obj.txtObj.set('text', newOptions[0]);
                        } else if (newOptions.length === 0) {
                            if (obj.txtObj) obj.txtObj.set('text', '');
                            obj.val = '';
                        }
                        // Rafraîchissement du panneau pour mettre à jour le <select> des valeurs par défaut
                        setTimeout(() => Panel.update(obj), 0);
                    }
                    if (key === 'fontSize' && txt && (obj.ctype === 'label' || obj.ctype === 'textarea' || obj.ctype === 'paragraph')) {
                        txt.set('fontSize', parseInt(val));

                        // Repositionnement en HAUT si c'est un textarea
                        if (obj.ctype === 'textarea') {
                            txt.set({
                                top: (-obj.height / 2) + 4,
                                width: obj.width - 8
                            });
                        }
                        obj.set('dirty', true);
                        if (obj.type === 'group') obj.addWithUpdate();
                    }



                    // --- NOUVEAU : SAUVEGARDE REQUIS / LECTURE SEULE ---
                    if (key === 'req') obj.isRequired = val;
                    if (key === 'read') obj.isReadOnly = val;
                    // ---------------------------------------------------

                    if (key === 'id') obj.pid = val;
                    if (key === 'fill') { target.set('fill', val); if (obj.ctype === 'draw') Panel.dom.hasFill.checked = true; }
                    if (key === 'has-fill') { target.set('fill', val ? Panel.dom.fill.value : 'transparent'); Panel.dom.boxFill.style.opacity = val ? '1' : '0.3'; }
                    if (key === 'stroke') { target.set('stroke', val); if (obj.ctype === 'label') obj.set('fill', val); }
                    if (key === 'width') target.set('strokeWidth', parseInt(val));
                    if (key === 'opacity') { target.set('opacity', parseFloat(val)); Panel.dom.opacityVal.innerText = Math.round(val * 100) + '%'; }
                    if (key === 'bstyle') { obj.bStyle = val; if (val === 'none') target.set({ strokeDashArray: [4, 4], stroke: '#ccc' }); else if (val === 'underline') target.set({ strokeDashArray: [10, 5] }); else target.set({ strokeDashArray: null, stroke: Panel.dom.stroke.value }); }
                    if (key === 'checked') { obj.isChecked = val; if (obj.markObj) obj.markObj.set('opacity', val ? 1 : 0); }
                    if (key === 'grp') obj.grp = val; if (key === 'val') obj.val = val; if (key === 'opts') obj.opts = val;
                    if (key === 'fmt') {
                        obj.fmt = val;
                        if (val === 'number') { obj.tAlign = 'right'; }
                    }


                    if (key === 'textAlign') {
                        obj.tAlign = val;
                        if (obj.txtObj) obj.txtObj.set('textAlign', val);
                    }
                    if (key === 'dimW') {
                        const newW = parseInt(val);
                        if (newW > 0) {
                            if (Panel.ratioLocked) {
                                obj.scaleToWidth(newW);
                                obj.set('scaleY', obj.scaleX);
                                Panel.dom.dimH.value = Math.round(obj.getScaledHeight());
                            } else {
                                obj.scaleToWidth(newW);
                            }
                        }
                    }
                    if (key === 'dimH') {

                        const newH = parseInt(val);
                        if (newH > 0) {
                            if (Panel.ratioLocked) {
                                obj.scaleToHeight(newH);
                                obj.set('scaleX', obj.scaleY);
                                Panel.dom.dimW.value = Math.round(obj.getScaledWidth());
                            } else {
                                obj.scaleToHeight(newH);
                                Panel.dom.fontSize.value = parseInt(newH * 0.7);
                                // obj.txtObj.set('fontSize', newFontSize);
                            }
                        }
                    }
                    // APPLY POS X/Y
                    if (key === 'posX') { obj.set('left', parseInt(val)); }
                    if (key === 'posY') { obj.set('top', parseInt(val)); }
                });
                State.canvas.requestRenderAll(); History.save();
            }
        };







        // --- LISTENERS (Indispensable pour que les cases réagissent) ---
        // --- LISTENER UNIQUE ET OPTIMISÉ ---
        // J'ai fusionné tes deux listes et ajouté 'fontSize'
        const propKeys = [
            'id', 'fontSize', 'fill', 'stroke', 'width', 'opacity', 'bstyle',
            'checked', 'grp', 'val', 'opts', 'dropdownVal', 'has-fill', 'fmt',
            'dimW', 'dimH', 'posX', 'posY', 'req', 'read'
        ];

        propKeys.forEach(k => {
            let elId = 'p-' + k;

            // Gestion des exceptions d'ID
            if (k === 'fontSize') elId = 'p-font-size';
            else if (k === 'opts') elId = 'p-opts';
            else if (k === 'dropdownVal') elId = 'p-dropdown-val'; // <--- NOUVEAU
            else if (k === 'dimW') elId = 'p-dim-w';
            else if (k === 'dimH') elId = 'p-dim-h';
            else if (k === 'posX') elId = 'p-pos-x';
            else if (k === 'posY') elId = 'p-pos-y';
            else if (k === 'req') elId = 'p-req';
            else if (k === 'read') elId = 'p-read';

            const el = document.getElementById(elId);

            if (el) {
                const eventType = (el.type === 'checkbox' || el.tagName === 'SELECT') ? 'change' : 'input';

                el.addEventListener(eventType, e => {
                    const val = el.type === 'checkbox' ? e.target.checked : e.target.value;
                    Panel.apply(k, val);
                });

                if (el.tagName === 'INPUT') {
                    el.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') el.blur();
                    });
                }
            }
        });

        App.toHex = (c) => { if (!c || c === 'transparent') return '#ffffff'; if (c.startsWith('#')) return c.slice(0, 7); return '#000000'; };

        const Exporter = {
            download: async () => {
                // 1. Sauvegarder pour figer l'état
                App.saveCurrentPage();

                const { PDFDocument, rgb, StandardFonts, TextAlignment } = PDFLib;
                let doc;

                if (State.pdfBytes) doc = await PDFDocument.load(State.pdfBytes);
                else doc = await PDFDocument.create();

                // --- A. CHARGEMENT DES POLICES STANDARD ---
                const helveticaFont = await doc.embedFont(StandardFonts.Helvetica);
                const helveticaBold = await doc.embedFont(StandardFonts.HelveticaBold);
                // AJOUT : On charge aussi les italiques pour le WYSIWYG
                const helveticaItalic = await doc.embedFont(StandardFonts.HelveticaOblique);
                const helveticaBoldItalic = await doc.embedFont(StandardFonts.HelveticaBoldOblique);

                const timesFont = await doc.embedFont(StandardFonts.TimesRoman);
                const courierFont = await doc.embedFont(StandardFonts.Courier);

                // Helpers
                const toRgb = (hex) => {
                    if (!hex || !hex.startsWith('#')) return undefined;
                    return rgb(parseInt(hex.slice(1, 3), 16) / 255, parseInt(hex.slice(3, 5), 16) / 255, parseInt(hex.slice(5, 7), 16) / 255);
                };

                // Helper pour choisir la police selon le style
                const getFont = (isBold, isItalic) => {
                    if (isBold && isItalic) return helveticaBoldItalic;
                    if (isBold) return helveticaBold;
                    if (isItalic) return helveticaItalic;
                    return helveticaFont;
                };

                const getSafeId = (id, set) => { let n = id; let i = 1; while (set.has(n)) n = id + "_" + i++; set.add(n); return n; };
                const usedIds = new Set();

                // --- BOUCLE PAGES ---
                for (let i = 0; i < State.pages.length; i++) {
                    let page;
                    if (i < doc.getPageCount()) page = doc.getPages()[i];
                    else page = doc.addPage([595, 842]);

                    const pdfWidth = page.getWidth();
                    const pdfHeight = page.getHeight();
                    const form = doc.getForm();

                    const pageData = State.pages[i];
                    if (!pageData || !pageData.objects) continue;

                    // 1. Fond
                    const bgRaw = pageData.objects.find(o => o.isBackground);
                    let bgLeft = 0, bgTop = 0, bgScaleW = 595;

                    if (bgRaw) {
                        await new Promise(resolve => {
                            fabric.util.enlivenObjects([bgRaw], (objs) => {
                                const bg = objs[0];
                                const p = bg.getPointByOrigin('left', 'top');
                                bgLeft = p.x; bgTop = p.y; bgScaleW = bg.getScaledWidth();
                                resolve();
                            });
                        });
                    } else {
                        bgScaleW = State.canvas.pageW || 595;
                    }

                    const ratio = pdfWidth / bgScaleW;

                    // 2. Objets
                    await new Promise(resolve => {
                        fabric.util.enlivenObjects(pageData.objects, (fabricObjects) => {

                            for (const o of fabricObjects) {
                                if (!o.ctype && o.type !== 'group' && o.ctype !== 'draw' && o.ctype !== 'image' && o.ctype !== 'label' && o.ctype !== 'paragraph') continue;
                                if (o.isBackground) continue;

                                const p = o.getPointByOrigin('left', 'top');
                                const relX = p.x - bgLeft;
                                const relY = p.y - bgTop;

                                const finalW = o.getScaledWidth() * ratio;
                                const finalH = o.getScaledHeight() * ratio;
                                const finalX = relX * ratio;
                                const finalY = pdfHeight - (relY * ratio) - finalH;

                                const opts = { x: finalX, y: finalY, width: finalW, height: finalH };

                                let rect = o;
                                let textObj = null;
                                if (o.type === 'group' && o._objects && o._objects.length >= 1) {
                                    rect = o._objects[0];
                                    if (o._objects.length > 1) textObj = o._objects[1];
                                }

                                // --- 1. EXPORT LABELS (SIMPLE) --- 
                                if (o.ctype === 'label') {
                                    const txt = o.text || "Texte";
                                    const fontSize = o.fontSize * ratio;
                                    let fontToUse = helveticaFont;
                                    const fam = (o.fontFamily || "").toLowerCase();
                                    if (fam.includes('times')) fontToUse = timesFont;
                                    else if (fam.includes('courier')) fontToUse = courierFont;
                                    else if (fam.includes('arial') && (o.fontWeight === 'bold' || o.fontWeight > 500)) fontToUse = helveticaBold;

                                    const textY = pdfHeight - (relY * ratio) - (fontSize * 0.88);
                                    page.drawText(txt, {
                                        x: finalX, y: textY, size: fontSize, font: fontToUse,
                                        color: toRgb(o.fill) || rgb(0, 0, 0), opacity: o.opacity
                                    });
                                    continue;
                                }

                                // --- 2. EXPORT PARAGRAPHE RICHE (WYSIWYG) ---
                                else if (o.ctype === 'paragraph') {
                                    // On utilise l'objet Fabric pour calculer les lignes et les styles
                                    // Note : o est déjà un objet Fabric "enlivened" ici

                                    const textLines = o._textLines;
                                    const lineHeight = o.lineHeight || 1.16;
                                    const fontSize = o.fontSize * ratio;
                                    const defaultFill = o.fill;
                                    const opacity = o.opacity || 1;

                                    textLines.forEach((lineChars, lineIdx) => {
                                        // Calcul Y de la ligne
                                        // On descend : Y départ - (padding top) - (index ligne * hauteur ligne)
                                        const lineY = pdfHeight - (relY * ratio) - (fontSize * 0.80) - (lineIdx * fontSize * lineHeight);

                                        // Calcul Alignement X
                                        let currentX = finalX;
                                        const lineWidth = o.getLineWidth(lineIdx) * ratio;

                                        if (o.textAlign === 'center') currentX += (finalW - lineWidth) / 2;
                                        else if (o.textAlign === 'right') currentX += (finalW - lineWidth);

                                        // --- LE DÉCOUPEUR DE STYLE ---
                                        let bufferText = "";
                                        let bufferStyle = o.getCompleteStyleDeclaration(lineIdx, 0) || {};

                                        const flushBuffer = () => {
                                            if (!bufferText) return;

                                            // 1. Police & Style
                                            const isBold = bufferStyle.fontWeight === 'bold' || o.fontWeight === 'bold';
                                            const isItalic = bufferStyle.fontStyle === 'italic' || o.fontStyle === 'italic';
                                            const fontToUse = getFont(isBold, isItalic);

                                            // 2. Couleur
                                            const fillColor = bufferStyle.fill || defaultFill;

                                            // 3. Dessin
                                            page.drawText(bufferText, {
                                                x: currentX, y: lineY,
                                                size: fontSize, font: fontToUse,
                                                color: toRgb(fillColor) || rgb(0, 0, 0),
                                                opacity: opacity
                                            });

                                            // 4. Avancer X
                                            const width = fontToUse.widthOfTextAtSize(bufferText, fontSize);
                                            currentX += width;

                                            // 5. Souligné
                                            if (bufferStyle.underline || o.underline) {
                                                page.drawLine({
                                                    start: { x: currentX - width, y: lineY - 2 },
                                                    end: { x: currentX, y: lineY - 2 },
                                                    thickness: 1 * ratio,
                                                    color: toRgb(fillColor) || rgb(0, 0, 0),
                                                    opacity: opacity
                                                });
                                            }
                                        };

                                        // Parcours caractères
                                        for (let c = 0; c < lineChars.length; c++) {
                                            const char = lineChars[c];
                                            const style = o.getCompleteStyleDeclaration(lineIdx, c) || {};

                                            // Changement de style ?
                                            const styleChanged =
                                                style.fontWeight !== bufferStyle.fontWeight ||
                                                style.fontStyle !== bufferStyle.fontStyle ||
                                                style.fill !== bufferStyle.fill ||
                                                style.underline !== bufferStyle.underline;

                                            if (styleChanged) {
                                                flushBuffer();
                                                bufferText = char;
                                                bufferStyle = style;
                                            } else {
                                                bufferText += char;
                                            }
                                        }
                                        flushBuffer(); // Fin de ligne
                                    });
                                    continue;
                                }

                                // --- 3. EXPORT IMAGES ---
                                if (o.ctype === 'image' && o.srcObj) {
                                    (async () => {
                                        try {
                                            let img;
                                            if (o.srcObj.startsWith('data:image/png')) img = await doc.embedPng(o.srcObj);
                                            else img = await doc.embedJpg(o.srcObj);
                                            page.drawImage(img, { ...opts, opacity: o.opacity });
                                        } catch (e) { }
                                    })();
                                    continue;
                                }

                                // --- 4. EXPORT DESSINS ---
                                if (o.ctype === 'draw') {
                                    const op = {
                                        borderColor: toRgb(o.stroke),
                                        borderWidth: o.strokeWidth * ratio,
                                        color: o.fill !== 'transparent' ? toRgb(o.fill) : undefined,
                                        opacity: o.opacity
                                    };
                                    if (o.type === 'rect') page.drawRectangle({ ...opts, ...op });
                                    else if (o.type === 'ellipse') page.drawEllipse({ x: finalX + finalW / 2, y: finalY + finalH / 2, xScale: finalW / 2, yScale: finalH / 2, ...op });
                                    else if (o.type === 'line') {
                                        // --- CORRECTION : CALCUL PRÉCIS DES POINTS ---
                                        // On utilise la matrice de transformation pour récupérer les coordonnées réelles
                                        // des deux extrémités (start/end), peu importe le sens ou la rotation.
                                        const matrix = o.calcTransformMatrix();
                                        const p1 = fabric.util.transformPoint({ x: o.x1, y: o.y1 }, matrix);
                                        const p2 = fabric.util.transformPoint({ x: o.x2, y: o.y2 }, matrix);

                                        const lX1 = (p1.x - bgLeft) * ratio;
                                        const lY1 = pdfHeight - ((p1.y - bgTop) * ratio);
                                        const lX2 = (p2.x - bgLeft) * ratio;
                                        const lY2 = pdfHeight - ((p2.y - bgTop) * ratio);

                                        page.drawLine({
                                            start: { x: lX1, y: lY1 },
                                            end: { x: lX2, y: lY2 },
                                            color: toRgb(o.stroke),
                                            thickness: o.strokeWidth * ratio,
                                            opacity: o.opacity
                                        });
                                    }
                                }

                                // --- 5. EXPORT INPUTS ---
                                else if (o.ctype) {
                                    const bg = (rect.fill && rect.fill !== 'transparent') ? toRgb(rect.fill) : undefined;
                                    const bc = toRgb(rect.stroke);
                                    const bw = (o.bStyle === 'none' || o.bStyle === 'underline') ? 0 : rect.strokeWidth * ratio;

                                    const formOpts = { ...opts, backgroundColor: bg, borderColor: bc, borderWidth: bw };
                                    const safeId = getSafeId(o.pid, usedIds);

                                    try {
                                        let f;
                                        if (o.ctype === 'textfield') {
                                            f = form.createTextField(safeId);
                                            if (textObj && textObj.text) f.setText(textObj.text);
                                            f.addToPage(page, formOpts);
                                            if (o.bStyle === 'underline') page.drawLine({ start: { x: finalX, y: finalY }, end: { x: finalX + finalW, y: finalY }, color: bc, thickness: 1 * ratio });
                                            if (o.tAlign === 'center') f.setAlignment(TextAlignment.Center);
                                            else if (o.tAlign === 'right') f.setAlignment(TextAlignment.Right);
                                            else f.setAlignment(TextAlignment.Left);
                                            if (o.fmt === 'date' && (!textObj || !textObj.text)) f.setText('JJ/MM/AAAA');
                                        }

                                        // DANS Exporter.download ...

                                        // DANS Exporter.download ...
                                        // DANS Exporter.download ...

                                        else if (o.ctype === 'textarea') {
                                            // 1. Création du champ
                                            f = form.createTextField(safeId);
                                            f.enableMultiline();

                                            // 2. Définition du texte
                                            if (textObj && textObj.text) f.setText(textObj.text);

                                            // 3. RECUPERATION DE LA POLICE ET TAILLE (Depuis l'éditeur)
                                            let fontToUse = helveticaFont;
                                            if (textObj && textObj.fontFamily) {
                                                const fam = textObj.fontFamily.toLowerCase();
                                                if (fam.includes('times')) fontToUse = timesFont;
                                                else if (fam.includes('courier')) fontToUse = courierFont;
                                            }

                                            // Calcul de la taille (Taille éditeur * Ratio PDF)
                                            // Par défaut 12 si non défini
                                            const fontSize = (textObj && textObj.fontSize) ? (textObj.fontSize * ratio) : (12 * ratio);

                                            // --- LE FIX ULTIME POUR /DA ---
                                            // Au lieu d'utiliser f.setFontSize() qui plante, on met à jour l'apparence complète manuellement.
                                            // Cela contourne le bug "No /DA entry found".

                                            try {
                                                // Méthode standard (si elle marche)
                                                f.updateAppearances(fontToUse);
                                                f.setFontSize(fontSize);
                                            } catch (e) {
                                                // Méthode de secours (Force brute)
                                                // On vérifie si acroField existe (accès bas niveau)
                                                if (f.acroField) {
                                                    const fontName = doc.fonts.find(f => f.embedder.font === fontToUse)?.name || 'Helv';

                                                    // On construit la chaine /DA manuellement : "/NomPolice Taille Tf 0 g"
                                                    // Exemple : "/Helv 12 Tf 0 g" (Police Helv, Taille 12, Couleur Noire)
                                                    const daString = `/${fontName} ${fontSize} Tf 0 g`;

                                                    // On l'injecte directement dans le PDF
                                                    f.acroField.setDefaultAppearance(daString);
                                                }
                                            }
                                            // -----------------------------

                                            // 4. Placement sur la page
                                            f.addToPage(page, formOpts);

                                            // 5. Alignement
                                            if (o.tAlign === 'center') f.setAlignment(TextAlignment.Center);
                                            else if (o.tAlign === 'right') f.setAlignment(TextAlignment.Right);
                                        }

                                        else if (o.ctype === 'checkbox') {
                                            f = form.createCheckBox(safeId);
                                            f.addToPage(page, formOpts);
                                            if (o.isChecked) f.check();
                                        }
                                        else if (o.ctype === 'radio') {
                                            let g;
                                            try { g = form.getRadioGroup(o.grp); } catch { g = form.createRadioGroup(o.grp); }
                                            g.addOptionToPage(o.val, page, formOpts);
                                            if (o.isChecked) g.select(o.val);
                                            f = g;
                                        }
                                        else if (o.ctype === 'dropdown') {
                                            f = form.createDropdown(safeId);

                                            // 1. On nettoie la liste des options (évite les lignes vides)
                                            const options = (o.opts || "").split('\n').filter(line => line.trim() !== "");
                                            f.setOptions(options);

                                            f.addToPage(page, formOpts);

                                            // 2. CORRECTION : On force la sélection de la valeur par défaut
                                            // Si une valeur est définie et qu'elle existe bien dans la liste, on la sélectionne.
                                            if (o.val && options.includes(o.val)) {
                                                f.select(o.val);
                                            } else if (options.length > 0) {
                                                // Sécurité : Si pas de valeur par défaut, on prend la première
                                                f.select(options[0]);
                                            }
                                        }
                                        if (f) {
                                            if (o.isRequired) f.setRequired(true);
                                            if (o.isReadOnly) f.enableReadOnly();
                                        }
                                    } catch (e) { console.error(e); }
                                }
                            }
                            resolve();
                        });
                    });
                }

                const title = document.getElementById('doc-title').value || "Formulaire";
                doc.setTitle(title);
                doc.setAuthor("Pdf Studio");
                doc.setCreator("Généré par Pdf Studio");

                const bytes = await doc.save();
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = (document.getElementById('doc-title').value || "doc") + ".pdf";
                link.click();
            }
        };


        document.getElementById('file-input').addEventListener('change', async e => {
            const f = e.target.files[0];
            if (!f) return;

            // UI : Petit loading (optionnel mais sympa)
            App.showModal("Chargement", "Importation du PDF en cours...");

            const ab = await f.arrayBuffer();
            State.pdfBytes = new Uint8Array(ab); // On garde le binaire pour l'export
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(new Blob([ab]))).promise;

            // RESET TOTAL
            State.pages = [];
            State.totalPages = pdf.numPages;
            State.currentPage = 0;

            // BOUCLE SUR CHAQUE PAGE
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const scale = 2.0; // Bonne qualité
                const vp = page.getViewport({ scale: scale });

                // Uniquement pour la page 1 : on définit la taille globale du canvas
                if (i === 1) {
                    State.canvas.pageW = vp.width;
                    State.canvas.pageH = vp.height;
                    App.resize();
                    const cx = (State.canvas.width / 2 - vp.width / 2);
                    const cy = 20;
                    State.canvas.pageOffset = { x: cx, y: cy };
                }

                // Rendu off-screen (canvas invisible)
                const c = document.createElement('canvas');
                c.width = vp.width;
                c.height = vp.height;
                await page.render({ canvasContext: c.getContext('2d'), viewport: vp }).promise;

                // Création de l'objet Image Fabric
                const img = new fabric.Image(c);
                img.set({
                    left: State.canvas.pageOffset.x,
                    top: State.canvas.pageOffset.y,
                    selectable: false, evented: false, hasControls: false,
                    lockMovementX: true, lockMovementY: true,
                    isBackground: true,
                    shadow: { color: 'rgba(0,0,0,0.1)', blur: 15 }
                });
                const defaultControls = fabric.Object.prototype.controls;
                img.controls = { ...defaultControls };  // Copie tous les contrôles par défaut
                delete img.controls.mtr;

                // CRÉATION DU JSON DE LA PAGE
                // On crée une "fausse" page qui contient juste cette image de fond pour l'instant
                // Note: On doit simuler la structure JSON de Fabric
                const pageJSON = {
                    version: "5.3.0",
                    objects: [img.toObject(customProps)]
                };

                State.pages.push(pageJSON);
            }

            // Terminé : On charge la page 0 (la première)
            App.closeModal();
            App.loadPage(0);

            // Reset de l'input pour pouvoir réimporter le même fichier si besoin
            e.target.value = '';
        });
        if (window.pdfjsLib) {
            // On force la version 3.4.120 pour qu'elle corresponde à votre fichier ext.js
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
        }
        document.body.classList.add('codage');
        function openDonationModal() {
            document.getElementById('donation-modal').classList.remove('hidden');
        }

        function closeDonationModal() {
            document.getElementById('donation-modal').classList.add('hidden');
        }
    </script>

    <div id="donation-modal"
        class="fixed inset-0 bg-slate-900/80 z-[100] hidden flex flex-col items-center justify-center backdrop-blur-sm transition-opacity">
        <div
            class="bg-white rounded-2xl shadow-2xl w-full max-w-sm overflow-hidden transform transition-all scale-100 p-6 text-center relative animate-bounce-short">

            <button onclick="closeDonationModal()"
                class="absolute top-4 right-4 text-slate-400 hover:text-slate-600 transition">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12">
                    </path>
                </svg>
            </button>

            <div class="w-16 h-16 bg-pink-100 text-pink-500 rounded-full flex items-center justify-center mx-auto mb-4">
                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd"
                        d="M3.172 5.172a4 4 0 015.656 0L10 6.343l1.172-1.171a4 4 0 115.656 5.656L10 17.657l-6.828-6.829a4 4 0 010-5.656z"
                        clip-rule="evenodd" />
                </svg>
            </div>

            <h3 class="text-xl font-bold text-slate-800 mb-3">Soutenir le projet</h3>

            <div class="text-slate-600 text-sm mb-6 space-y-2 leading-relaxed">
                <p>Cet outil est développé bénévolement pour aider professeurs et élèves.</p>
                <p class="font-medium text-pink-600">Il n'y a pas de pub, pas d'inscription.</p>
                <p>Si vous souhaitez soutenir ma démarche et l'évolution du projet, vous pouvez faire un don libre
                    ci-dessous.</p>
            </div>

            <a href="https://www.paypal.com/donate/?hosted_button_id=VKZXDC5BM2GHA" target="_blank"
                class="block w-full py-3 bg-pink-500 hover:bg-pink-600 text-white font-bold rounded-xl shadow-lg hover:shadow-xl transition transform hover:-translate-y-1 mb-3 flex items-center justify-center gap-2">
                <span>❤️</span> Faire un don
            </a>

            <button onclick="closeDonationModal()"
                class="text-xs text-slate-400 hover:text-slate-600 underline py-2">Plus tard</button>
        </div>
    </div>
</body>

</html>
