<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pdf Studio</title>

    <script src="ext.js"></script>


    <script>
        // Ce petit script fait le lien entre PDF.js (dans ext.js) et le worker ci-dessus
        // ✅ BON : On attend que le HTML soit fini de lire ('DOMContentLoaded')

    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }

        .canvas-box {
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
            background: transparent;
        }

        .os-input {
            background: #ffffff;
            border: 1px solid #d1d1d6;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 12px;
        }

        .os-input:focus {
            border-color: #1c1c1e;
            outline: none;
        }

        /* Tool Button Compact Style */
        .tool-btn {
            width: 100%;
            height: 36px;
            border-radius: 6px;
            transition: 0.1s;
            color: #636366;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tool-btn:hover {
            background: #e5e5ea;
            color: #000;
        }

        .tool-btn.active {
            background: #1c1c1e;
            color: #ffffff;
        }

        .tool-btn i {
            font-size: 14px;
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            padding: 0;
            background: none;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 1px solid #d1d1d6;
            border-radius: 4px;
        }

        .align-btn.selected {
            background-color: #e5e5ea;
            color: black;
            border-color: #d1d1d6;
        }

        /* Navigator List Items */
        .nav-item {
            padding: 8px 10px;
            font-size: 11px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            user-select: none;
            transition: background 0.1s;
        }

        .nav-item:hover {
            background: #f9fafb;
        }

        .nav-item.active {
            background: #eff6ff;
            color: #2563eb;
            font-weight: 600;
            border-left: 3px solid #2563eb;
        }

        .nav-item i {
            width: 16px;
            text-align: center;
            color: #9ca3af;
        }

        .nav-item.active i {
            color: #2563eb;
        }

        .nav-item.dragging {
            opacity: 0.5;
            background: #e5e7eb;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            text-align: center;
            font-size: 11px;
            font-weight: 600;
            color: #9ca3af;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            transition: 0.2s;
        }

        .tab-btn:hover {
            color: #1c1c1e;
            background: #f9fafb;
        }

        .tab-btn.active {
            color: #1c1c1e;
            border-bottom-color: #1c1c1e;
        }

        .modal-enter {
            opacity: 0;
            transform: scale(0.95);
        }

        .modal-enter-active {
            opacity: 1;
            transform: scale(1);
            transition: opacity 0.2s, transform 0.2s;
        }

        .modal-exit {
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.2s, transform 0.2s;
        }

        .active-tab {
            color: #2563eb;
            /* bleu */
            border-bottom-color: #2563eb;
        }

        .nav-delete-btn {
            margin-left: auto;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            color: #ef4444;
            opacity: 0;
            transition: all 0.2s;
        }

        .nav-delete-btn:hover {
            background-color: #fee2e2;
        }

        .nav-item:hover .nav-delete-btn {
            opacity: 1;
        }

        .bank-item {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            cursor: grab;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .bank-item:hover {
            border-color: #2563eb;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .bank-item:active {
            cursor: grabbing;
        }

        .bank-preview {
            width: 40px;
            height: 40px;
            object-fit: contain;
            background-color: #f3f4f6;
            border-radius: 4px;
        }

        .bank-text-preview {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #eff6ff;
            color: #2563eb;
            font-weight: bold;
            font-size: 16px;
            border-radius: 4px;
        }

        .bank-del-btn {
            margin-left: auto;
            color: #ef4444;
            opacity: 0;
            cursor: pointer;
            padding: 4px;
        }

        .bank-item:hover .bank-del-btn {
            opacity: 1;
        }

        .storage-bar-container {
            width: 100%;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .storage-bar-fill {
            height: 100%;
            background: #2563eb;
            transition: width 0.3s;
        }

        .storage-text {
            font-size: 9px;
            color: #9ca3af;
            margin-top: 2px;
            display: flex;
            justify-content: space-between;
        }

        .bank-name-input {
            width: 100%;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 4px;
            border: 1px solid #3b82f6;
            border-radius: 4px;
            outline: none;
            background: white;
            color: black;
            margin: -3px 0;
        }

        .help-tab {
            border-bottom-width: 2px;
            transition: all 0.2s;
        }

        /* TOAST NOTIFICATIONS */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            /* Laisse passer les clics au travers */
        }

        .toast {
            background: #1c1c1e;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            min-width: 200px;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .toast.success i {
            color: #4ade80;
        }

        /* Vert */
        .toast.info i {
            color: #60a5fa;
        }

        /* Bleu */
        .toast.error i {
            color: #f87171;
        }

        /* Rouge */
    </style>
</head>

<body class="bg-bg h-screen w-screen flex flex-col text-text">

    <div id="modal-overlay"
        class="fixed inset-0 bg-black/40 z-[100] hidden flex items-center justify-center backdrop-blur-sm">
        <div id="modal-box" class="bg-white rounded-xl shadow-2xl w-80 p-5 transform transition-all">
            <h3 id="modal-title" class="text-lg font-bold mb-2">Titre</h3>
            <p id="modal-msg" class="text-sm text-gray-600 mb-5 leading-relaxed">Message...</p>
            <div class="flex justify-end">
                <button onclick="App.closeModal()"
                    class="bg-active text-white text-xs font-bold px-4 py-2 rounded hover:bg-gray-800 transition">Compris</button>
            </div>
        </div>
    </div>

    <header class="h-14 bg-panel border-b border-border flex items-center px-5 justify-between shrink-0 z-20">
        <div class="flex items-center gap-4">
            <div class="font-bold text-lg flex items-center gap-2"><i class="fa-solid fa-cube"></i> Studio</div>
            <div class="h-5 w-px bg-border mx-1"></div>
            <div class="flex items-center ml-4 group">
                <input type="text" id="doc-title" value="Mon_Formulaire"
                    class="bg-transparent text-gray-600 text-sm font-medium px-2 py-1 rounded border border-transparent hover:bg-gray-50 hover:text-gray-900 focus:bg-white focus:text-black focus:ring-1 focus:ring-gray-200 focus:outline-none transition-all duration-300 w-24 focus:w-64 text-right placeholder-gray-400"
                    placeholder="Nom...">

                <span class="text-gray-400 text-xs ml-0.5 pt-0.5 select-none">.pdf</span>

                <i class="fa-solid fa-pencil text-gray-300 text-[10px] ml-2 opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer"
                    onclick="document.getElementById('doc-title').focus()"></i>
            </div>
            <div class="flex gap-1">
                <button onclick="History.undo()"
                    class="w-8 h-8 flex items-center justify-center rounded hover:bg-bg text-slate-500 hover:text-black"
                    title="Annuler (Ctrl+Z)"><i class="fa-solid fa-arrow-rotate-left text-xs"></i></button>
                <button onclick="History.redo()"
                    class="w-8 h-8 flex items-center justify-center rounded hover:bg-bg text-slate-500 hover:text-black"
                    title="Rétablir (Ctrl+Y)"><i class="fa-solid fa-arrow-rotate-right text-xs"></i></button>
            </div>
        </div>

        <div id="toolbar-main" class="flex items-center gap-4 transition-opacity duration-200">

            <div id="toolbar-font" class="flex items-center gap-2 bg-bg px-2 py-1 rounded-lg border border-border">
                <i class="fa-solid fa-font text-[10px] text-gray-400"></i>
                <select id="g-font"
                    class="bg-transparent text-xs font-medium border-none outline-none w-20 cursor-pointer"
                    onchange="App.setStyle('font', this.value)">
                    <option value="Arial">Arial</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times</option>
                    <option value="Courier New">Courier</option>
                </select>
                <input type="number" id="g-size" value="11"
                    class="bg-transparent text-xs font-medium w-10 text-center outline-none border-none"
                    oninput="App.setStyle('size', this.value)" title="Taille Police">
            </div>

            <div class="flex items-center gap-2 bg-bg px-2 py-1 rounded-lg border border-border">
                <div class="flex flex-col items-center group cursor-pointer relative" title="Couleur Fond">
                    <input type="color" id="g-fill" value="#ffffff" class="w-5 h-5 cursor-pointer absolute opacity-0"
                        oninput="App.setStyle('fill', this.value)">
                    <div class="w-4 h-4 rounded bg-white border border-gray-300 shadow-sm" id="preview-fill"></div>
                </div>
                <div class="flex flex-col items-center group cursor-pointer relative" title="Couleur Bordure">
                    <input type="color" id="g-stroke" value="#000000" class="w-5 h-5 cursor-pointer absolute opacity-0"
                        oninput="App.setStyle('stroke', this.value)">
                    <div class="w-4 h-4 rounded bg-black border border-gray-300 shadow-sm" id="preview-stroke"></div>
                </div>
                <div class="w-px h-4 bg-gray-300"></div>
                <input type="number" id="g-width" value="1" min="0" max="10"
                    class="bg-transparent text-xs font-medium w-8 text-center outline-none border-none"
                    oninput="App.setStyle('width', this.value)" title="Épaisseur Trait">
            </div>

            <div class="flex items-center gap-2 px-2 border-l border-border pl-4">
                <label class="flex items-center gap-2 cursor-pointer select-none border-r border-border pr-3 mr-1">
                    <input type="checkbox" id="g-snap" class="accent-black w-4 h-4 rounded" checked
                        onchange="State.snap=this.checked">
                    <span class="text-[10px] font-bold text-gray-500">AIMANT</span>
                </label>
                <div class="flex items-center gap-3">

                    <span class="text-[9px] font-bold text-gray-400 uppercase" title="Hauteur Champ Texte">
                        Input</span>
                    <input type="number" id="g-def-height" value="24"
                        class="os-input w-12 text-center h-5 p-0 text-[10px]"
                        onchange="State.defaults.defHeight = parseInt(this.value)">

                    <button id="btn-size-painter" onclick="App.setTool('size-painter')"
                        class="mx-2 w-7 h-7 bg-gray-100 hover:bg-black hover:text-white text-gray-500 rounded flex items-center justify-center transition shadow-sm"
                        title="Appliquer la taille par défaut au clic">
                        <i class="fa-solid fa-paintbrush text-xs"></i>
                    </button>


                    <span class="text-[9px] font-bold text-gray-400 uppercase" title="Taille Case / Radio">
                        Box</span>
                    <input type="number" id="g-def-box" value="14" class="os-input w-12 text-center h-5 p-0 text-[10px]"
                        onchange="State.defaults.boxSize = parseInt(this.value)">

                    <label class="flex items-center gap-2 cursor-pointer select-none ml-2">
                        <input type="checkbox" id="g-lock" class="accent-black w-4 h-4 rounded" checked
                            onchange="App.setStyle('lock', this.checked)">
                        <span class="text-[10px] font-bold text-gray-500">FIXE</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-3">
            <button id="btn-flow-toggle" onclick="App.toggleFlowLines()"
                class="flex items-center justify-center w-7 h-7 bg-white border border-gray-200 text-gray-500 rounded hover:text-blue-600 hover:border-blue-400 transition-all"
                title="Afficher/Masquer le parcours de tabulation">
                <i class="fa-solid fa-route text-[11px]"></i>
            </button>
            <button onclick="App.togglePreview()" id="btn-preview"
                class="text-xs font-bold text-gray-500 hover:text-black hover:bg-bg px-3 py-2 rounded transition flex items-center gap-2"
                title="Mode Aperçu">
                <i class="fa-regular fa-eye"></i> </button>
            <button onclick="document.getElementById('file-input').click()"
                class="text-xs font-bold text-gray-500 hover:text-black hover:bg-bg px-3 py-2 rounded transition"
                title="Importer un fichier PDF">PDF</button>

            <button onclick="Exporter.download()"
                class="bg-active text-white text-xs font-bold px-4 py-2 rounded shadow-md hover:bg-gray-800 transition flex items-center gap-2"
                title="Télécharger le document final">Export</button>

            <button
                onclick="if(document.fullscreenElement) document.exitFullscreen(); else document.documentElement.requestFullscreen();"
                class="text-gray-400 hover:text-blue-600 w-8 h-8 rounded-full border border-transparent hover:border-blue-100 hover:bg-blue-50 transition flex items-center justify-center ml-2"
                title="Plein Écran">
                <i class="fa-solid fa-expand"></i>
            </button>

            <button onclick="App.toggleHelp()"
                class="text-gray-400 hover:text-blue-600 w-8 h-8 rounded-full border border-transparent hover:border-blue-100 hover:bg-blue-50 transition flex items-center justify-center ml-1"
                title="Centre d'aide et Raccourcis">
                <i class="fa-solid fa-circle-question text-lg"></i>
            </button>
        </div>
    </header>

    <div class="flex flex-1 h-[calc(100vh-56px)]">
        <aside id="sidebar-tools"
            class="w-[220px] bg-panel border-r border-border flex flex-col shrink-0 transition-transform duration-300 z-10">

            <div class="p-2 border-b border-border bg-white">
                <span class="text-[9px] font-bold uppercase text-gray-400 ml-1 mb-2 block">Outils</span>

                <div class="grid grid-cols-4 gap-1">
                    <button onclick="App.setTool('select')" id="btn-select" class="tool-btn active"
                        title="Sélection (V / S)">
                        <i class="fa-solid fa-arrow-pointer"></i>
                    </button>

                    <button onclick="App.setTool('hand')" id="btn-hand" class="tool-btn" title="Déplacer (M / Espace)">
                        <i class="fa-solid fa-hand"></i>
                    </button>

                    <div class="col-span-2"></div>

                    <button onclick="App.setTool('textfield')" id="btn-textfield" class="tool-btn" title="Champ Texte">
                        <i class="fa-solid fa-i-cursor"></i>
                    </button>

                    <button onclick="App.setTool('textarea')" id="btn-textarea" class="tool-btn"
                        title="Paragraphe (Multi-lignes)">
                        <i class="fa-solid fa-paragraph"></i>
                    </button>

                    <button onclick="App.setTool('checkbox')" id="btn-checkbox" class="tool-btn" title="Case à cocher">
                        <i class="fa-regular fa-square-check"></i>
                    </button>

                    <button onclick="App.setTool('radio')" id="btn-radio" class="tool-btn"
                        title="Bouton Radio (Choix unique)">
                        <i class="fa-regular fa-circle-dot"></i>
                    </button>

                    <button onclick="App.setTool('dropdown')" id="btn-dropdown" class="tool-btn" title="Menu Déroulant">
                        <i class="fa-regular fa-square-caret-down"></i>
                    </button>

                    <button onclick="App.setTool('label')" id="btn-label" class="tool-btn"
                        title="Étiquette / Titre (Texte fixe)">
                        <i class="fa-solid fa-heading"></i>
                    </button>

                    <button onclick="App.setTool('rect')" id="btn-rect" class="tool-btn" title="Rectangle (Dessin)">
                        <i class="fa-regular fa-square"></i>
                    </button>

                    <button onclick="App.setTool('circle')" id="btn-circle" class="tool-btn" title="Cercle (Dessin)">
                        <i class="fa-regular fa-circle"></i>
                    </button>

                    <button onclick="App.setTool('line')" id="btn-line" class="tool-btn" title="Ligne (Dessin)">
                        <i class="fa-solid fa-minus"></i>
                    </button>
                </div>
            </div>

            <div class="px-3 py-2 bg-gray-50 border-b border-border flex justify-between items-center shrink-0">
                <span class="text-[10px] font-bold uppercase text-gray-400">Ordre</span>

                <div class="flex items-center gap-2">
                    <button onclick="App.autoSort()"
                        class="bg-white border border-gray-200 text-gray-600 hover:text-blue-600 hover:border-blue-300 text-[10px] px-2 py-1 rounded flex items-center gap-1.5 transition shadow-sm"
                        title="Tri Automatique (Haut vers Bas)">
                        <i class="fa-solid fa-arrow-down-z-a"></i> Auto
                    </button>

                    <button onclick="App.toggleSequenceMode()" id="btn-seq"
                        class="bg-white border border-gray-200 text-gray-600 hover:text-orange-600 hover:border-orange-300 text-[10px] px-2 py-1 rounded flex items-center gap-1.5 transition shadow-sm"
                        title="Définir l'ordre manuellement">
                        <i class="fa-solid fa-arrow-down-1-9"></i> Séquence
                    </button>
                </div>
            </div>

            <div id="navigator-list" class="flex-1 overflow-y-auto overflow-x-hidden bg-white scrollbar-thin">
            </div>

            <div class="p-2 border-t border-border grid grid-cols-3 gap-2 bg-gray-50 shrink-0">

                <button onclick="Project.new()"
                    class="tool-btn text-[10px] h-8 bg-slate-100 border border-slate-300 text-slate-700 hover:bg-slate-200 hover:text-black hover:border-slate-400 font-medium"
                    title="Nouveau Projet (Tout effacer)">
                    <i class="fa-solid fa-file-circle-plus"></i>
                </button>

                <button onclick="Project.save()"
                    class="tool-btn text-[10px] h-8 bg-slate-100 border border-slate-300 text-slate-700 hover:bg-slate-200 hover:text-black hover:border-slate-400 font-medium"
                    title="Sauvegarder Projet (Ctrl+S)">
                    <i class="fa-solid fa-floppy-disk"></i>
                </button>

                <button onclick="document.getElementById('project-input').click()"
                    class="tool-btn text-[10px] h-8 bg-slate-100 border border-slate-300 text-slate-700 hover:bg-slate-200 hover:text-black hover:border-slate-400 font-medium"
                    title="Ouvrir Projet">
                    <i class="fa-solid fa-folder-open"></i>
                </button>
            </div>
        </aside>

        <main id="workspace" class="flex-1 bg-[#d4d4d8] relative overflow-hidden flex justify-center items-center">
            <div class="canvas-box relative"><canvas id="c"></canvas></div>

            <div id="page-nav"
                class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-white border border-gray-200 px-4 py-2 rounded-full shadow-lg flex items-center gap-4 z-50 hidden">
                <button onclick="App.changePage(-1)" class="hover:text-blue-600 transition" title="Page Précédente">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <span id="page-indicator" class="text-xs font-bold w-20 text-center font-mono text-gray-600">Page 1 /
                    1</span>
                <button onclick="App.changePage(1)" class="hover:text-blue-600 transition" title="Page Suivante">
                    <i class="fa-solid fa-chevron-right"></i>
                </button>
            </div>

            <div class="absolute bottom-4 left-4 flex items-center gap-3 z-50">

                <div class="flex items-center bg-white border border-gray-200 rounded-md shadow-sm overflow-hidden">
                    <button onclick="App.setZoom(-0.1)"
                        class="w-8 h-8 flex items-center justify-center hover:bg-gray-50 text-gray-600 active:bg-gray-100 border-r border-gray-200 transition"
                        title="Dézoomer (-)">
                        <i class="fa-solid fa-minus text-xs"></i>
                    </button>

                    <button onclick="App.resetZoom()"
                        class="px-2 h-8 flex items-center justify-center hover:bg-gray-50 text-gray-600 text-[10px] font-bold font-mono active:bg-gray-100 min-w-[50px] transition"
                        title="Réinitialiser (100%)">
                        100%
                    </button>

                    <button onclick="App.setZoom(0.1)"
                        class="w-8 h-8 flex items-center justify-center hover:bg-gray-50 text-gray-600 active:bg-gray-100 border-l border-gray-200 transition"
                        title="Zoomer (+)">
                        <i class="fa-solid fa-plus text-xs"></i>
                    </button>
                </div>

                <div id="coord-display"
                    class="bg-white border border-gray-200 px-3 py-1.5 rounded-md shadow-sm text-[10px] font-mono text-gray-500 min-w-[80px] text-center select-none cursor-default">
                    x: 0 | y: 0
                </div>
            </div>
        </main>

        <aside id="panel-right"
            class="w-72 bg-panel border-l border-border flex flex-col shrink-0 z-10 transition-transform duration-300">
            <div class="flex border-b border-border bg-gray-50">
                <button onclick="App.setSideTab('props')" id="tab-btn-props" class="tab-btn active">Propriétés</button>
                <button onclick="App.setSideTab('bank')" id="tab-btn-bank" class="tab-btn">Banque</button>
            </div>

            <div id="view-props" class="flex-1 flex flex-col overflow-hidden">
                <div id="panel-empty"
                    class="flex-1 flex flex-col items-center justify-center text-gray-300 p-6 text-center">
                    <i class="fa-regular fa-object-group text-3xl mb-3 opacity-30"></i>
                    <p class="text-xs">Sélectionnez un objet</p>
                </div>

                <div id="panel-content" class="flex-1 overflow-y-auto p-5 hidden flex flex-col gap-6">

                    <div id="batch-radio-section"
                        class="hidden flex-col gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200">
                        <span class="text-[10px] font-bold uppercase text-blue-400">Groupe Radio</span>
                        <p class="text-[10px] text-blue-800 mb-1">Associer ces boutons au même groupe ?</p>
                        <div class="flex gap-2">
                            <input type="text" id="batch-grp-name" class="os-input flex-1 bg-white border-blue-200"
                                placeholder="Nom du groupe commun">
                            <button onclick="App.applyBatchGroup()"
                                class="bg-blue-600 text-white text-[10px] font-bold px-3 rounded hover:bg-blue-700 transition">OK</button>
                        </div>
                    </div>

                    <div id="sec-align" class="hidden flex-col gap-2 p-2 bg-gray-50 rounded-lg border border-gray-200">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Alignement</span>
                        <div class="grid grid-cols-4 gap-1">
                            <button onclick="App.align('left')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Gauche"><i class="fa-solid fa-align-left"></i></button>
                            <button onclick="App.align('center')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Centre Horizontal"><i class="fa-solid fa-align-center"></i></button>
                            <button onclick="App.align('right')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Droite"><i class="fa-solid fa-align-right"></i></button>
                            <button onclick="App.align('dist-h')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Distribuer Horizontal"><i class="fa-solid fa-arrows-left-right"></i></button>

                            <button onclick="App.align('top')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Haut"><i class="fa-solid fa-align-left"
                                    style="transform: rotate(90deg);"></i></button>
                            <button onclick="App.align('middle')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Milieu Vertical"><i class="fa-solid fa-align-center"
                                    style="transform: rotate(90deg);"></i></button>
                            <button onclick="App.align('bottom')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Bas"><i class="fa-solid fa-align-right"
                                    style="transform: rotate(90deg);"></i></button>
                            <button onclick="App.align('dist-v')"
                                class="p-1.5 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-200 rounded transition text-gray-600"
                                title="Distribuer Vertical"><i class="fa-solid fa-arrows-left-right"
                                    style="transform: rotate(90deg);"></i></button>
                        </div>
                    </div>

                    <div id="sec-config" class="flex flex-col gap-3">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Config</span>
                        <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">ID</span><input type="text" id="p-id"
                                class="os-input font-mono text-xs bg-gray-50"></div>

                        <div id="row-format" class="grid grid-cols-[60px_1fr] items-center gap-2">
                            <span class="text-xs font-medium">Format</span>
                            <select id="p-fmt" class="os-input">
                                <option value="text">Texte</option>
                                <option value="number">Nombre (€)</option>
                                <option value="date">Date</option>
                            </select>
                        </div>
                        <div id="row-align" class="grid grid-cols-[60px_1fr] items-center gap-2">
                            <span class="text-xs font-medium">Texte</span>
                            <div class="flex bg-gray-50 p-0.5 rounded border border-gray-200">
                                <button id="p-align-left" onclick="Panel.apply('textAlign', 'left')"
                                    class="align-btn flex-1 py-1 rounded hover:bg-white text-[10px] border border-transparent"><i
                                        class="fa-solid fa-align-left"></i></button>
                                <button id="p-align-center" onclick="Panel.apply('textAlign', 'center')"
                                    class="align-btn flex-1 py-1 rounded hover:bg-white text-[10px] border border-transparent"><i
                                        class="fa-solid fa-align-center"></i></button>
                                <button id="p-align-right" onclick="Panel.apply('textAlign', 'right')"
                                    class="align-btn flex-1 py-1 rounded hover:bg-white text-[10px] border border-transparent"><i
                                        class="fa-solid fa-align-right"></i></button>
                            </div>
                        </div>

                        <div id="sub-radio" class="hidden flex-col gap-2 p-2 bg-gray-50 rounded border border-gray-200">
                            <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                    class="text-xs">Groupe</span><input type="text" id="p-grp" class="os-input bg-white"
                                    placeholder="Nom du groupe"></div>
                            <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                    class="text-xs">Valeur</span><input type="text" id="p-val"
                                    class="os-input bg-white"></div>
                        </div>
                        <div id="sub-dropdown" class="hidden flex-col gap-1"><span
                                class="text-xs font-medium">Options</span><textarea id="p-opts"
                                class="os-input h-24 resize-none"></textarea></div>
                        <div class="flex gap-4 mt-1"><label
                                class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                    id="p-req" class="accent-black"> <span class="text-xs">Requis</span></label><label
                                class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                    id="p-read" class="accent-black"> <span class="text-xs">Lecture Seule</span></label>
                        </div>
                        <hr class="border-t border-border mt-2">
                    </div>
                    <div class="flex flex-col gap-3">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Apparence</span>
                        <div id="row-fill-check" class="flex items-center justify-between mb-1 hidden"><span
                                class="text-xs font-medium">Remplissage</span><label
                                class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                    id="p-has-fill" class="accent-black"> <span
                                    class="text-xs text-gray-500">Actif</span></label></div>
                        <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">Couleurs</span>
                            <div class="flex gap-2 w-full">
                                <div id="box-fill"
                                    class="flex-1 flex items-center border border-gray-300 rounded px-2 bg-white"><span
                                        class="text-[9px] mr-2 text-gray-400">FOND</span><input type="color" id="p-fill"
                                        class="w-full h-6 cursor-pointer"></div>
                                <div class="flex-1 flex items-center border border-gray-300 rounded px-2 bg-white"><span
                                        class="text-[9px] mr-2 text-gray-400">BORD</span><input type="color"
                                        id="p-stroke" class="w-full h-6 cursor-pointer"></div>
                            </div>
                        </div>
                        <div id="row-opacity" class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">Opacité</span>
                            <div class="flex items-center gap-2 w-full"><input type="range" id="p-opacity" min="0"
                                    max="1" step="0.1" class="flex-1"><span class="text-[10px] font-mono w-8 text-right"
                                    id="p-opacity-val">100%</span></div>
                        </div>
                        <div class="grid grid-cols-[60px_1fr] items-center gap-2"><span
                                class="text-xs font-medium">Bordure</span>
                            <div class="flex gap-2 w-full"><input type="number" id="p-width" min="0" max="20"
                                    class="os-input w-14 text-center"><select id="p-bstyle" class="os-input flex-1">
                                    <option value="solid">Trait Plein</option>
                                    <option value="underline">Souligné</option>
                                    <option value="none">Invisible</option>
                                </select></div>
                        </div>
                    </div>
                    <div id="sub-check" class="hidden p-2 bg-gray-50 border border-gray-200 rounded"><label
                            class="flex items-center gap-2 cursor-pointer select-none"><input type="checkbox"
                                id="p-checked" class="accent-black w-4 h-4"> <span
                                class="text-xs font-bold text-gray-700">Coché par
                                défaut</span></label></div>

                    <div id="sec-dims" class="flex flex-col gap-2 pt-4 border-t border-border">
                        <span class="text-[10px] font-bold uppercase text-gray-400">Dimensions (px)</span>
                        <div class="flex items-end gap-2">
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Largeur (W)</span>
                                <input type="number" id="p-dim-w" class="os-input w-full">
                            </div>
                            <button id="btn-ratio" onclick="Panel.toggleRatio()"
                                class="h-8 w-8 mb-[1px] rounded hover:bg-gray-100 text-gray-400 flex items-center justify-center transition"
                                title="Lier les proportions">
                                <i class="fa-solid fa-link-slash"></i>
                            </button>
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Hauteur (H)</span>
                                <input type="number" id="p-dim-h" class="os-input w-full">
                            </div>
                        </div>
                        <div class="flex items-end gap-2 mt-2">
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Pos X</span>
                                <input type="number" id="p-pos-x" class="os-input w-full">
                            </div>
                            <div class="flex flex-col flex-1">
                                <span class="text-[9px] text-gray-400 mb-1">Pos Y</span>
                                <input type="number" id="p-pos-y" class="os-input w-full">
                            </div>
                        </div>
                    </div>
                    <div class="mt-auto pt-4"><button onclick="App.deleteSelection()"
                            class="w-full bg-white text-red-500 border border-red-100 hover:bg-red-50 py-2 rounded text-xs font-bold transition shadow-sm">Supprimer</button>
                    </div>
                </div>
            </div>

            <div id="view-bank" class="hidden flex-1 flex flex-col p-4 gap-4 overflow-y-auto bg-gray-50">

                <div class="bg-white border border-dashed border-blue-300 p-4 rounded-lg flex flex-col items-center justify-center text-center gap-2 hover:bg-blue-50 transition cursor-pointer"
                    onclick="document.getElementById('img-input-bank').click()">
                    <div class="h-8 w-8 bg-blue-100 rounded-full flex items-center justify-center text-blue-600">
                        <i class="fa-solid fa-cloud-arrow-up"></i>
                    </div>
                    <div class="text-[10px] text-blue-800 font-bold uppercase">Importer Image</div>
                    <p class="text-[9px] text-gray-400">JPG, PNG supportés</p>
                </div>

                <div class="bg-white border border-gray-200 p-3 rounded-lg flex flex-col gap-2">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Création</span>
                    <button onclick="Bank.addFromSelection()"
                        class="bg-black text-white text-[10px] font-bold py-2 rounded hover:bg-gray-800 transition w-full flex items-center justify-center gap-2">
                        <i class="fa-solid fa-star"></i> Sauver la sélection
                    </button>
                    <p class="text-[9px] text-gray-400 italic text-center">Sélectionnez un texte stylisé sur le PDF et
                        cliquez ici pour le garder en mémoire.</p>
                </div>

                <hr class="border-gray-200">

                <div class="flex flex-col gap-2">
                    <span class="text-[10px] font-bold uppercase text-gray-400">Ma Bibliothèque</span>
                    <div id="bank-list" class="flex flex-col pb-4">
                        <div class="text-xs text-gray-400 text-center italic py-4">Vide pour l'instant</div>
                    </div>
                </div>
            </div>

            <input type="file" id="img-input-bank" class="hidden" accept="image/png, image/jpeg, image/jpg">
        </aside>
    </div>

    <input type="file" id="file-input" class="hidden" accept="application/pdf">
    <input type="file" id="project-input" class="hidden" accept=".json">
    <input type="file" id="img-input" class="hidden" accept="image/png, image/jpeg, image/jpg">
    <div id="help-overlay"
        class="fixed inset-0 bg-black/50 z-[200] hidden flex items-center justify-center backdrop-blur-sm transition-opacity">
        <div class="bg-white rounded-xl shadow-2xl w-[600px] h-[500px] flex flex-col overflow-hidden transform scale-95 transition-transform duration-200"
            id="help-box">

            <div class="px-6 py-4 border-b border-gray-100 flex justify-between items-center bg-gray-50">
                <h3 class="font-bold text-gray-800 flex items-center gap-2"><i
                        class="fa-solid fa-graduation-cap text-blue-500"></i> Centre d'Aide</h3>
                <button onclick="App.toggleHelp()" class="text-gray-400 hover:text-black transition"><i
                        class="fa-solid fa-xmark text-lg"></i></button>
            </div>

            <div class="flex border-b border-gray-200 px-6 gap-6 text-sm font-medium text-gray-500">
                <button onclick="App.setHelpTab('tuto')" id="ht-tuto"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600 active-tab">Tutoriel</button>
                <button onclick="App.setHelpTab('shortcuts')" id="ht-shortcuts"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600">Raccourcis</button>
                <button onclick="App.setHelpTab('tools')" id="ht-tools"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600">Fonctionnalités</button>
                <button onclick="App.setHelpTab('faq')" id="ht-faq"
                    class="help-tab py-3 border-b-2 border-transparent hover:text-blue-600">FAQ</button>
            </div>

            <div class="flex-1 overflow-y-auto p-6 bg-white text-sm text-gray-600">

                <div id="hc-tuto" class="help-content space-y-6">
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            1</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Importer</h4>
                            <p class="text-xs text-gray-500 mt-1">Cliquez sur <b
                                    class="bg-gray-100 px-1 rounded">PDF</b> pour charger votre document, ou commencez
                                sur une page blanche.</p>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            2</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Ajouter les Champs</h4>
                            <p class="text-xs text-gray-500 mt-1">Utilisez la barre de gauche pour ajouter des zones de
                                texte, cases à cocher, etc. Placez-les là où l'utilisateur devra écrire.</p>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            3</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Définir l'Ordre</h4>
                            <p class="text-xs text-gray-500 mt-1">Activez le bouton <b
                                    class="bg-gray-100 px-1 rounded">Séquence</b> et cliquez sur vos champs dans l'ordre
                                (1, 2, 3...) pour définir le trajet de la touche Tabulation.</p>
                        </div>
                    </div>
                    <div class="flex gap-4">
                        <div
                            class="w-8 h-8 bg-blue-100 text-blue-600 rounded-full flex items-center justify-center font-bold shrink-0">
                            4</div>
                        <div>
                            <h4 class="font-bold text-gray-800">Exporter</h4>
                            <p class="text-xs text-gray-500 mt-1">Cliquez sur <b
                                    class="bg-black text-white px-1 rounded">Export</b> pour télécharger votre PDF
                                final, prêt à être rempli !</p>
                        </div>
                    </div>
                </div>

                <div id="hc-shortcuts" class="help-content hidden space-y-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div class="bg-gray-50 p-3 rounded border border-gray-100">
                            <span class="block text-xs font-bold text-gray-400 uppercase mb-2">Outils</span>
                            <div class="flex justify-between mb-1"><span>Sélection (Flèche)</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">V / S</code>
                            </div>
                            <div class="flex justify-between mb-1"><span>Main (Pan)</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">M</code>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded border border-gray-100">
                            <span class="block text-xs font-bold text-gray-400 uppercase mb-2">Navigation</span>
                            <div class="flex justify-between mb-1"><span>Déplacer</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Espace
                                    + Clic</code>
                            </div>
                            <div class="flex justify-between mb-1"><span>Zoomer</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Molette</code>
                            </div>
                            <div class="flex justify-between mb-1"><span>Précision</span> <code
                                    class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Flèches</code>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-3 rounded border border-gray-100 col-span-2">
                            <span class="block text-xs font-bold text-gray-400 uppercase mb-2">Action</span>
                            <div class="grid grid-cols-2 gap-x-8">
                                <div class="flex justify-between mb-1"><span>Annuler</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + Z</code></div>
                                <div class="flex justify-between mb-1"><span>Rétablir</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + Y</code></div>
                                <div class="flex justify-between mb-1"><span>Copier / Coller</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + C / V</code></div>
                                <div class="flex justify-between mb-1"><span>Dupliquer</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + D</code></div>
                                <div class="flex justify-between mb-1"><span>Tout Sélectionner</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + A</code></div>
                                <div class="flex justify-between mb-1"><span>Sauvegarder</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Ctrl
                                        + S</code></div>
                                <div class="flex justify-between mb-1"><span>Supprimer</span> <code
                                        class="bg-white px-1.5 py-0.5 rounded border border-gray-200 font-mono text-xs text-black">Suppr</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="hc-tools" class="help-content hidden space-y-4">
                    <div class="flex gap-4">
                        <div
                            class="w-10 h-10 bg-blue-50 text-blue-600 rounded flex items-center justify-center shrink-0">
                            <i class="fa-solid fa-file-pen"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Champs de Formulaire</h4>
                            <p class="text-xs text-gray-500 mt-1 leading-relaxed">
                                Créez des champs interactifs pour le PDF final :
                                <br>• <b>Champ Texte (I)</b> : Pour les noms, adresses...
                                <br>• <b>Paragraphe (¶)</b> : Pour les textes longs (multilignes).
                                <br>• <b>Check / Radio</b> : Cases à cocher et choix uniques.
                                <br>• <b>Menu Déroulant</b> : Liste de choix.
                            </p>
                        </div>
                    </div>
                    <hr class="border-gray-100">
                    <div class="flex gap-4">
                        <div
                            class="w-10 h-10 bg-orange-100 text-orange-600 rounded flex items-center justify-center shrink-0">
                            <i class="fa-solid fa-arrow-down-1-9"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Ordre de Tabulation</h4>
                            <p class="text-xs text-gray-500 mt-1 leading-relaxed">
                                Contrôlez l'ordre dans lequel l'utilisateur passe d'un champ à l'autre (touche Tab).
                                <br>• <b>Mode Séquence</b> : Cliquez sur vos champs dans l'ordre (1, 2, 3...).
                                <br>• <b>Vue Flux (Route)</b> : Affiche des flèches bleues pour visualiser le parcours.
                                <br>• <b>Liste Latérale</b> : Glissez-déposez les calques pour réorganiser l'ordre.
                            </p>
                        </div>
                    </div>
                    <hr class="border-gray-100">
                    <div class="flex gap-4">
                        <div
                            class="w-10 h-10 bg-purple-100 text-purple-600 rounded flex items-center justify-center shrink-0">
                            <i class="fa-solid fa-shapes"></i>
                        </div>
                        <div>
                            <h4 class="font-bold text-gray-800">Banque & Dessin</h4>
                            <p class="text-xs text-gray-500 mt-1 leading-relaxed">
                                • <b>Dessin</b> : Ajoutez des rectangles, cercles, lignes ou images pour décorer ou
                                masquer
                                des zones.
                                <br>• <b>Banque (Modèles)</b> : Sauvegardez vos champs complexes (ex: un groupe de
                                boutons
                                Radio pré-configuré) pour les réutiliser sur d'autres pages ou projets.
                            </p>
                        </div>
                    </div>
                </div>

                <div id="hc-faq" class="help-content hidden space-y-4">
                    <div class="p-3 bg-red-50 rounded border border-red-100">
                        <h4 class="font-bold text-red-800 text-xs mb-1">Pourquoi je ne peux pas tourner les champs ?
                        </h4>
                        <p class="text-xs text-red-600">La rotation est volontairement bloquée sur les champs de
                            formulaire
                            (Input, Checkbox...) car la plupart des lecteurs PDF ne supportent pas la saisie de texte en
                            biais. Seuls les dessins (rectangles, cercles) peuvent être tournés.</p>
                    </div>
                    <div class="p-3 bg-blue-50 rounded border border-blue-100">
                        <h4 class="font-bold text-blue-800 text-xs mb-1">Champs Transparents</h4>
                        <p class="text-xs text-blue-600">Pour rendre un champ invisible à l'impression (fond
                            transparent),
                            sélectionnez-le et décochez la case <b>"Actif"</b> dans la section Remplissage (panneau de
                            droite).</p>
                    </div>
                    <div class="p-3 bg-gray-50 rounded border border-gray-200">
                        <h4 class="font-bold text-gray-800 text-xs mb-1">Sauvegarde & Export</h4>
                        <p class="text-xs text-gray-500">
                            • <b>Sauvegarder (.json)</b> : Garde tout éditable (calques, ordre, historique).
                            <br>• <b>Export PDF</b> : Génère le fichier final utilisable. Les champs seront calés au
                            pixel
                            près par rapport au fond.
                        </p>
                    </div>
                </div>

            </div>

            <div class="p-4 border-t border-gray-100 bg-gray-50 text-center">
                <button onclick="App.toggleHelp()"
                    class="bg-gray-800 hover:bg-black text-white px-6 py-2 rounded text-xs font-bold transition">Fermer</button>
            </div>
        </div>
    </div>
    <div id="context-menu"
        class="fixed bg-white shadow-xl border border-gray-200 rounded-lg py-1 z-[300] hidden w-40 text-xs">
        <button onclick="App.duplicate(); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-gray-100 flex items-center gap-2"><i
                class="fa-regular fa-copy"></i> Dupliquer</button>
        <button onclick="App.deleteSelection(); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-red-50 text-red-600 flex items-center gap-2"><i
                class="fa-solid fa-trash"></i> Supprimer</button>
        <div class="h-px bg-gray-100 my-1"></div>
        <button onclick="State.canvas.sendBackwards(State.canvas.getActiveObject()); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-gray-100">Reculer</button>
        <button onclick="State.canvas.bringForward(State.canvas.getActiveObject()); App.hideCtx()"
            class="w-full text-left px-4 py-2 hover:bg-gray-100">Avancer</button>
    </div>
    <script>
        
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
            Bank.init(); // <--- AJOUTER ICI
        });
        if (window.fabric) {
            fabric.Object.prototype.set({ transparentCorners: false, cornerColor: '#1c1c1e', cornerStyle: 'circle', cornerSize: 8, borderColor: '#1c1c1e' });
            fabric.Text.prototype.textBaseline = 'top'; fabric.IText.prototype.textBaseline = 'top'; fabric.Textbox.prototype.textBaseline = 'top';
        }

        const customProps = ['ctype', 'pid', 'grp', 'val', 'opts', 'bStyle', 'isChecked', 'fmt', 'tAlign', 'lockScalingX', 'lockScalingY', 'srcObj', 'id', 'isBackground', 'evented', 'selectable'];
        // --- GESTION DE LA BANQUE (Corrigé) ---
        const Bank = {
            items: [],
            storageKey: 'prof_toolbox_bank_v2', // Nouvelle clé pour éviter les conflits avec l'ancienne version buggée
            maxSize: 4.8 * 1024 * 1024,

            init: () => {
                Bank.load();
                const input = document.getElementById('img-input-bank');
                if (input) {
                    input.addEventListener('change', (e) => {
                        const file = e.target.files[0];
                        if (!file) return;
                        Bank.compressImageFile(file, 600, 0.7, (compressedData) => {
                            Bank.add('image', compressedData, compressedData, file.name);
                        });
                        e.target.value = '';
                    });
                }
                if (typeof DropZone !== 'undefined') DropZone.init();
            },

            load: () => {
                const saved = localStorage.getItem(Bank.storageKey);
                if (saved) { try { Bank.items = JSON.parse(saved); } catch (e) { console.error(e); } }
                Bank.render();
                Bank.updateStorageUI();
            },

            saveStorage: () => {
                try {
                    const json = JSON.stringify(Bank.items);
                    if (new Blob([json]).size > Bank.maxSize) {
                        alert("⚠️ Banque pleine !");
                        return false;
                    }
                    localStorage.setItem(Bank.storageKey, json);
                    Bank.updateStorageUI();
                    return true;
                } catch (e) { return false; }
            },

            compressImageFile: (file, maxWidth, quality, callback) => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        let w = img.width, h = img.height;
                        if (w > maxWidth) { h *= maxWidth / w; w = maxWidth; }
                        canvas.width = w; canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, w, h);
                        callback(canvas.toDataURL('image/jpeg', quality));
                    }
                };
                reader.readAsDataURL(file);
            },

            add: (type, content, preview, name = "Sans titre") => {
                const item = { id: Date.now() + Math.random(), type, content, preview, name };
                Bank.items.push(item);
                if (!Bank.saveStorage()) Bank.items.pop();
                else Bank.render();
            },

            // --- CORRECTION MAJEURE ICI ---
            addFromSelection: () => {
                const active = State.canvas.getActiveObject();
                if (!active) { App.showModal("Erreur", "Sélectionnez un objet."); return; }

                // On clone pour ne pas toucher à l'original
                active.clone((cloned) => {
                    cloned.set({ left: 0, top: 0 });

                    // Génération de l'image
                    const previewData = cloned.toDataURL({ format: 'jpeg', quality: 0.7, multiplier: 0.5, enableRetinaScaling: false });

                    // SAUVEGARDE PROFONDE
                    // includeDefaultValues: false allège le JSON
                    // customProps est passé pour s'assurer que 'ctype' est gardé PARTOUT
                    const objData = cloned.toObject(customProps);

                    // Sécurité : si c'est un groupe simple qui a perdu son ctype, on le remet
                    if (active.ctype && !objData.ctype) objData.ctype = active.ctype;

                    const json = JSON.stringify(objData);

                    let name = "Objet";
                    if (active.type === 'activeSelection') name = `Groupe (${active._objects.length})`;
                    else if (active.ctype) name = active.ctype;
                    else if (['i-text', 'text', 'textbox'].includes(active.type)) name = "Texte";

                    Bank.add('template', json, previewData, name);
                    App.showModal("Sauvegardé", "Ajouté à la bibliothèque.");
                }, customProps); // <--- Ce 2ème argument est vital pour que clone() copie les props
            },

            remove: (id) => {
                if (!confirm("Supprimer ?")) return;
                Bank.items = Bank.items.filter(i => i.id !== id);
                Bank.saveStorage();
                Bank.render();
            },

            updateStorageUI: () => {
                const el = document.getElementById('storage-fill');
                const txt = document.getElementById('storage-text');
                if (!el) return;
                const size = new Blob([JSON.stringify(Bank.items)]).size;
                const pct = Math.min(100, (size / Bank.maxSize) * 100);
                el.style.width = pct + '%';
                el.style.backgroundColor = pct > 90 ? '#ef4444' : '#2563eb';
                if (txt) txt.innerText = `${(size / 1024).toFixed(0)} Ko`;
            },

            editName: (e, id, span) => {
                e.preventDefault(); e.stopPropagation();
                const item = Bank.items.find(i => i.id === id);
                if (!item) return;
                const input = document.createElement('input');
                input.type = 'text'; input.value = item.name; input.className = 'bank-name-input';
                const save = () => { if (input.value.trim()) { item.name = input.value.trim(); Bank.saveStorage(); } Bank.render(); };
                input.addEventListener('blur', save);
                input.addEventListener('keydown', k => { if (k.key === 'Enter') input.blur(); if (k.key === 'Escape') Bank.render(); k.stopPropagation(); });
                input.addEventListener('mousedown', ev => ev.stopPropagation());
                span.replaceWith(input); input.focus(); input.select();
            },

            render: () => {
                const container = document.getElementById('bank-list');
                if (!container) return;
                container.innerHTML = '';
                if (Bank.items.length === 0) { container.innerHTML = '<div class="text-xs text-gray-400 text-center italic py-4">Vide</div>'; return; }
                [...Bank.items].reverse().forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'bank-item group';
                    el.draggable = true;
                    const previewImg = `<img src="${item.preview}" class="bank-preview bg-gray-100 object-contain w-10 h-10 rounded pointer-events-none">`;
                    el.innerHTML = `${previewImg}<div class="flex flex-col overflow-hidden flex-1 pointer-events-none"><div class="flex items-center gap-1 w-full pointer-events-auto"><span class="text-[10px] font-bold truncate cursor-text hover:text-blue-600 px-1 transition-colors" onclick="Bank.editName(event, ${item.id}, this)">${item.name}</span></div><span class="text-[9px] text-gray-400 uppercase">${item.type === 'template' ? 'Modèle' : 'Image'}</span></div><i class="fa-solid fa-trash bank-del-btn pointer-events-auto" onclick="Bank.remove(${item.id})"></i>`;
                    el.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('application/json', JSON.stringify({ origin: 'bank', type: item.type, content: item.content }));
                        e.dataTransfer.effectAllowed = 'copy';
                    });
                    container.appendChild(el);
                });
            }
        };
        const DropZone = {
            init: () => {
                const workspace = document.getElementById('workspace');
                if (!workspace) return;

                workspace.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
                workspace.addEventListener('drop', (e) => {
                    e.preventDefault();

                    const rawData = e.dataTransfer.getData('application/json');
                    if (!rawData) return;

                    try {
                        const data = JSON.parse(rawData);
                        if (data.origin !== 'bank') return;

                        const pointer = State.canvas.getPointer(e);

                        if (data.type === 'template') {
                            const jsonContent = JSON.parse(data.content);

                            fabric.util.enlivenObjects([jsonContent], (objects) => {
                                const rootObj = objects[0];
                                if (!rootObj) return;

                                // 1. CALCUL DU DÉCALAGE (Pour placer sous la souris)
                                const currentCenter = rootObj.getCenterPoint();
                                const dx = pointer.x - currentCenter.x;
                                const dy = pointer.y - currentCenter.y;

                                // 2. PRÉPARATION DE LA LISTE À PLACER
                                let finalObjects = [];

                                if (rootObj.type === 'activeSelection') {
                                    // Cas A : Plusieurs objets sauvés ensemble
                                    const items = rootObj.getObjects();
                                    items.forEach(child => {
                                        child.left += dx; child.top += dy;
                                        child.setCoords();
                                        finalObjects.push(child);
                                    });
                                } else if (rootObj.type === 'group' && !rootObj.ctype) {
                                    // Cas B : Groupe purement graphique (Dessin) -> On le garde groupé ou on l'éclate selon besoin
                                    // Ici, on décide de le poser tel quel, mais de le traiter comme un objet unique
                                    rootObj.set({ left: pointer.x, top: pointer.y, originX: 'center', originY: 'center' });
                                    rootObj.setCoords();
                                    // Si on veut pouvoir éditer les morceaux du dessin, on peut l'éclater :
                                    // State.canvas.add(rootObj); const sel = rootObj.toActiveSelection(); finalObjects = sel.getObjects();
                                    // Sinon on le garde groupé :
                                    finalObjects = [rootObj];
                                } else {
                                    // Cas C : Objet unique ou Input (Checkbox, Textfield...)
                                    rootObj.set({ left: pointer.x, top: pointer.y, originX: 'center', originY: 'center' });
                                    finalObjects = [rootObj];
                                }

                                // ============================================================
                                // 3. LE CERVEAU : REMAPPING DES IDs ET GROUPES
                                // ============================================================

                                // Dictionnaire pour mapper les anciens noms de groupes radio vers les nouveaux
                                // Cela garantit que les radios d'un MEME drop restent liés, 
                                // mais isolés des drops précédents.
                                const radioGroupMap = {};

                                finalObjects.forEach(obj => {
                                    // A. RESTAURATION DES LIENS INTERNES (Pour que les inputs marchent)
                                    if (obj.type === 'group' && obj.ctype) {
                                        const items = obj.getObjects();
                                        obj.bgObj = items[0];
                                        // On retrouve les enfants (Texte ou Coche)
                                        if (items[1]) {
                                            if (['textfield', 'textarea', 'dropdown'].includes(obj.ctype)) obj.txtObj = items[1];
                                            if (['checkbox', 'radio'].includes(obj.ctype)) obj.markObj = items[1];
                                        }
                                        // On reverrouille les enfants pour éviter les bugs de sélection interne
                                        items.forEach(k => {
                                            k.selectable = false;
                                            k.evented = false;
                                            k.lockMovementX = true; k.lockMovementY = true;
                                        });
                                        // On réapplique les verrous globaux du groupe
                                        if (['textfield', 'textarea', 'checkbox', 'radio', 'dropdown', 'label'].includes(obj.ctype)) {
                                            obj.setControlsVisibility({ mtr: false });
                                            obj.lockRotation = true;
                                        }
                                    }

                                    // B. GÉNÉRATION D'UN NOUVEL ID UNIQUE (PID)
                                    // Obligatoire pour éviter les doublons d'ID dans le PDF
                                    if (obj.ctype) {
                                        obj.pid = Factory.getSafeId(obj.ctype);
                                    }

                                    // C. GESTION INTELLIGENTE DES RADIOS
                                    if (obj.ctype === 'radio' && obj.grp) {
                                        const oldGrp = obj.grp;

                                        // Si on n'a pas encore créé de nouveau nom pour ce groupe DANS CE DROP...
                                        if (!radioGroupMap[oldGrp]) {
                                            // ... on en crée un unique (ex: "Sexe_17458992")
                                            radioGroupMap[oldGrp] = `${oldGrp}_${Date.now()}_${Math.floor(Math.random() * 1000)}`;
                                        }

                                        // On assigne le nouveau nom mappé
                                        obj.grp = radioGroupMap[oldGrp];

                                        // La valeur (val: "A", "B"...) reste inchangée, c'est ce qu'on veut.
                                    }

                                    // D. AJOUT AU CANVAS
                                    if (!obj.canvas) State.canvas.add(obj);
                                    obj.setCoords();
                                });

                                // 4. SÉLECTION FINALE (UX)
                                if (finalObjects.length > 1) {
                                    const sel = new fabric.ActiveSelection(finalObjects, { canvas: State.canvas });
                                    State.canvas.setActiveObject(sel);
                                } else if (finalObjects.length === 1) {
                                    State.canvas.setActiveObject(finalObjects[0]);
                                }

                                State.canvas.requestRenderAll();
                                Panel.update(State.canvas.getActiveObject());
                                Navigator.refresh();
                                History.save();
                            });
                        }
                        // GESTION DES IMAGES SIMPLES
                        else if (data.type === 'image') {
                            fabric.Image.fromURL(data.content, (img) => {
                                if (img.width > 300) img.scaleToWidth(300);
                                img.set({
                                    left: pointer.x, top: pointer.y,
                                    originX: 'center', originY: 'center',
                                    ctype: 'image',
                                    pid: Factory.getName('image')
                                });
                                Factory.ensureUniqueId(img);
                                img.srcObj = data.content;
                                State.canvas.add(img);
                                State.canvas.setActiveObject(img);
                                Navigator.refresh();
                                History.save();
                            });
                        }
                    } catch (err) { console.error("Erreur Drop:", err); }
                });
            }
        };


        const History = {


            stack: [],
            idx: -1,
            max: 50,
            processing: false,

            save: () => {
                if (History.processing) return;
                if (History.idx < History.stack.length - 1) History.stack = History.stack.slice(0, History.idx + 1);

                // Gestion Undo/Redo (inchangée)
                const raw = State.canvas.toObject(customProps);
                raw.objects = raw.objects.filter(o => !o.isGuide);
                History.stack.push(JSON.stringify(raw));
                if (History.stack.length > History.max) History.stack.shift(); else History.idx++;

                // APPEL AUTO-SAVE
                App.saveAuto(); // <--- C'est ici qu'on appelle la nouvelle fonction

                Navigator.refresh();
            },
            restore: (json) => {
                History.processing = true;
                App.clearGuides();
                State.canvas.clear();
                State.canvas.loadFromJSON(json, () => {
                    State.canvas.renderAll();
                    App.restoreRefs();
                    History.processing = false;
                    Panel.update(null);
                    Navigator.refresh();
                });
            },

            undo: () => { if (History.idx > 0) { History.idx--; History.restore(History.stack[History.idx]); } },
            redo: () => { if (History.idx < History.stack.length - 1) { History.idx++; History.restore(History.stack[History.idx]); } }
        };

        const State = {
            showFlowLines: false,
            pages: [],       // Tableau qui stockera le JSON de chaque page
            currentPage: 0,  // Index de la page active (commence à 0)
            totalPages: 1,    // Nombre total de pages
            sequenceList: [], // Pour stocker l'ordre temporaire
            isSequencing: false, canvas: null, mode: 'select', snap: true, isPreview: false, pdfBytes: null, clipboard: null, counts: { draw : 1, textfield: 1, textarea: 1, checkbox: 1, radio: 1, dropdown: 1, label: 1, rect: 1, circle: 1, radiogroup: 1, image: 1 }, defaults: { fill: '#ffffff', stroke: '#000000', width: 1, font: 'Arial', size: 12, lock: true, defHeight: 24, boxSize: 14 }
        };

        const Navigator = {
            dom: document.getElementById('navigator-list'),
            lastSelectedIndex: -1,

            refresh: () => {
                const list = Navigator.dom;
                list.innerHTML = '';

                const allObjs = State.canvas.getObjects();
                const navObjs = allObjs.filter(o => !o.isBackground && !o.isGuide);
                const activeObjs = State.canvas.getActiveObjects();

                navObjs.forEach((o, index) => {
                    const div = document.createElement('div');
                    div.className = 'nav-item';
                    if (activeObjs.includes(o)) div.classList.add('active');

                    div.draggable = true;
                    div.dataset.canvasIndex = allObjs.indexOf(o);

                    // --- Icone et Label ---
                    let icon = 'fa-square';
                    let extra = '';
                    if (o.ctype === 'textfield') icon = 'fa-font';
                    else if (o.ctype === 'checkbox') icon = 'fa-check-square';
                    else if (o.ctype === 'radio') { icon = 'fa-circle-dot'; extra = ` (${o.grp}) - ${o.val}`; }
                    else if (o.ctype === 'image') icon = 'fa-image';

                    const label = (o.pid || (o.ctype ? o.ctype : 'Forme')) + extra;

                    // On ajoute le numéro de séquence si dispo
                    let seqBadge = '';
                    if (State.sequenceList.includes(o)) {
                        const num = State.sequenceList.indexOf(o) + 1;
                        seqBadge = `<span class="bg-blue-100 text-blue-600 text-[9px] font-bold px-1 rounded ml-auto">${num}</span>`;
                    }

                    div.innerHTML = `
                <div class="flex items-center gap-2 flex-1 overflow-hidden pointer-events-none">
                    <span class="text-gray-300 w-4 text-[9px] text-center">${index + 1}</span>
                    <i class="fa-solid ${icon} text-gray-400"></i> 
                    <span class="truncate text-[10px] font-medium">${label}</span>
                    ${seqBadge}
                </div>
            `;

                    // --- Events Clic (Selection) ---
                    div.addEventListener('click', (e) => {
                        // ... (Ton code de sélection existant, pas de changement nécessaire ici) ...
                        const currentListIndex = index;
                        let newSelection = [];
                        if (e.shiftKey && Navigator.lastSelectedIndex !== -1) {
                            const start = Math.min(Navigator.lastSelectedIndex, currentListIndex);
                            const end = Math.max(Navigator.lastSelectedIndex, currentListIndex);
                            for (let i = start; i <= end; i++) newSelection.push(navObjs[i]);
                        } else if (e.ctrlKey || e.metaKey) {
                            newSelection = [...State.canvas.getActiveObjects()];
                            if (newSelection.includes(o)) newSelection = newSelection.filter(item => item !== o);
                            else newSelection.push(o);
                            Navigator.lastSelectedIndex = currentListIndex;
                        } else {
                            newSelection = [o];
                            Navigator.lastSelectedIndex = currentListIndex;
                        }
                        State.canvas.discardActiveObject();
                        if (newSelection.length > 0) {
                            const sel = new fabric.ActiveSelection(newSelection, { canvas: State.canvas });
                            State.canvas.setActiveObject(sel);
                        } else {
                            Panel.update(null);
                        }
                        State.canvas.requestRenderAll();
                    });

                    // --- Drag & Drop (Le coeur du changement) ---
                    div.addEventListener('dragstart', (e) => {
                        const active = State.canvas.getActiveObjects();
                        let indicesToMove = active.includes(o) ? active.map(obj => allObjs.indexOf(obj)) : [allObjs.indexOf(o)];
                        e.dataTransfer.setData('application/json', JSON.stringify(indicesToMove));
                        div.classList.add('dragging');
                    });

                    div.addEventListener('dragend', () => { div.classList.remove('dragging'); });
                    div.addEventListener('dragover', (e) => { e.preventDefault(); div.style.borderTop = "2px solid #2563eb"; });
                    div.addEventListener('dragleave', () => { div.style.borderTop = "none"; });

                    div.addEventListener('drop', (e) => {
                        e.preventDefault();
                        div.style.borderTop = "none";
                        const rawData = e.dataTransfer.getData('application/json');
                        if (!rawData) return;

                        const fromIndices = JSON.parse(rawData);
                        const targetCanvasIndex = parseInt(div.dataset.canvasIndex);
                        const targetObj = allObjs[targetCanvasIndex];

                        if (fromIndices.includes(targetCanvasIndex)) return;

                        const objsToMove = fromIndices.map(i => allObjs[i]);
                        // On trie pour garder l'ordre relatif
                        objsToMove.sort((a, b) => allObjs.indexOf(a) - allObjs.indexOf(b));

                        // Déplacement Fabric (Z-Index)
                        [...objsToMove].reverse().forEach(obj => {
                            const currentTargetIndex = State.canvas.getObjects().indexOf(targetObj);
                            obj.moveTo(currentTargetIndex);
                        });

                        // --- MISE A JOUR DE LA SÉQUENCE ---
                        // C'est ici ! Une fois déplacé, on recalcule la liste de séquence.
                        App.syncSequenceFromLayers();
                        // ----------------------------------

                        State.canvas.requestRenderAll();
                        History.save();
                        Navigator.refresh();
                    });

                    list.appendChild(div);
                });
            }
        };
        const Factory = {
            getSafeId: (type) => {
                let candidate;
                do {
                    candidate = `${type}_${State.counts[type]++}`;
                } while (State.canvas.getObjects().some(o => o.pid === candidate));
                return candidate;
            },
            getName: (t) => Factory.getSafeId(t),
            ensureUniqueId: (obj) => {
                if (obj.ctype) {
                    obj.set('pid', Factory.getSafeId(obj.ctype));
                    if (obj.ctype === 'radio') {
                        obj.set('grp', `Groupe_${State.counts.radiogroup++}`);
                    }
                }
            },

            // --- INPUT TEXTE / TEXTAREA / DROPDOWN ---
            createInputGroup: (l, t, w, h, type) => {
                const rect = new fabric.Rect({
                    width: w, height: h,
                    fill: State.defaults.fill,
                    stroke: State.defaults.stroke,
                    strokeWidth: State.defaults.width,
                    originX: 'left', originY: 'top'
                });
                const text = new fabric.Textbox("", {
                    width: w - 8,
                    fontSize: State.defaults.size,
                    fontFamily: State.defaults.font,
                    left: 4, top: 4,
                    originX: 'left', originY: 'top',
                    splitByGrapheme: type === 'textarea',
                    editable: true
                });

                // === FIX DÉFINITIF ROTATION ===
                // 1. On rend les sous-objets non sélectionnables individuellement
                rect.selectable = false;
                text.selectable = false;

                // 2. On désactive complètement les contrôles et transformations sur les sous-objets
                rect.hasControls = false;
                rect.hasBorders = false;
                rect.lockMovementX = rect.lockMovementY = true;
                rect.lockScalingX = rect.lockScalingY = true;
                rect.lockRotation = true;

                text.hasControls = false;
                text.hasBorders = false;
                text.lockMovementX = text.lockMovementY = true;
                text.lockScalingX = text.lockScalingY = true;
                text.lockRotation = true;

                const lockY = (type === 'textfield' && State.defaults.lock);

                const grp = new fabric.Group([rect, text], {
                    left: l, top: t,
                    subTargetCheck: true,   // Gardé à true pour que le dblclick détecte le texte et déclenche l'édition
                    lockScalingY: lockY,
                    lockRotation: true
                });

                const controls = { mtr: false };
                if (lockY) Object.assign(controls, { mt: false, mb: false, ml: true, mr: true });
                grp.setControlsVisibility(controls);

                grp.set({ ctype: type, pid: Factory.getName(type), bStyle: 'solid', fmt: 'text', tAlign: 'left' });
                grp.bgObj = rect; grp.txtObj = text;
                return grp;
            },

            // --- CHECKBOX ---
            createCheckbox: (l, t) => {
                const s = State.defaults.boxSize;
                const rect = new fabric.Rect({
                    width: s, height: s,
                    fill: State.defaults.fill,
                    stroke: State.defaults.stroke,
                    strokeWidth: State.defaults.width,
                    originX: 'center', originY: 'center'
                });
                const mark = new fabric.Text("✕", {
                    fontSize: s - 4,
                    fontFamily: 'Arial',
                    fill: State.defaults.stroke,
                    originX: 'center', originY: 'center',
                    opacity: 0, selectable: false
                });

                rect.hasControls = false;
                rect.lockRotation = true;
                rect.selectable = false; // Par sécurité

                const locked = State.defaults.lock;

                const grp = new fabric.Group([rect, mark], {
                    left: l, top: t,
                    subTargetCheck: false,
                    lockUniScaling: true,
                    lockRotation: true
                });

                const controls = { mtr: false };

                if (locked) {
                    grp.set({ lockScalingX: true, lockScalingY: true });
                    Object.assign(controls, { tl: false, tr: false, bl: false, br: false, mt: false, mb: false, ml: false, mr: false });
                } else {
                    Object.assign(controls, { mt: false, mb: false, ml: false, mr: false });
                }

                grp.setControlsVisibility(controls);
                grp.set({ ctype: 'checkbox', pid: Factory.getName('checkbox'), isChecked: false });
                grp.bgObj = rect; grp.markObj = mark;
                return grp;
            },

            // --- RADIO ---
            createRadio: (l, t) => {
                const s = State.defaults.boxSize;
                const outer = new fabric.Circle({
                    radius: s / 2,
                    fill: State.defaults.fill,
                    stroke: State.defaults.stroke,
                    strokeWidth: State.defaults.width,
                    originX: 'center', originY: 'center'
                });
                const inner = new fabric.Circle({
                    radius: s / 4,
                    fill: State.defaults.stroke,
                    originX: 'center', originY: 'center',
                    opacity: 0, selectable: false
                });

                outer.hasControls = false;
                outer.lockRotation = true;
                outer.selectable = false; // Par sécurité

                const locked = State.defaults.lock;

                const grp = new fabric.Group([outer, inner], {
                    left: l, top: t,
                    subTargetCheck: false,
                    lockUniScaling: true,
                    lockRotation: true
                });

                const controls = { mtr: false };

                if (locked) {
                    grp.set({ lockScalingX: true, lockScalingY: true });
                    Object.assign(controls, { tl: false, tr: false, bl: false, br: false, mt: false, mb: false, ml: false, mr: false });
                } else {
                    Object.assign(controls, { mt: false, mb: false, ml: false, mr: false });
                }

                grp.setControlsVisibility(controls);
                grp.set({
                    ctype: 'radio',
                    pid: Factory.getName('radio'),
                    isChecked: false,
                    grp: `Groupe_${State.counts.radiogroup++}`,
                    val: 'A'
                });
                grp.bgObj = outer; grp.markObj = inner;
                return grp;
            },

            // --- FORMES (RECTANGLE/CERCLE/LIGNE) ---
            createShape: (type, l, t, w, h) => {
                let obj;
                const opts = { left: l, top: t, width: w, height: h, fill: 'transparent', stroke: State.defaults.stroke, strokeWidth: State.defaults.width };
                if (type === 'rect') obj = new fabric.Rect(opts);
                else if (type === 'circle') obj = new fabric.Ellipse({ ...opts, rx: w / 2, ry: h / 2 });
                else if (type === 'line') obj = new fabric.Line([l, t, l + w, t + h], { stroke: State.defaults.stroke, strokeWidth: State.defaults.width });

                obj.ctype = 'draw';
                return obj;
            },

            // --- LABEL ---
            createLabel: (l, t) => {
                const obj = new fabric.IText("Texte", {
                    left: l, top: t,
                    fontSize: State.defaults.size,
                    fontFamily: State.defaults.font,
                    fill: State.defaults.stroke
                });
                obj.ctype = 'label';
                obj.lockRotation = true;
                obj.setControlsVisibility({ mtr: false });
                return obj;
            }
        };
        const App = {
            setZoom: (delta) => {
                let zoom = State.canvas.getZoom();
                zoom += delta;
                if (zoom > 5) zoom = 5;
                if (zoom < 0.1) zoom = 0.1;
                State.canvas.setZoom(zoom);
                State.canvas.requestRenderAll();
            },
            resetZoom: () => {
                State.canvas.setZoom(1);
                // Centre la vue
                State.canvas.viewportTransform[4] = (State.canvas.width - State.canvas.pageW) / 2;
                State.canvas.viewportTransform[5] = 20;
                State.canvas.requestRenderAll();
            },
            checkAutoSave: () => {
                const saved = localStorage.getItem('prof_toolbox_autosave');

                if (!saved) {
                    console.log("Aucune sauvegarde trouvée.");
                    return;
                }

                try {
                    const data = JSON.parse(saved);

                    // Vérification basique pour ne pas charger n'importe quoi
                    if (!data.pages || !Array.isArray(data.pages)) {
                        console.error("Sauvegarde corrompue");
                        return;
                    }

                    const date = new Date(data.timestamp).toLocaleString();
                    if (confirm(`Une session précédente (${date}) a été trouvée.\nVoulez-vous la restaurer ?`)) {

                        // 1. Restaurer les variables d'état
                        State.pages = data.pages;
                        State.totalPages = data.totalPages || data.pages.length;

                        // 2. Restaurer les dimensions (TRÈS IMPORTANT pour l'alignement)
                        if (data.dims) {
                            State.canvas.pageW = data.dims.w;
                            State.canvas.pageH = data.dims.h;
                            State.canvas.pageOffset = { x: data.dims.offX, y: data.dims.offY };

                            // On force le redimensionnement du viewport
                            App.resize();
                        }

                        // 3. Charger la page (avec un petit délai pour être sûr que Fabric est prêt)
                        setTimeout(() => {
                            App.loadPage(data.currentPage || 0);
                            App.showModal("Restauration", "Votre session a été récupérée avec succès.");
                        }, 100);
                    } else {
                        // Si l'utilisateur dit NON, on peut nettoyer pour ne pas redemander
                        // localStorage.removeItem('prof_toolbox_autosave'); // Décommente si tu veux supprimer au refus
                    }
                } catch (e) {
                    console.error("Erreur lors de la lecture de l'auto-save", e);
                    // Si c'est planté, on nettoie pour éviter que ça replante au prochain démarrage
                    localStorage.removeItem('prof_toolbox_autosave');
                }
            },
            saveAuto: () => {
                // 1. On force la mise à jour de la page actuelle dans le tableau
                // (Sinon State.pages[current] risque d'être vide ou obsolète)
                App.saveCurrentPage();

                // 2. On prépare les données
                const data = {
                    version: "V46",
                    timestamp: Date.now(),
                    pages: State.pages,
                    currentPage: State.currentPage,
                    totalPages: State.totalPages,
                    // On sauvegarde les dimensions importantes
                    dims: {
                        w: State.canvas.pageW,
                        h: State.canvas.pageH,
                        offX: State.canvas.pageOffset.x,
                        offY: State.canvas.pageOffset.y
                    }
                };

                // 3. On écrit (avec une protection en cas de dépassement de quota)
                try {
                    const json = JSON.stringify(data);
                    localStorage.setItem('prof_toolbox_autosave', json);
                    console.log("Auto-save OK :", new Date().toLocaleTimeString());
                } catch (e) {
                    console.warn("Auto-save échoué (quota ou erreur)", e);
                }
            },
            hideCtx: () => { document.getElementById('context-menu').classList.add('hidden'); },
            // --- GESTION DE L'AIDE ---
            toggleHelp: () => {
                const el = document.getElementById('help-overlay');
                const box = document.getElementById('help-box');
                if (el.classList.contains('hidden')) {
                    el.classList.remove('hidden');
                    // Petite animation d'entrée
                    setTimeout(() => box.classList.remove('scale-95'), 10);
                } else {
                    box.classList.add('scale-95');
                    setTimeout(() => el.classList.add('hidden'), 200);
                }
            },

            setHelpTab: (tabName) => {
                // Reset Tabs
                document.querySelectorAll('.help-tab').forEach(t => t.classList.remove('active-tab'));
                document.getElementById('ht-' + tabName).classList.add('active-tab');

                // Reset Content
                document.querySelectorAll('.help-content').forEach(c => c.classList.add('hidden'));
                document.getElementById('hc-' + tabName).classList.remove('hidden');
            },
            updatePageIndicator: () => {
                const el = document.getElementById('page-indicator');
                const nav = document.getElementById('page-nav');
                if (State.totalPages > 1) nav.classList.remove('hidden'); else nav.classList.add('hidden');
                el.innerText = `Page ${State.currentPage + 1} / ${State.totalPages}`;
            },

            saveCurrentPage: () => {
                // On sauvegarde l'état actuel du canvas dans le tableau à l'index courant
                // On utilise toObject avec tes customProps
                const json = State.canvas.toObject(customProps);
                State.pages[State.currentPage] = json;
            },

            loadPage: (index) => {
                State.canvas.clear();
                const json = State.pages[index];

                if (json) {
                    // Si la page contient des données, on les charge
                    State.canvas.loadFromJSON(json, () => {
                        State.canvas.renderAll();
                        App.restoreRefs(); // Important pour reconnecter bgObj/txtObj

                        // On s'assure que le fond est bien non-sélectionnable
                        const bg = State.canvas.getObjects().find(o => o.isBackground);
                        if (bg) {
                            bg.set({ selectable: false, evented: false, lockMovementX: true, lockMovementY: true });
                            State.canvas.sendToBack(bg);
                        }

                        Navigator.refresh(); // Mise à jour de la liste des calques
                    });
                } else {
                    // Si la page est vide (cas rare mais possible), on charge un fond blanc
                    App.loadBlank();
                }
                State.currentPage = index;
                App.updatePageIndicator();
            },

            changePage: (delta) => {
                const newIndex = State.currentPage + delta;
                // Vérification des limites (pas moins de 0, pas plus que le total)
                if (newIndex >= 0 && newIndex < State.totalPages) {
                    App.saveCurrentPage(); // Sauvegarder AVANT de partir
                    App.loadPage(newIndex); // Charger la nouvelle
                }
            },
            // --- OUTIL DE CALIBRAGE ---
            addCalibrationMarks: () => {
                // On récupère les dimensions de la page A4 (595 x 842)
                const w = State.canvas.pageW;
                const h = State.canvas.pageH;
                // On récupère le décalage de la feuille par rapport au canvas
                const offX = State.canvas.pageOffset.x;
                const offY = State.canvas.pageOffset.y;

                // Création de 4 carrés rouges de 20x20px
                const makeRect = (l, t, name) => {
                    const r = new fabric.Rect({
                        left: l + offX, // On ajoute offX pour se caler sur la feuille
                        top: t + offY,  // On ajoute offY pour se caler sur la feuille
                        width: 20,
                        height: 20,
                        fill: 'red',
                        stroke: 'black',
                        strokeWidth: 1,
                        opacity: 0.5
                    });
                    // Petit texte pour identifier le coin
                    const txt = new fabric.Text(name, {
                        left: l + offX + 2, top: t + offY + 5, fontSize: 8, fill: 'white'
                    });
                    return new fabric.Group([r, txt], { ctype: 'draw', pid: 'calib_' + name });
                };

                // 1. Coin Haut-Gauche (doit être à 0,0)
                State.canvas.add(makeRect(0, 0, "TL"));

                // 2. Coin Bas-Droite (doit être tout en bas à droite)
                // On retire 20px (taille du carré) pour qu'il soit DANS la feuille
                State.canvas.add(makeRect(w - 20, h - 20, "BR"));

                State.canvas.requestRenderAll();
                // Lance l'export tout de suite pour voir
                setTimeout(() => Exporter.download(), 500);
            },
            copyStyle: (source) => {
                if (!source) return;
                const s = source;

                // 1. Sauvegarde du style (code identique)
                State.clipboardStyle = {
                    fill: s.fill,
                    stroke: s.stroke,
                    strokeWidth: s.strokeWidth,
                    opacity: s.opacity,
                    fontFamily: (s.txtObj || s).fontFamily,
                    fontSize: (s.txtObj || s).fontSize,
                    bStyle: s.bStyle || 'solid',
                    textAlign: s.tAlign || 'left'
                };

                // 2. Mise à jour visuelle Toolbar (Header)
                document.getElementById('g-fill').value = App.toHex(State.clipboardStyle.fill);
                document.getElementById('preview-fill').style.backgroundColor = State.clipboardStyle.fill;
                document.getElementById('g-stroke').value = App.toHex(State.clipboardStyle.stroke);
                document.getElementById('preview-stroke').style.backgroundColor = State.clipboardStyle.stroke;
                document.getElementById('g-width').value = State.clipboardStyle.strokeWidth;

                // 3. NOUVEAU : On active visuellement le bouton Pinceau
                const btnPainter = document.getElementById('btn-painter');
                btnPainter.classList.remove('opacity-40');
                btnPainter.classList.add('text-blue-600'); // Optionnel : mettre en couleur pour attirer l'oeil

                // 4. UX Fluide : On passe automatiquement en mode Pinceau après la capture
                App.setTool('painter');

                // Petit feedback discret (Toast) au lieu d'une grosse modale bloquante
                // (Tu peux garder App.showModal si tu préfères, mais c'est moins fluide)
                console.log("Style copié !");
            },
            pasteStyle: (target) => {
                if (!target || !State.clipboardStyle) return;
                const st = State.clipboardStyle;

                // On applique au conteneur (rect/circle...)
                const bg = target.bgObj || target;
                bg.set({
                    fill: st.fill,
                    stroke: st.stroke,
                    strokeWidth: st.strokeWidth,
                    opacity: st.opacity
                });

                // Gestion des bordures spéciales (pointillés)
                target.bStyle = st.bStyle;
                if (st.bStyle === 'none') bg.set({ strokeDashArray: [4, 4], stroke: '#cccccc' });
                else if (st.bStyle === 'underline') bg.set({ strokeDashArray: [10, 5] });
                else bg.set({ strokeDashArray: null });

                // On applique au texte si applicable
                const txt = target.txtObj || (target.type === 'i-text' ? target : null);
                if (txt) {
                    if (st.fontFamily) txt.set('fontFamily', st.fontFamily);
                    if (st.fontSize) txt.set('fontSize', st.fontSize);
                    if (target.ctype === 'label') target.set('fill', st.stroke); // Le label prend la couleur du trait
                }

                // Alignement
                if (st.textAlign) {
                    target.tAlign = st.textAlign;
                    if (txt) txt.set('textAlign', st.textAlign);
                }

                State.canvas.requestRenderAll();
                History.save();
                // Optionnel : On peut rester en mode pinceau pour coller sur plusieurs objets, 
                // ou revenir en mode select. Ici je propose de rester en pinceau.
            },
            // --- DÉBUT BLOC SMART GUIDES ---
            drawSmartGuide: (ctx, x1, y1, x2, y2) => {
                ctx.save();
                ctx.strokeStyle = "#ff0055"; // Rouge 'Pro'
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]); // Pointillés
                ctx.beginPath();
                ctx.moveTo(x1 + 0.5, y1 + 0.5); // +0.5 pour des lignes nettes (anti-aliasing)
                ctx.lineTo(x2 + 0.5, y2 + 0.5);
                ctx.stroke();
                ctx.restore();
            },

            smartGuides: (target) => {
                const canvas = State.canvas;
                const threshold = 4 / canvas.getZoom();

                // 1. On vide la liste au début (pour effacer les guides précédents)
                State.snapLines = [];

                if (!State.snap) return { x: 0, y: 0 };

                const tBR = target.getBoundingRect(true, true);
                const tPoints = {
                    h: [tBR.top, tBR.top + tBR.height / 2, tBR.top + tBR.height],
                    v: [tBR.left, tBR.left + tBR.width / 2, tBR.left + tBR.width]
                };

                const candidates = canvas.getObjects().filter(o => {
                    return o !== target && o.visible && !o.isGuide && !o.isBackground &&
                        !(target.type === 'activeSelection' && target.contains(o));
                });

                let dx = 0, dy = 0;
                let snappedH = false, snappedV = false;

                for (let cand of candidates) {
                    if (snappedH && snappedV) break;

                    const cBR = cand.getBoundingRect(true, true);
                    const cPoints = {
                        h: [cBR.top, cBR.top + cBR.height / 2, cBR.top + cBR.height],
                        v: [cBR.left, cBR.left + cBR.width / 2, cBR.left + cBR.width]
                    };

                    // Alignement Horizontal
                    if (!snappedH) {
                        for (let tp of tPoints.h) {
                            for (let cp of cPoints.h) {
                                if (Math.abs(tp - cp) < threshold) {
                                    dy = cp - tp;
                                    State.snapLines.push({ vertical: false, y: cp });
                                    snappedH = true; break;
                                }
                            }
                            if (snappedH) break;
                        }
                    }

                    // Alignement Vertical
                    if (!snappedV) {
                        for (let tp of tPoints.v) {
                            for (let cp of cPoints.v) {
                                if (Math.abs(tp - cp) < threshold) {
                                    dx = cp - tp;
                                    State.snapLines.push({ vertical: true, x: cp });
                                    snappedV = true; break;
                                }
                            }
                            if (snappedV) break;
                        }
                    }
                }

                // --- CORRECTION EST ICI ---
                // On demande TOUJOURS le redessin à la fin de la fonction.
                // Si State.snapLines est vide, after:render ne dessinera rien 
                // et le rafraîchissement effacera les anciennes lignes rouges.
                canvas.requestRenderAll();

                return { x: dx, y: dy };
            },
            // --- FIN BLOC SMART GUIDES ---
            toggleSequenceMode: () => {
                State.isSequencing = !State.isSequencing;
                const btn = document.getElementById('btn-seq');

                if (State.isSequencing) {
                    // ACTIVATION
                    State.mode = 'sequence'; // Bloque les autres outils
                    State.sequenceList = []; // On reset la liste temporaire
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                    State.canvas.defaultCursor = 'crosshair'; // Curseur cible

                    btn.innerHTML = '<i class="fa-solid fa-check"></i> Terminer';
                    btn.classList.add('font-bold', 'bg-orange-100', 'px-2', 'rounded');
                    App.showModal("Mode Séquence", "Cliquez sur les champs un par un dans l'ordre souhaité (1, 2, 3...).\nLes champs déjà cliqués deviendront verts.");
                } else {
                    // DÉSACTIVATION & APPLICATION
                    State.mode = 'select';
                    State.canvas.defaultCursor = 'default';

                    btn.innerHTML = '<i class="fa-solid fa-arrow-down-1-9"></i> Séquence';
                    btn.classList.remove('font-bold', 'bg-orange-100', 'px-2', 'rounded');

                    // On réorganise vraiment les objets maintenant
                    if (State.sequenceList.length > 0) {
                        // 1. On sépare les objets non concernés (Background, images déco...)
                        const allObjs = State.canvas.getObjects();
                        const background = allObjs.filter(o => o.isBackground);
                        const others = allObjs.filter(o => !State.sequenceList.includes(o) && !o.isBackground);

                        // 2. On vide le canvas (sans effacer le contexte, juste la liste)
                        State.canvas.remove(...allObjs);

                        // 3. On remet tout dans le bon ordre : 
                        // Fond -> Objets non triés -> Objets triés (1, 2, 3...)
                        background.forEach(o => State.canvas.add(o));
                        others.forEach(o => State.canvas.add(o));
                        State.sequenceList.forEach(o => State.canvas.add(o));

                        State.canvas.requestRenderAll();
                        History.save();
                        Navigator.refresh();
                    }
                }
            },
            stringToColor: (str) => {
                let hash = 0; for (let i = 0; i < str.length; i++) { hash = str.charCodeAt(i) + ((hash << 5) - hash); }
                const c = (hash & 0x00FFFFFF).toString(16).toUpperCase(); return '#' + "00000".substring(0, 6 - c.length) + c;
            },
            init: () => {
                // 0. (NOUVEAU) MODE SILENCIEUX PDF.JS
                // On dit à PDF.js de ne signaler que les erreurs critiques, pas les warnings de polices.
                if (window.pdfjsLib) {
                    window.pdfjsLib.GlobalWorkerOptions.verbosity = window.pdfjsLib.VerbosityLevel.ERRORS;
                }

                // 1. Initialisation du Canvas
                State.canvas = new fabric.Canvas('c', {
                    preserveObjectStacking: true,
                    fireRightClick: true,
                    stopContextMenu: true,
                    backgroundColor: null
                });

                // 2. Gestion du redimensionnement & SCROLL (CORRECTIF BUG SÉLECTION)
                App.resize();
                window.addEventListener('resize', () => {
                    App.resize();
                    State.canvas.calcOffset(); // Recalcule la position après resize
                });

                // --> C'EST ICI LA MAGIE POUR LE CLIC QUI RATE <--
                window.addEventListener('scroll', () => {
                    if (State.canvas) State.canvas.calcOffset();
                }, { passive: true });

                // 3. Gestion du Clic Droit (Menu Contextuel)
                State.canvas.upperCanvasEl.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    const target = State.canvas.findTarget(e);
                    if (target && !target.isBackground) {
                        State.canvas.setActiveObject(target);
                        const menu = document.getElementById('context-menu');
                        menu.style.left = e.clientX + 'px';
                        menu.style.top = e.clientY + 'px';
                        menu.classList.remove('hidden');
                    }
                });

                // Cache le menu quand on clique ailleurs
                document.addEventListener('click', () => App.hideCtx());

                // 4. Chargement de la page blanche par défaut
                App.loadBlank();

                // 5. Écouteurs d'événements Fabric
                State.canvas.on('object:modified', History.save);
                // GESTION DU REDIMENSIONNEMENT (Panel + Anti-Distortion)
                State.canvas.on('object:scaling', function (e) {
                    const target = e.target;

                    // 1. On met à jour les chiffres dans le panneau en temps réel
                    Panel.update(target);

                    // 2. MAGIE : On empêche les radios/checkbox d'être écrasés dans un groupe
                    if (target.type === 'activeSelection' || target.type === 'group') {

                        const groupScaleX = target.scaleX;
                        const groupScaleY = target.scaleY;

                        target.getObjects().forEach(obj => {
                            // Si c'est un objet qui doit rester géométrique (Rond ou Carré)
                            if (['checkbox', 'radio'].includes(obj.ctype)) {

                                // On calcule l'échelle Y nécessaire pour compenser l'étirement du groupe
                                // Cela force l'objet à garder son aspect ratio 1:1 visuel
                                const newScaleY = (obj.scaleX * groupScaleX) / groupScaleY;

                                obj.set('scaleY', newScaleY);
                            }
                        });
                    }
                });
                State.canvas.on('mouse:down', function (opt) {
                    const evt = opt.e;
                    if (State.mode === 'hand' || evt.altKey || evt.code === 'Space') {
                        this.isDragging = true;
                        this.selection = false;
                        this.lastPosX = evt.clientX;
                        this.lastPosY = evt.clientY;
                        this.setCursor('grabbing');
                    }
                });

                State.canvas.on('mouse:move', function (opt) {
                    if (this.isDragging) {
                        const e = opt.e;
                        const delta = {
                            x: e.clientX - this.lastPosX,
                            y: e.clientY - this.lastPosY
                        };
                        this.relativePan(delta);
                        this.lastPosX = e.clientX;
                        this.lastPosY = e.clientY;
                        // Optionnel mais fluide : force le rendu pendant le drag
                        this.requestRenderAll();
                    }
                });

                State.canvas.on('mouse:up', function (opt) {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.selection = true;
                        this.setCursor(State.mode === 'hand' ? 'grab' : 'default');


                    }
                    State.snapLines = [];
                    State.canvas.requestRenderAll();
                    // ← LA CORRECTION CLÉ : Nettoie les résidus de smart guides
                    this.clearContext(this.contextTop);
                    this.requestRenderAll();
                });
                // Rendu visuel (Lignes Radio + Numéros Séquence + Coordonnées corrigées)
                // Rendu visuel (Lignes Radio + Numéros Séquence + Guides Magnétiques)
                State.canvas.on('after:render', ctx => {
                    if (State.isPreview) return;

                    const ctx2 = State.canvas.getContext();
                    const vpt = State.canvas.viewportTransform;
                    const pixelRatio = State.canvas.getRetinaScaling();

                    const getCoords = (o) => {
                        if (!o) return { x: 0, y: 0 };
                        let p = o.getPointByOrigin('left', 'top');
                        if (o.group) p = fabric.util.transformPoint(p, o.group.calcTransformMatrix());
                        return { x: p.x * vpt[0] + vpt[4], y: p.y * vpt[3] + vpt[5] };
                    };

                    // --- A. LIGNES (Si activé via Header) ---
                    if (State.showFlowLines && State.sequenceList && State.sequenceList.length > 1) {
                        ctx2.save();
                        ctx2.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                        ctx2.lineWidth = 2;
                        ctx2.strokeStyle = "#3b82f6"; // Bleu
                        ctx2.setLineDash([5, 5]);

                        for (let i = 0; i < State.sequenceList.length - 1; i++) {
                            const cur = State.sequenceList[i];
                            const next = State.sequenceList[i + 1];

                            // Si un objet a été supprimé ou n'est plus sur le canvas, on ignore
                            if (!cur || !next || !State.canvas.contains(cur) || !State.canvas.contains(next)) continue;

                            const p1 = getCoords(cur);
                            const p2 = getCoords(next);

                            ctx2.beginPath();
                            ctx2.moveTo(p1.x, p1.y);
                            ctx2.lineTo(p2.x, p2.y);
                            ctx2.stroke();
                        }
                        ctx2.restore();
                    }

                    // --- B. PASTILLES ---
                    const inputs = State.canvas.getObjects().filter(o => ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(o.ctype));

                    inputs.forEach((o, i) => {
                        const pos = getCoords(o);
                        const seqIndex = State.sequenceList ? State.sequenceList.indexOf(o) : -1;

                        let badgeColor = "#2563eb";
                        let text = i + 1; // Par défaut : ordre de création (calque)

                        // 1. Si on est en mode "Édition Séquence" (1-9)
                        if (State.isSequencing) {
                            if (seqIndex !== -1) {
                                badgeColor = "#16a34a"; // Vert
                                text = seqIndex + 1;
                            } else {
                                badgeColor = "#9ca3af"; // Gris
                                text = "?";
                            }
                        }
                        // 2. Si on est en mode "Vue Flux" (Route)
                        else if (State.showFlowLines) {
                            // On affiche le numéro de la séquence pour suivre le fil
                            if (seqIndex !== -1) {
                                text = seqIndex + 1;
                            } else {
                                // Si l'objet n'est pas dans la liste (ex: ajouté après), on le signale discrètement
                                text = "+";
                                badgeColor = "#9ca3af";
                            }
                        }

                        ctx2.save();
                        ctx2.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                        ctx2.translate(pos.x, pos.y);

                        ctx2.fillStyle = badgeColor;
                        ctx2.beginPath();
                        ctx2.arc(0, 0, 9, 0, 2 * Math.PI);
                        ctx2.fill();

                        ctx2.fillStyle = "white";
                        ctx2.font = "bold 11px sans-serif";
                        ctx2.textAlign = "center";
                        ctx2.textBaseline = "middle";
                        ctx2.fillText(text, 0, 1);
                        ctx2.restore();
                    });

                    // (Tu peux laisser ici tes Guides Magnétiques rouges s'ils ne sont pas déjà dessinés ailleurs)
                });         // 6. Bindings globaux
                App.bindEvents();
                App.bindKeys();

                // 7. VÉRIFICATION AUTO-SAVE
                setTimeout(() => {
                    App.checkAutoSave();
                }, 500);
            },
            showModal: (title, msg) => {
                document.getElementById('modal-title').innerText = title;
                document.getElementById('modal-msg').innerText = msg;
                const ov = document.getElementById('modal-overlay');
                ov.classList.remove('hidden');
                ov.classList.add('modal-enter');
                setTimeout(() => ov.classList.add('modal-enter-active'), 10);
            },
            closeModal: () => {
                const ov = document.getElementById('modal-overlay');
                ov.classList.remove('modal-enter-active');
                ov.classList.add('modal-exit');
                setTimeout(() => {
                    ov.classList.add('hidden');
                    ov.classList.remove('modal-exit', 'modal-enter');
                }, 200);
            },
            resize: () => { const el = document.getElementById('workspace'); State.canvas.setWidth(el.clientWidth); State.canvas.setHeight(el.clientHeight); State.canvas.calcOffset(); },
            loadBlank: () => {
                State.canvas.clear();

                // Dimensions A4 standard
                const w = 595, h = 842;
                State.canvas.pageW = w;
                State.canvas.pageH = h;

                const cx = (State.canvas.width / 2 - w / 2), cy = 20;
                State.canvas.pageOffset = { x: cx, y: cy };

                // Création du fond blanc
                const bg = new fabric.Rect({
                    width: w, height: h,
                    fill: 'white',
                    shadow: { color: 'rgba(0,0,0,0.1)', blur: 10 },
                    selectable: false, evented: false, hasControls: false,
                    lockMovementX: true, lockMovementY: true,
                    isBackground: true,
                    left: cx, top: cy
                });

                State.canvas.add(bg);
                State.canvas.sendToBack(bg);

                // --- NOUVEAU : INITIALISATION MULTI-PAGES ---
                State.pages = []; // On vide tout
                State.totalPages = 1;
                State.currentPage = 0;

                // On sauvegarde immédiatement cette page blanche comme "Page 1"
                const json = State.canvas.toObject(customProps);
                State.pages[0] = json;

                App.updatePageIndicator();
                State.canvas.requestRenderAll();
            },
            restoreRefs: () => {
                State.canvas.getObjects().forEach(o => {
                    if (o.isBackground) { o.set({ selectable: false, evented: false, hasControls: false, lockMovementX: true, lockMovementY: true }); State.canvas.sendToBack(o); }
                    if (o.type === 'group' && o._objects.length >= 2) {
                        o.bgObj = o._objects[0];
                        if (['textfield', 'textarea'].includes(o.ctype)) o.txtObj = o._objects[1];
                        if (['checkbox', 'radio'].includes(o.ctype)) o.markObj = o._objects[1];
                    }
                });
            },
            setSideTab: (tab) => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-btn-' + tab).classList.add('active');
                document.getElementById('view-props').classList.add('hidden');
                document.getElementById('view-bank').classList.add('hidden');
                document.getElementById('view-' + tab).classList.remove('hidden');
                if (tab === 'props') Panel.update(State.canvas.getActiveObject());
            },
            togglePreview: () => {
                State.isPreview = !State.isPreview;
                const btn = document.getElementById('btn-preview');
                const tb = document.getElementById('toolbar-main');
                const side = document.getElementById('sidebar-tools');
                const props = document.getElementById('panel-right');

                if (State.isPreview) {
                    btn.classList.add('bg-blue-100', 'text-blue-600');
                    tb.style.opacity = '0'; tb.style.pointerEvents = 'none';
                    side.style.transform = 'translateX(-100%)';
                    props.style.transform = 'translateX(100%)';
                    State.canvas.discardActiveObject();
                    State.canvas.getObjects().forEach(o => o.selectable = false);
                } else {
                    btn.classList.remove('bg-blue-100', 'text-blue-600');
                    tb.style.opacity = '1'; tb.style.pointerEvents = 'all';
                    side.style.transform = 'translateX(0)';
                    props.style.transform = 'translateX(0)';
                    State.canvas.getObjects().forEach(o => { if (!o.isBackground) o.selectable = true; });
                }
                State.canvas.requestRenderAll();
            },
            syncSequenceFromDOM: function () {
                // 1. On récupère tous les éléments de la liste dans leur NOUVEL ORDRE visuel
                // (Adaptez '.layer-item' sélecteur CSS de vos éléments de liste)
                const listItems = document.querySelectorAll('#layer-list .layer-item');

                const newOrder = [];

                listItems.forEach(item => {
                    // On récupère l'ID stocké dans le HTML
                    const targetId = item.getAttribute('data-id');

                    // On cherche l'objet correspondant dans le Canvas
                    // Note: Assurez-vous que vos objets Fabric ont bien une propriété .id ou .name unique
                    const obj = State.canvas.getObjects().find(o => o.id === targetId);

                    if (obj) {
                        newOrder.push(obj);
                    }
                });

                // 2. On met à jour la liste officielle de séquence
                State.sequenceList = newOrder;

                // 3. On redessine le canvas pour mettre à jour les numéros et les flèches
                State.canvas.requestRenderAll();
            },
            // AJOUTER DANS L'OBJET App = { ... }

            toggleFlowLines: function () {
                State.showFlowLines = !State.showFlowLines;

                // 1. Initialisation automatique si la liste est vide
                if (State.showFlowLines && (!State.sequenceList || State.sequenceList.length === 0)) {
                    // On prend tous les champs valides et on les trie par leur position Z (Ordre des calques)
                    // car c'est l'ordre par défaut de Tabulation dans un PDF.
                    const inputs = State.canvas.getObjects().filter(o => ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(o.ctype));
                    State.sequenceList = inputs;
                }

                // 2. Gestion visuelle du bouton
                const btn = document.getElementById('btn-flow-toggle');
                if (btn) {
                    if (State.showFlowLines) {
                        btn.classList.remove('bg-white', 'text-gray-500', 'border-gray-200');
                        btn.classList.add('bg-blue-50', 'text-blue-600', 'border-blue-400', 'ring-1', 'ring-blue-200');
                    } else {
                        btn.classList.add('bg-white', 'text-gray-500', 'border-gray-200');
                        btn.classList.remove('bg-blue-50', 'text-blue-600', 'border-blue-400', 'ring-1', 'ring-blue-200');
                    }
                }
                State.canvas.requestRenderAll();
            },

            syncSequenceFromLayers: function () {
                // Cette fonction synchronise la liste de séquence avec l'ordre visuel des calques (Navigator)
                const allObjs = State.canvas.getObjects();

                // On ne garde que les champs de formulaire
                const inputs = allObjs.filter(o => ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(o.ctype));

                // On met à jour la liste officielle. 
                // Comme canvas.getObjects() retourne les objets du bas vers le haut (0 = fond, N = premier plan),
                // et que l'ordre de tabulation suit souvent cet ordre (ou l'inverse), on aligne les deux.
                State.sequenceList = inputs;

                // On peut aussi trier par position visuelle (Haut -> Bas) si tu préfères :
                // App.autoSort(); 
            },


            autoSort: () => {
                const objs = State.canvas.getObjects();
                const formItems = objs.filter(o => o.ctype && !o.isBackground && !o.isGuide);
                const others = objs.filter(o => !formItems.includes(o) && !o.isBackground);
                formItems.sort((a, b) => {
                    const ay = Math.round(a.top / 10), by = Math.round(b.top / 10);
                    if (ay !== by) return ay - by;
                    return a.left - b.left;
                });
                State.canvas.remove(...objs);
                const bg = objs.find(o => o.isBackground);
                if (bg) State.canvas.add(bg);
                others.forEach(o => State.canvas.add(o));
                formItems.forEach(o => State.canvas.add(o));
                State.canvas.requestRenderAll();
                History.save();
                App.showModal("Tri Automatique", "L'ordre de tabulation a été réorganisé de haut en bas.");
            },
            align: (mode) => {
                const selection = State.canvas.getActiveObjects();
                if (selection.length < 2) return;

                State.canvas.discardActiveObject();

                const minX = Math.min(...selection.map(o => o.left));
                const maxX = Math.max(...selection.map(o => o.left + o.getScaledWidth()));

                const minY = Math.min(...selection.map(o => o.top));
                const maxY = Math.max(...selection.map(o => o.top + o.getScaledHeight()));

                if (mode === 'left') {
                    selection.forEach(o => o.set('left', minX));
                } else if (mode === 'center') {
                    const centerX = minX + (maxX - minX) / 2;
                    selection.forEach(o => o.set('left', centerX - o.getScaledWidth() / 2));
                } else if (mode === 'right') {
                    selection.forEach(o => o.set('left', maxX - o.getScaledWidth()));
                } else if (mode === 'top') {
                    selection.forEach(o => o.set('top', minY));
                } else if (mode === 'middle') {
                    const centerY = minY + (maxY - minY) / 2;
                    selection.forEach(o => o.set('top', centerY - o.getScaledHeight() / 2));
                } else if (mode === 'bottom') {
                    selection.forEach(o => o.set('top', maxY - o.getScaledHeight()));
                } else if (mode === 'dist-v') {
                    selection.sort((a, b) => a.top - b.top);
                    const first = selection[0]; const last = selection[selection.length - 1];
                    const totalH = last.top - first.top;
                    const gap = totalH / (selection.length - 1);
                    selection.forEach((o, i) => { if (i > 0 && i < selection.length - 1) o.set('top', first.top + (gap * i)); });
                } else if (mode === 'dist-h') {
                    selection.sort((a, b) => a.left - b.left);
                    const first = selection[0]; const last = selection[selection.length - 1];
                    const distance = (last.left - first.left) / (selection.length - 1);
                    selection.forEach((o, i) => { if (i > 0 && i < selection.length - 1) o.set('left', first.left + (distance * i)); });
                }

                const sel = new fabric.ActiveSelection(selection, { canvas: State.canvas });
                State.canvas.setActiveObject(sel);
                State.canvas.requestRenderAll();
                History.save();
            },
            applyBatchGroup: () => {
                const name = document.getElementById('batch-grp-name').value;
                if (!name) return;
                const active = State.canvas.getActiveObject();
                if (active && active.type === 'activeSelection') {
                    active.forEachObject(o => {
                        if (o.ctype === 'radio') {
                            o.set('grp', name);
                        }
                    });
                    State.canvas.requestRenderAll();
                    History.save();
                    App.showModal("Groupe Radio", "Le groupe '" + name + "' a été appliqué avec succès.");
                }
            },
            copy: () => {
                const active = State.canvas.getActiveObject();
                if (!active || active.isBackground) return;
                active.clone(cloned => { State.clipboard = cloned; }, customProps);
            },
            paste: () => {
                if (!State.clipboard) return;
                State.clipboard.clone(cloned => {
                    State.canvas.discardActiveObject();
                    cloned.set({ left: cloned.left + 10, top: cloned.top + 10, evented: true });
                    const assignIds = (o) => { Factory.ensureUniqueId(o); };
                    if (cloned.type === 'activeSelection') {
                        cloned.canvas = State.canvas; cloned.forEachObject(assignIds); cloned.forEachObject(o => State.canvas.add(o)); cloned.setCoords();
                    } else {
                        assignIds(cloned); State.canvas.add(cloned);
                    }
                    State.canvas.setActiveObject(cloned); State.canvas.requestRenderAll(); App.restoreRefs(); History.save();
                }, customProps);
            },
            duplicate: () => { App.copy(); App.paste(); },
            setTool: (t) => {
                // 0. LOGIQUE TOGGLE (INTERRUPTEUR)
                // Si je clique sur le 'size-painter' alors qu'il est déjà actif, 
                // je décide basculer vers 'select' (ce qui va éteindre le pinceau)
                if (t === 'size-painter' && State.mode === 'size-painter') {
                    t = 'select';
                }

                // 1. RESET VISUEL (On éteint toujours le bouton avant d'aller plus loin)
                // Cela garantit qu'il s'éteindra si on repasse en 'select'
                const sizeBtn = document.getElementById('btn-size-painter');
                if (sizeBtn) {
                    sizeBtn.classList.remove('bg-black', 'text-white');
                    sizeBtn.classList.add('bg-gray-100', 'text-gray-500');
                }

                // 2. GESTION DES OUTILS DE GAUCHE
                if (t === 'select') {
                    State.mode = 'select';
                    _uiActiveTool(t); // Active l'icône flèche à gauche
                    State.canvas.defaultCursor = 'default';
                    State.canvas.selection = true;
                }
                else if (t === 'hand') {
                    State.mode = 'hand';
                    _uiActiveTool(t);
                    State.canvas.defaultCursor = 'grab';
                    State.canvas.selection = false;
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                }
                else if (t === 'picker') {
                    State.mode = 'picker';
                    _uiActiveTool(t);
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                    State.canvas.defaultCursor = 'crosshair';
                }
                else if (t === 'painter') {
                    State.mode = 'painter';
                    _uiActiveTool(t);
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                    State.canvas.defaultCursor = 'copy';
                }

                // 3. GESTION DU PINCEAU DE TAILLE (HAUT)
                else if (t === 'size-painter') {
                    State.mode = 'size-painter';

                    // On désactive tout à gauche
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));

                    // On active visuellement le bouton du haut (Noir)
                    if (sizeBtn) {
                        sizeBtn.classList.remove('bg-gray-100', 'text-gray-500');
                        sizeBtn.classList.add('bg-black', 'text-white');
                    }

                    State.canvas.defaultCursor = 'cell';
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                }

                // 4. AUTRES OUTILS (Formes, etc.)
                else {
                    State.mode = t;
                    _uiActiveTool(t);
                    State.canvas.defaultCursor = 'crosshair';
                    State.canvas.selection = false;
                    State.canvas.discardActiveObject();
                    State.canvas.requestRenderAll();
                }
            }, setStyle: (key, val) => {
                if (key === 'size' || key === 'width') val = parseInt(val); if (key === 'lock') State.defaults.lock = val; else State.defaults[key] = val;
                if (key === 'fill') document.getElementById('preview-fill').style.backgroundColor = val;
                if (key === 'stroke') document.getElementById('preview-stroke').style.backgroundColor = val;

                const objs = State.canvas.getActiveObjects();
                objs.forEach(obj => {
                    const target = obj.bgObj || obj; const txt = obj.txtObj || (obj.type === 'i-text' ? obj : null);
                    if (key === 'fill') target.set('fill', val);
                    if (key === 'stroke') { target.set('stroke', val); if (obj.ctype === 'label') obj.set('fill', val); }
                    if (key === 'width') target.set('strokeWidth', val);
                    if (key === 'font' && txt) txt.set('fontFamily', val);
                    if (key === 'size' && txt) txt.set('fontSize', val);
                    if (key === 'lock') {
                        if (obj.ctype === 'textfield') { obj.set('lockScalingY', val); if (val) obj.setControlsVisibility({ mt: false, mb: false }); else obj.setControlsVisibility({ mt: true, mb: true }); }
                        if (['checkbox', 'radio'].includes(obj.ctype)) {
                            obj.set({ lockScalingX: val, lockScalingY: val });
                            if (val) {
                                obj.setControlsVisibility({ tl: false, tr: false, bl: false, br: false, mtr: false, mt: false, mb: false, ml: false, mr: false });
                            } else {
                                obj.setControlsVisibility({ tl: true, tr: true, bl: true, br: true, mtr: false, mt: false, mb: false, ml: false, mr: false });
                            }
                        }
                    }
                });
                if (objs.length) { State.canvas.requestRenderAll(); History.save(); Panel.update(objs[0]); }
            },
            deleteSelection: () => {
                const a = State.canvas.getActiveObjects().filter(o => !o.isBackground);
                if (a.length) { State.canvas.discardActiveObject(); State.canvas.remove(...a); Panel.update(null); History.save(); }
            },
            getSnapLines: (target) => {
                const zoom = State.canvas.getZoom();
                const snapDist = 10 / zoom;
                let vertical = [], horizontal = [];

                const tRect = target.getBoundingRect ? target.getBoundingRect(true, true) : { left: target.left, top: target.top, width: 0, height: 0 };
                const tCenter = { x: tRect.left + tRect.width / 2, y: tRect.top + tRect.height / 2 };

                State.canvas.getObjects().forEach(o => {
                    if (o === target || !o.visible || o.isGuide || o.isBackground || (target.type === 'activeSelection' && target.contains(o))) return;

                    const oRect = o.getBoundingRect(true, true);
                    const oCenter = { x: oRect.left + oRect.width / 2, y: oRect.top + oRect.height / 2 };

                    [oRect.left, oRect.left + oRect.width, oCenter.x].forEach(val => vertical.push(val));
                    [oRect.top, oRect.top + oRect.height, oCenter.y].forEach(val => horizontal.push(val));
                });
                return { vertical, horizontal, tRect, tCenter, snapDist };
            },
            snapMove: (target) => {
                if (!State.snap) return { x: 0, y: 0 };

                const { vertical, horizontal, tRect, tCenter, snapDist } = App.getSnapLines(target);
                let dx = 0, dy = 0; App.clearGuides();

                for (let v of vertical) {
                    if (Math.abs(tRect.left - v) < snapDist) { dx = v - tRect.left; App.drawGuide('v', v); break; }
                    if (Math.abs((tRect.left + tRect.width) - v) < snapDist) { dx = v - (tRect.left + tRect.width); App.drawGuide('v', v); break; }
                    if (Math.abs(tCenter.x - v) < snapDist) { dx = v - tCenter.x; App.drawGuide('v', v); break; }
                }

                for (let h of horizontal) {
                    if (Math.abs(tRect.top - h) < snapDist) { dy = h - tRect.top; App.drawGuide('h', h); break; }
                    if (Math.abs((tRect.top + tRect.height) - h) < snapDist) { dy = h - (tRect.top + tRect.height); App.drawGuide('h', h); break; }
                    if (Math.abs(tCenter.y - h) < snapDist) { dy = h - tCenter.y; App.drawGuide('h', h); break; }
                }

                return { x: dx, y: dy };
            },
            snapScale: (target, corner) => {
                if (!State.snap) return;
                const { vertical, horizontal, tRect, snapDist } = App.getSnapLines(target);
                App.clearGuides();
                if (corner.includes('r')) {
                    const match = vertical.find(v => Math.abs((tRect.left + tRect.width) - v) < snapDist);
                    if (match) { App.drawGuide('v', match); target.set('scaleX', (match - target.left) / target.width); }
                }
                if (corner.includes('b')) {
                    const match = horizontal.find(h => Math.abs((tRect.top + tRect.height) - h) < snapDist);
                    if (match) { App.drawGuide('h', match); target.set('scaleY', (match - target.top) / target.height); }
                }
            },
            drawGuide: (type, pos) => {
                const coords = type === 'v' ? [pos, -10000, pos, 10000] : [-10000, pos, 10000, pos];
                const exist = State.canvas.getObjects().find(o => o.isGuide && o.guideType === type && (type === 'v' ? Math.abs(o.x1 - pos) < 1 : Math.abs(o.y1 - pos) < 1));
                if (exist) return;
                const line = new fabric.Line(coords, { stroke: '#ff0055', strokeWidth: 1 / State.canvas.getZoom(), strokeDashArray: [4, 4], selectable: false, evented: false, excludeFromExport: true, opacity: 0.8 });
                line.isGuide = true; line.guideType = type; State.canvas.add(line);
            },
            clearGuides: () => { const guides = State.canvas.getObjects().filter(o => o.isGuide); if (guides.length) State.canvas.remove(...guides); },

            bindEvents: () => {
                let isDrawing = false, sx, sy, ghost;
                const C = State.canvas;
                let isDragging = false; let lx, ly;

                // ============================================================
                // LE GARDIEN (SÉCURITÉ & UI)
                // ============================================================
                const checkRotation = () => {
                    const target = C.getActiveObject();

                    // Si rien n'est sélectionné, on vide le panneau
                    if (!target) {
                        Panel.update(null);
                        return;
                    }

                    // 1. GESTION ROTATION (Code existant)
                    const noRotationTypes = ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown', 'label'];
                    let shouldBan = false;
                    if (target.type === 'activeSelection') shouldBan = target.getObjects().some(o => noRotationTypes.includes(o.ctype));
                    else shouldBan = noRotationTypes.includes(target.ctype);

                    target.setControlsVisibility({ mtr: !shouldBan });
                    if (shouldBan) target.lockRotation = true; else target.lockRotation = false;

                    // 2. MISE À JOUR UI (C'est la ligne qui manquait !)
                    Panel.update(target);      // <--- Met à jour le panneau de droite
                    Navigator.refresh();       // <--- Met à jour la liste des calques à gauche

                    C.requestRenderAll();
                };

                // --- EVENTS SOURIS ---
                C.on('mouse:wheel', opt => { if (opt.e.ctrlKey) return; var d = opt.e.deltaY; var z = C.getZoom() * 0.999 ** d; if (z > 20) z = 20; if (z < 0.01) z = 0.01; C.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, z); opt.e.preventDefault(); opt.e.stopPropagation(); });

                C.on('mouse:down', function (opt) {
                    // 1. SÉQUENCE
                    if (State.isSequencing) {
                        if (opt.target && ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(opt.target.ctype)) {
                            if (!State.sequenceList.includes(opt.target)) {
                                State.sequenceList.push(opt.target);
                                C.requestRenderAll();
                            }
                        }
                        return;
                    }

                    // 2. MAIN / PAN
                    var e = opt.e;
                    if (e.altKey || e.code === 'Space' || State.mode === 'hand') {
                        this.isDragging = true;
                        this.selection = false;
                        this.lastPosX = e.clientX;
                        this.lastPosY = e.clientY;
                        this.setCursor('grabbing');
                        return;
                    }

                    // 3. REGLAGE PAINTER
                    if (State.mode === 'size-painter') return;

                    if (opt.e.shiftKey || opt.e.ctrlKey || opt.e.metaKey) return;

                    // 4. DESSIN
                    if (State.mode !== 'select' && State.mode !== 'hand' && State.mode !== 'picker' && State.mode !== 'painter' && !opt.target) {
                        isDrawing = true;
                        const ptr = C.getPointer(opt.e);
                        const fakeStart = { left: ptr.x, top: ptr.y, width: 0, height: 0, getBoundingRect: function () { return this; }, set: function () { } };
                        const startSnap = App.snapMove(fakeStart);
                        sx = ptr.x + startSnap.x; sy = ptr.y + startSnap.y;

                        if (['textfield', 'textarea', 'dropdown', 'rect'].includes(State.mode)) {
                            ghost = new fabric.Rect({ left: sx, top: sy, width: 0, height: 0, fill: 'rgba(37,99,235,0.1)', stroke: '#2563eb', strokeWidth: 1, strokeDashArray: [4, 4], opacity: 1 });
                        }
                        else if (State.mode === 'circle') {
                            ghost = new fabric.Ellipse({ left: sx, top: sy, rx: 0, ry: 0, fill: 'rgba(37,99,235,0.1)', stroke: '#2563eb', strokeWidth: 1, strokeDashArray: [4, 4], opacity: 1 });
                        }
                        else if (State.mode === 'line') {
                            ghost = new fabric.Line([sx, sy, sx, sy], { stroke: '#2563eb', strokeWidth: 1, strokeDashArray: [4, 4] });
                        }

                        if (ghost) C.add(ghost);
                    }
                });

                C.on('mouse:move', function (opt) {
                    if (this.isDragging) {
                        var e = opt.e;
                        var v = this.viewportTransform;
                        v[4] += e.clientX - this.lastPosX;
                        v[5] += e.clientY - this.lastPosY;
                        this.requestRenderAll();
                        this.lastPosX = e.clientX;
                        this.lastPosY = e.clientY;
                        return;
                    }

                    const coord = document.getElementById('coord-display');
                    if (coord) coord.innerText = `x: ${Math.round(opt.pointer.x)} | y: ${Math.round(opt.pointer.y)}`;

                    if (isDrawing && ghost) {
                        const ptr = C.getPointer(opt.e);
                        let destX = ptr.x; let destY = ptr.y;
                        const mouseTarget = { left: destX, top: destY, width: 0, height: 0, getBoundingRect: function () { return this; } };
                        const snapD = App.snapMove(mouseTarget);
                        destX += snapD.x; destY += snapD.y;

                        let w = Math.abs(sx - destX); let h = Math.abs(sy - destY);
                        let l = Math.min(sx, destX); let t = Math.min(sy, destY);

                        if (State.defaults.lock) {
                            if (State.mode === 'textfield') { h = State.defaults.defHeight; t = (destY < sy) ? sy - h : sy; }
                            if (['checkbox', 'radio'].includes(State.mode)) { w = State.defaults.boxSize; h = State.defaults.boxSize; t = (destY < sy) ? sy - h : sy; l = (destX < sx) ? sx - w : sx; }
                        }

                        if (State.mode === 'line') { ghost.set({ x2: destX, y2: destY }); }
                        else if (State.mode === 'circle') { ghost.set({ rx: w / 2, ry: h / 2, left: l, top: t }); }
                        else { ghost.set({ width: w, height: h, left: l, top: t }); }
                        C.requestRenderAll();

                    } else if (!isDrawing && State.mode !== 'select' && State.mode !== 'hand' && State.mode !== 'size-painter') {
                        App.clearGuides();
                        const ptr = C.getPointer(opt.e);
                        const fakeTarget = { left: ptr.x, top: ptr.y, width: 0, height: 0, getBoundingRect: function () { return this; }, set: function () { } };
                        App.snapMove(fakeTarget);
                    } else if (State.mode === 'select') {
                        App.clearGuides();
                    }
                });

                C.on('mouse:up', function (opt) {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.selection = true;
                        this.setCursor(State.mode === 'hand' ? 'grab' : 'default');
                        return;
                    }

                    // Painter
                    if (State.mode === 'size-painter' && opt.target) {
                        const t = opt.target;
                        if (['checkbox', 'radio'].includes(t.ctype)) {
                            t.scaleToWidth(State.defaults.boxSize);
                            t.scaleToHeight(State.defaults.boxSize);
                        } else if (['textfield', 'dropdown', 'textarea'].includes(t.ctype)) {
                            t.scaleToHeight(State.defaults.defHeight);
                        }
                        t.setCoords(); C.requestRenderAll(); Panel.update(t); History.save();
                        return;
                    }

                    if (isDrawing) {
                        isDrawing = false; App.clearGuides(); const ptr = C.getPointer(opt.e);
                        let l, t, w, h;
                        if (ghost) { l = ghost.left; t = ghost.top; w = ghost.width * ghost.scaleX; h = ghost.height * ghost.scaleY; C.remove(ghost); ghost = null; }
                        else { l = sx; t = sy; w = 0; h = 0; }

                        const isClick = w < 5 && h < 5;
                        if (isClick) {
                            if (['textfield', 'dropdown'].includes(State.mode)) { w = 150; h = State.defaults.defHeight; }
                            else if (State.mode === 'textarea') { w = 250; h = State.defaults.defHeight * 3; }
                            else if (['rect', 'circle'].includes(State.mode)) { w = 100; h = 100; }
                            else if (State.mode === 'line') { w = 100; h = 0; }
                            else if (['checkbox', 'radio'].includes(State.mode)) { w = State.defaults.boxSize; h = State.defaults.boxSize; }
                        } else if (State.mode === 'textarea') h = Math.max(h, 50);

                        if (State.defaults.lock) {
                            if (State.mode === 'textfield') h = State.defaults.defHeight;
                            if (['checkbox', 'radio'].includes(State.mode)) { w = State.defaults.boxSize; h = State.defaults.boxSize; }
                        }

                        let obj = null;
                        if (['textfield', 'textarea', 'dropdown'].includes(State.mode)) obj = Factory.createInputGroup(l, t, w, h, State.mode);
                        else if (State.mode === 'checkbox') obj = Factory.createCheckbox(l, t);
                        else if (State.mode === 'radio') obj = Factory.createRadio(l, t);
                        else if (State.mode === 'label') obj = Factory.createLabel(l, t);
                        else if (['rect', 'circle', 'line'].includes(State.mode)) {
                            if (State.mode === 'line') obj = Factory.createShape(State.mode, sx, sy, ptr.x - sx, ptr.y - sy);
                            else obj = Factory.createShape(State.mode, l, t, w, h);
                        }

                        if (obj) { C.add(obj); C.setActiveObject(obj); Panel.update(obj); History.save(); }
                    }

                    if (State.mode === 'select') C.selection = true;
                    State.canvas.clearContext(State.canvas.contextTop);
                    checkRotation(); // <--- C'est lui qui va mettre à jour le panel maintenant
                });

                C.on('object:moving', e => {
                    const target = e.target;
                    const snapD = App.snapMove(target);
                    target.left += snapD.x; target.top += snapD.y;
                    const smartD = App.smartGuides(target);
                    target.left -= snapD.x; target.top -= snapD.y;
                    if (smartD.x !== 0) target.left += smartD.x; else target.left += snapD.x;
                    if (smartD.y !== 0) target.top += smartD.y; else target.top += snapD.y;
                    Panel.update(target);
                });

                C.on('object:scaling', e => { if (e.transform && e.transform.corner) App.snapScale(e.target, e.transform.corner); });
                C.on('object:modified', () => App.clearGuides());

                C.on('mouse:dblclick', o => {
                    if (!o.target) return; const t = o.target;
                    if (t.ctype === 'checkbox' || t.ctype === 'radio') {
                        t.isChecked = !t.isChecked;
                        if (t.markObj) t.markObj.set('opacity', t.isChecked ? 1 : 0);
                        C.requestRenderAll(); Panel.update(t); History.save();
                    } else if (t.ctype === 'label') {
                        t.enterEditing(); t.selectAll();
                    } else if (t.txtObj) {
                        const items = t.getObjects(); t._restoreObjectsState(); C.remove(t); items.forEach(i => C.add(i)); C.setActiveObject(items[1]); items[1].enterEditing(); items[1].selectAll();
                        items[1].on('editing:exited', () => {
                            const grp = new fabric.Group(items, { left: t.left, top: t.top, subTargetCheck: true, lockScalingY: t.lockScalingY, lockRotation: true });
                            const controls = { mtr: false };
                            if (t.lockScalingY) Object.assign(controls, { mt: false, mb: false, ml: true, mr: true });
                            grp.setControlsVisibility(controls);
                            grp.set({ ctype: t.ctype, pid: t.pid, bStyle: t.bStyle, fmt: t.fmt, tAlign: t.tAlign, isRequired: t.isRequired, isReadOnly: t.isReadOnly });
                            grp.bgObj = items[0]; grp.txtObj = items[1];
                            if (t.ctype === 'radio') { grp.grp = t.grp; grp.val = t.val; }
                            items[0].selectable = false; items[0].evented = false; items[1].selectable = false; items[1].evented = false;
                            C.remove(...items); C.add(grp); C.setActiveObject(grp); History.save();
                        });
                    }
                });

                C.on('selection:created', checkRotation);
                C.on('selection:updated', checkRotation);
                C.on('selection:cleared', () => { Panel.update(null); Navigator.refresh(); });
            }


            , bindKeys: () => {
                document.addEventListener('keydown', e => {

                    // ------------------------------------------------------------
                    // 1. SÉCURITÉ : STOP si on est en train d'écrire
                    // ------------------------------------------------------------

                    // A. Vérification des Inputs HTML (Panneau de droite, Titre...)
                    const tag = e.target.tagName.toUpperCase();
                    // On bloque si c'est un INPUT (sauf checkbox/radio) ou un TEXTAREA
                    const isHtmlInput = (tag === 'INPUT' && !['CHECKBOX', 'RADIO', 'RANGE', 'COLOR'].includes(e.target.type.toUpperCase())) || tag === 'TEXTAREA';

                    // B. Vérification de l'édition sur le Canvas (FabricJS)
                    const activeObj = State.canvas.getActiveObject();
                    const isCanvasEditing = activeObj && (activeObj.isEditing || (activeObj.type === 'i-text' && activeObj.isEditing));

                    // Si l'une des conditions est vraie, on arrête tout (la touche fera son action par défaut : écrire)
                    if (isHtmlInput || isCanvasEditing) return;


                    // ------------------------------------------------------------
                    // 2. DÉPLACEMENT AU CLAVIER (FLÈCHES)
                    // ------------------------------------------------------------
                    if (activeObj && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault(); // Empêche le scroll de la page web

                        const step = e.shiftKey ? 10 : 1; // Shift = Grand pas (10px)

                        if (e.key === 'ArrowUp') activeObj.top -= step;
                        if (e.key === 'ArrowDown') activeObj.top += step;
                        if (e.key === 'ArrowLeft') activeObj.left -= step;
                        if (e.key === 'ArrowRight') activeObj.left += step;

                        activeObj.setCoords(); // Recalcule la zone de clic
                        State.canvas.requestRenderAll();

                        // Mise à jour des valeurs X/Y dans le panneau de droite en temps réel
                        Panel.update(activeObj);

                        // Note : On ne sauvegarde pas l'historique à chaque pixel pour ne pas saturer le Undo
                        return;
                    }


                    // ------------------------------------------------------------
                    // 3. AUTRES RACCOURCIS
                    // ------------------------------------------------------------

                    // Outils
                    if (e.key.toLowerCase() === 'm') App.setTool('hand');
                    if (e.key.toLowerCase() === 'v' || e.key.toLowerCase() === 's' || e.key === 'Escape') App.setTool('select');

                    // Suppression
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        e.preventDefault();
                        App.deleteSelection();
                    }

                    // Main temporaire (Espace)
                    if (e.code === 'Space') {
                        if (State.mode !== 'hand') State.canvas.defaultCursor = 'grab';
                    }

                    // Combinaisons CTRL / CMD
                    const isCtrl = e.ctrlKey || e.metaKey;
                    if (isCtrl) {
                        if (e.key === 'z') { e.preventDefault(); History.undo(); }
                        else if (e.key === 'y') { e.preventDefault(); History.redo(); }
                        else if (e.key === 'c') { e.preventDefault(); App.copy(); }
                        else if (e.key === 'v') { e.preventDefault(); App.paste(); }
                        else if (e.key === 'd') { e.preventDefault(); App.duplicate(); }
                        else if (e.key === 's') { e.preventDefault(); Project.save(); }
                        else if (e.key === 'a') {
                            e.preventDefault();
                            // Tout sélectionner sauf le fond et les guides
                            const targets = State.canvas.getObjects().filter(o => !o.isBackground && !o.isGuide);
                            if (targets.length) {
                                const sel = new fabric.ActiveSelection(targets, { canvas: State.canvas });
                                State.canvas.setActiveObject(sel);
                                State.canvas.requestRenderAll();
                            }
                        }
                    }
                });

                // Relâchement Espace
                document.addEventListener('keyup', e => {
                    if (e.code === 'Space') {
                        // Retour au curseur de l'outil actif
                        if (State.mode === 'select') State.canvas.defaultCursor = 'default';
                        else if (State.mode === 'hand') State.canvas.defaultCursor = 'grab';
                        else State.canvas.defaultCursor = 'crosshair';

                        State.canvas.requestRenderAll();
                    }
                    // Sauvegarde intelligente : on sauve l'historique quand on relâche la flèche
                    // Cela évite d'avoir 50 étapes d'historique pour un déplacement de 50px
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        History.save();
                    }
                });
            }
        };


        function _uiActiveTool(t) { document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active')); const btn = document.getElementById('btn-' + t); if (btn) btn.classList.add('active'); }

        const Project = {
            // --- NOUVELLE FONCTION ---
            new: () => {
                if (!confirm("⚠️ Attention !\nTout travail non sauvegardé sera perdu.\nVoulez-vous vraiment créer un nouveau projet vierge ?")) return;

                // 1. Réinitialisation des variables d'état
                State.pages = [];
                State.currentPage = 0;
                State.totalPages = 1;
                State.pdfBytes = null; // On oublie le PDF importé
                State.sequenceList = [];
                State.history = { stack: [], idx: -1 }; // Reset historique

                // 2. Reset des compteurs d'ID pour repartir propre
                State.counts = { textfield: 1, textarea: 1, checkbox: 1, radio: 1, dropdown: 1, label: 1, rect: 1, circle: 1, radiogroup: 1, image: 1 };

                // 3. Reset du titre
                document.getElementById('doc-title').value = "Nouveau_Projet";

                // 4. Nettoyage du canvas et chargement page blanche
                App.loadBlank();

                // 5. Nettoyage UI
                Navigator.refresh();
                Panel.update(null);

                // Optionnel : Supprimer l'auto-save pour ne pas recharger l'ancien projet au F5
                localStorage.removeItem('prof_toolbox_autosave');
            },
            // -------------------------

            save: () => {
                App.saveCurrentPage();
                const data = {
                    version: "V46_Studio",
                    timestamp: Date.now(),
                    pages: State.pages,
                    dims: { w: State.canvas.pageW, h: State.canvas.pageH, offX: State.canvas.pageOffset.x, offY: State.canvas.pageOffset.y }
                };
                const json = JSON.stringify(data);
                const blob = new Blob([json], { type: "application/json" });
                let filename = document.getElementById('doc-title').value.trim() || "projet";
                if (filename.toLowerCase().endsWith('.pdf')) filename = filename.slice(0, -4);
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `${filename}_projet.json`;
                link.click();
            },

            load: (e) => {
                const f = e.target.files[0];
                if (!f) return;
                const r = new FileReader();
                r.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!data.pages && data.objects) { State.pages = [data]; } else { State.pages = data.pages; }
                        if (data.dims) {
                            State.canvas.pageW = data.dims.w;
                            State.canvas.pageH = data.dims.h;
                            State.canvas.pageOffset = { x: data.dims.offX, y: data.dims.offY };
                            App.resize();
                        }
                        State.totalPages = State.pages.length;
                        State.currentPage = 0;

                        // Si on charge un projet, on considère qu'on n'a plus le PDF d'origine en mémoire binaire
                        // (Sauf si on voulait stocker le PDF en base64 dans le JSON, mais ça ferait des fichiers énormes)
                        State.pdfBytes = null;

                        App.loadPage(0);
                        App.showModal("Projet chargé", `${State.totalPages} page(s) récupérée(s).`);
                    } catch (err) {
                        console.error(err);
                        App.showModal("Erreur", "Fichier projet invalide.");
                    }
                };
                r.readAsText(f);
                e.target.value = '';
            }
        };
        document.getElementById('project-input').addEventListener('change', Project.load);

        document.getElementById('img-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (f) => {
                const data = f.target.result;
                fabric.Image.fromURL(data, (img) => {
                    const maxWidth = 200;
                    if (img.width > maxWidth) img.scaleToWidth(maxWidth);
                    img.set({ left: 50, top: 50 });
                    img.set('ctype', 'image');
                    img.set('pid', Factory.getName('image'));
                    Factory.ensureUniqueId(img);
                    img.srcObj = data;
                    State.canvas.add(img);
                    State.canvas.setActiveObject(img);
                    App.setSideTab('props');
                    Panel.update(img);
                    History.save();
                });
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        });


        const Panel = {
            ratioLocked: false,
            dom: {
                empty: document.getElementById('panel-empty'),
                content: document.getElementById('panel-content'),
                secConfig: document.getElementById('sec-config'),
                secAlign: document.getElementById('sec-align'),
                batchRadio: document.getElementById('batch-radio-section'),
                rowFillCheck: document.getElementById('row-fill-check'),
                hasFill: document.getElementById('p-has-fill'),
                boxFill: document.getElementById('box-fill'),
                rowOpacity: document.getElementById('row-opacity'),
                id: document.getElementById('p-id'),
                fill: document.getElementById('p-fill'),
                stroke: document.getElementById('p-stroke'),
                width: document.getElementById('p-width'),
                bstyle: document.getElementById('p-bstyle'),
                opacity: document.getElementById('p-opacity'),
                opacityVal: document.getElementById('p-opacity-val'),
                subRadio: document.getElementById('sub-radio'),
                subCheck: document.getElementById('sub-check'),
                subDrop: document.getElementById('sub-dropdown'),
                req: document.getElementById('p-req'),   // Case "Requis"
                read: document.getElementById('p-read'), // Case "Lecture Seule"
                grp: document.getElementById('p-grp'),
                val: document.getElementById('p-val'),
                checked: document.getElementById('p-checked'),
                fmt: document.getElementById('p-fmt'),
                rowFmt: document.getElementById('row-format'),
                rowAlign: document.getElementById('row-align'),
                dimW: document.getElementById('p-dim-w'),
                dimH: document.getElementById('p-dim-h'),
                posX: document.getElementById('p-pos-x'),
                posY: document.getElementById('p-pos-y'),
                secDims: document.getElementById('sec-dims')
            },
            toggleRatio: () => {
                Panel.ratioLocked = !Panel.ratioLocked;
                const btn = document.getElementById('btn-ratio');
                if (Panel.ratioLocked) {
                    btn.innerHTML = '<i class="fa-solid fa-link"></i>';
                    btn.classList.add('text-blue-600', 'bg-blue-50');
                    btn.classList.remove('text-gray-400');
                } else {
                    btn.innerHTML = '<i class="fa-solid fa-link-slash"></i>';
                    btn.classList.remove('text-blue-600', 'bg-blue-50');
                    btn.classList.add('text-gray-400');
                }
            },
            update: (obj) => {
                Panel.dom.batchRadio.classList.add('hidden');

                if (obj && obj.type === 'activeSelection') {
                    Panel.dom.empty.style.display = 'none';
                    Panel.dom.content.style.display = 'flex';
                    Panel.dom.secConfig.style.display = 'none';
                    Panel.dom.secDims.classList.add('hidden');
                    Panel.dom.secAlign.style.display = 'flex';

                    // DETECT MULTI RADIOS
                    const allRadios = obj._objects.every(o => o.ctype === 'radio');
                    if (allRadios) {
                        Panel.dom.batchRadio.classList.remove('hidden');
                        document.getElementById('batch-grp-name').value = obj._objects[0].grp;
                    }
                    return;
                }

                Panel.dom.secAlign.style.display = 'none';

                if (!obj) { Panel.dom.empty.style.display = 'flex'; Panel.dom.content.style.display = 'none'; return; }
                Panel.dom.empty.style.display = 'none'; Panel.dom.content.style.display = 'flex';

                const isDraw = obj.ctype === 'draw' || obj.ctype === 'image';
                Panel.dom.secConfig.style.display = isDraw ? 'none' : 'flex';
                Panel.dom.rowOpacity.style.display = isDraw ? 'grid' : 'grid';
                document.getElementById('toolbar-font').style.display = isDraw ? 'none' : 'flex';

                // --- BLOC MODIFIÉ POUR AFFICHER LE BOUTON ACTIF ---
                Panel.dom.rowFillCheck.classList.add('hidden');
                if ((obj.ctype === 'draw' && obj.type !== 'line') || ['textfield', 'textarea', 'checkbox', 'radio', 'dropdown'].includes(obj.ctype)) {
                    Panel.dom.rowFillCheck.classList.remove('hidden');
                    const t = obj.bgObj || obj;
                    const isTransparent = !t.fill || t.fill === 'transparent';
                    Panel.dom.hasFill.checked = !isTransparent;
                    Panel.dom.boxFill.style.opacity = !isTransparent ? '1' : '0.3';
                }
                // --------------------------------------------------

                // --- NOUVEAU : MISE A JOUR DES CASES REQUIS / LECTURE SEULE ---
                if (Panel.dom.req) Panel.dom.req.checked = obj.isRequired || false;
                if (Panel.dom.read) Panel.dom.read.checked = obj.isReadOnly || false;
                // --------------------------------------------------------------

                const target = obj.bgObj || obj;
                Panel.dom.id.value = obj.pid || '';
                Panel.dom.fill.value = App.toHex(target.fill);
                Panel.dom.stroke.value = App.toHex(target.stroke);
                Panel.dom.width.value = target.strokeWidth || 0;
                const op = target.opacity !== undefined ? target.opacity : 1; Panel.dom.opacity.value = op; Panel.dom.opacityVal.innerText = Math.round(op * 100) + '%';
                if (obj.bStyle) Panel.dom.bstyle.value = obj.bStyle; else Panel.dom.bstyle.value = 'solid';

                Panel.dom.rowFmt.style.display = (obj.ctype === 'textfield') ? 'grid' : 'none';
                Panel.dom.rowAlign.style.display = (obj.ctype === 'textfield' || obj.ctype === 'textarea') ? 'grid' : 'none';
                if (obj.ctype === 'textfield') Panel.dom.fmt.value = obj.fmt || 'text';

                if (obj.ctype === 'textfield' || obj.ctype === 'textarea') {
                    const align = obj.tAlign || 'left';
                    ['left', 'center', 'right'].forEach(a => {
                        const btn = document.getElementById('p-align-' + a);
                        if (align === a) btn.classList.add('selected'); else btn.classList.remove('selected');
                    });
                }

                Panel.dom.subRadio.classList.add('hidden'); Panel.dom.subCheck.classList.add('hidden'); Panel.dom.subDrop.classList.add('hidden');
                if (obj.ctype === 'radio') { Panel.dom.subRadio.classList.remove('hidden'); Panel.dom.subCheck.classList.remove('hidden'); Panel.dom.grp.value = obj.grp || ''; Panel.dom.val.value = obj.val || ''; Panel.dom.checked.checked = obj.isChecked; }
                else if (obj.ctype === 'checkbox') { Panel.dom.subCheck.classList.remove('hidden'); Panel.dom.checked.checked = obj.isChecked; }
                else if (obj.ctype === 'dropdown') { Panel.dom.subDrop.classList.remove('hidden'); document.getElementById('p-opts').value = obj.opts || ''; }

                Panel.dom.secDims.classList.remove('hidden');
                Panel.dom.dimW.value = Math.round(obj.getScaledWidth());
                Panel.dom.dimH.value = Math.round(obj.getScaledHeight());

                // UPDATE POS X/Y
                Panel.dom.posX.value = Math.round(obj.left);
                Panel.dom.posY.value = Math.round(obj.top);
            },
            apply: (key, val) => {
                const objs = State.canvas.getActiveObjects();
                if (!objs.length) return;

                objs.forEach(obj => {
                    const target = obj.bgObj || obj;

                    // --- NOUVEAU : SAUVEGARDE REQUIS / LECTURE SEULE ---
                    if (key === 'req') obj.isRequired = val;
                    if (key === 'read') obj.isReadOnly = val;
                    // ---------------------------------------------------

                    if (key === 'id') obj.pid = val;
                    if (key === 'fill') { target.set('fill', val); if (obj.ctype === 'draw') Panel.dom.hasFill.checked = true; }
                    if (key === 'has-fill') { target.set('fill', val ? Panel.dom.fill.value : 'transparent'); Panel.dom.boxFill.style.opacity = val ? '1' : '0.3'; }
                    if (key === 'stroke') { target.set('stroke', val); if (obj.ctype === 'label') obj.set('fill', val); }
                    if (key === 'width') target.set('strokeWidth', parseInt(val));
                    if (key === 'opacity') { target.set('opacity', parseFloat(val)); Panel.dom.opacityVal.innerText = Math.round(val * 100) + '%'; }
                    if (key === 'bstyle') { obj.bStyle = val; if (val === 'none') target.set({ strokeDashArray: [4, 4], stroke: '#ccc' }); else if (val === 'underline') target.set({ strokeDashArray: [10, 5] }); else target.set({ strokeDashArray: null, stroke: Panel.dom.stroke.value }); }
                    if (key === 'checked') { obj.isChecked = val; if (obj.markObj) obj.markObj.set('opacity', val ? 1 : 0); }
                    if (key === 'grp') obj.grp = val; if (key === 'val') obj.val = val; if (key === 'opts') obj.opts = val;
                    if (key === 'fmt') {
                        obj.fmt = val;
                        if (val === 'number') { obj.tAlign = 'right'; }
                    }
                    if (key === 'textAlign') {
                        obj.tAlign = val;
                        if (obj.txtObj) obj.txtObj.set('textAlign', val);
                    }
                    if (key === 'dimW') {
                        const newW = parseInt(val);
                        if (newW > 0) {
                            if (Panel.ratioLocked) {
                                obj.scaleToWidth(newW);
                                obj.set('scaleY', obj.scaleX);
                                Panel.dom.dimH.value = Math.round(obj.getScaledHeight());
                            } else {
                                obj.scaleToWidth(newW);
                            }
                        }
                    }
                    if (key === 'dimH') {
                        const newH = parseInt(val);
                        if (newH > 0) {
                            if (Panel.ratioLocked) {
                                obj.scaleToHeight(newH);
                                obj.set('scaleX', obj.scaleY);
                                Panel.dom.dimW.value = Math.round(obj.getScaledWidth());
                            } else {
                                obj.scaleToHeight(newH);
                            }
                        }
                    }
                    // APPLY POS X/Y
                    if (key === 'posX') { obj.set('left', parseInt(val)); }
                    if (key === 'posY') { obj.set('top', parseInt(val)); }
                });
                State.canvas.requestRenderAll(); History.save();
            }
        };

        // --- LISTENERS (Indispensable pour que les cases réagissent) ---
        ['id', 'fill', 'stroke', 'width', 'opacity', 'bstyle', 'checked', 'grp', 'val', 'opts', 'has-fill', 'fmt', 'dimW', 'dimH', 'posX', 'posY', 'req', 'read'].forEach(k => {
            const el = document.getElementById(k === 'opts' ? 'p-opts' : (k === 'bstyle' ? 'p-bstyle' : (k === 'checked' ? 'p-checked' : (k === 'has-fill' ? 'p-has-fill' : (k === 'fmt' ? 'p-fmt' : (k === 'dimW' ? 'p-dim-w' : (k === 'dimH' ? 'p-dim-h' : (k === 'posX' ? 'p-pos-x' : (k === 'posY' ? 'p-pos-y' : (k === 'req' ? 'p-req' : (k === 'read' ? 'p-read' : 'p-' + k)))))))))));
            if (el) {
                el.addEventListener(el.type === 'checkbox' || el.tagName === 'SELECT' ? 'change' : 'input', e => Panel.apply(k, el.type === 'checkbox' ? e.target.checked : e.target.value));
                if (el.tagName === 'INPUT') {
                    el.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') el.blur();
                    });
                }
            }
        });
        ['id', 'fill', 'stroke', 'width', 'opacity', 'bstyle', 'checked', 'grp', 'val', 'opts', 'has-fill', 'fmt', 'dimW', 'dimH', 'posX', 'posY'].forEach(k => {
            const el = document.getElementById(k === 'opts' ? 'p-opts' : (k === 'bstyle' ? 'p-bstyle' : (k === 'checked' ? 'p-checked' : (k === 'has-fill' ? 'p-has-fill' : (k === 'fmt' ? 'p-fmt' : (k === 'dimW' ? 'p-dim-w' : (k === 'dimH' ? 'p-dim-h' : (k === 'posX' ? 'p-pos-x' : (k === 'posY' ? 'p-pos-y' : 'p-' + k)))))))));
            if (el) {
                el.addEventListener(el.type === 'checkbox' || el.tagName === 'SELECT' ? 'change' : 'input', e => Panel.apply(k, el.type === 'checkbox' ? e.target.checked : e.target.value));
                if (el.tagName === 'INPUT') {
                    el.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') el.blur();
                    });
                }
            }
        });
        App.toHex = (c) => { if (!c || c === 'transparent') return '#ffffff'; if (c.startsWith('#')) return c.slice(0, 7); return '#000000'; };

        const Exporter = {
            download: async () => {
                // 1. Sauvegarder pour figer l'état
                App.saveCurrentPage();

                const { PDFDocument, rgb, StandardFonts, TextAlignment } = PDFLib;
                let doc;

                if (State.pdfBytes) doc = await PDFDocument.load(State.pdfBytes);
                else doc = await PDFDocument.create();

                // --- A. CHARGEMENT DES POLICES STANDARD ---
                const helveticaFont = await doc.embedFont(StandardFonts.Helvetica);
                const helveticaBold = await doc.embedFont(StandardFonts.HelveticaBold);
                const timesFont = await doc.embedFont(StandardFonts.TimesRoman);
                const courierFont = await doc.embedFont(StandardFonts.Courier);

                // Helpers
                const toRgb = (hex) => {
                    if (!hex || !hex.startsWith('#')) return undefined;
                    return rgb(parseInt(hex.slice(1, 3), 16) / 255, parseInt(hex.slice(3, 5), 16) / 255, parseInt(hex.slice(5, 7), 16) / 255);
                };
                const getSafeId = (id, set) => { let n = id; let i = 1; while (set.has(n)) n = id + "_" + i++; set.add(n); return n; };
                const usedIds = new Set();

                // --- BOUCLE PAGES ---
                for (let i = 0; i < State.pages.length; i++) {
                    let page;
                    if (i < doc.getPageCount()) page = doc.getPages()[i];
                    else page = doc.addPage([595, 842]);

                    const pdfWidth = page.getWidth();
                    const pdfHeight = page.getHeight();
                    const form = doc.getForm();

                    const pageData = State.pages[i];
                    if (!pageData || !pageData.objects) continue;

                    // 1. D'ABORD, on cherche l'objet FOND pour se caler dessus
                    const bgRaw = pageData.objects.find(o => o.isBackground);
                    let bgLeft = 0, bgTop = 0, bgScaleW = 595;

                    if (bgRaw) {
                        await new Promise(resolve => {
                            fabric.util.enlivenObjects([bgRaw], (objs) => {
                                const bg = objs[0];
                                const p = bg.getPointByOrigin('left', 'top');
                                bgLeft = p.x;
                                bgTop = p.y;
                                bgScaleW = bg.getScaledWidth();
                                resolve();
                            });
                        });
                    } else {
                        bgScaleW = State.canvas.pageW || 595;
                    }

                    const ratio = pdfWidth / bgScaleW;

                    // 2. On traite les objets
                    await new Promise(resolve => {
                        fabric.util.enlivenObjects(pageData.objects, (fabricObjects) => {

                            for (const o of fabricObjects) {
                                // Ignore le fond et les objets non valides
                                if (!o.ctype && o.type !== 'group' && o.ctype !== 'draw' && o.ctype !== 'image' && o.ctype !== 'label') continue;
                                if (o.isBackground) continue;

                                // --- COORDONNÉES PRÉCISES ---
                                const p = o.getPointByOrigin('left', 'top');
                                const relX = p.x - bgLeft;
                                const relY = p.y - bgTop;

                                const finalW = o.getScaledWidth() * ratio;
                                const finalH = o.getScaledHeight() * ratio;
                                const finalX = relX * ratio;
                                const finalY = pdfHeight - (relY * ratio) - finalH;

                                const opts = { x: finalX, y: finalY, width: finalW, height: finalH };

                                // Extraction des sous-objets
                                let rect = o;
                                let textObj = null;
                                if (o.type === 'group' && o._objects && o._objects.length >= 1) {
                                    rect = o._objects[0];
                                    if (o._objects.length > 1) textObj = o._objects[1];
                                }

                                // --- 1. EXPORT LABELS (TEXTE) --- 
                                if (o.ctype === 'label') {
                                    const txt = o.text || "Texte";
                                    const fontSize = o.fontSize * ratio;

                                    // Choix de la police
                                    let fontToUse = helveticaFont;
                                    const fam = (o.fontFamily || "").toLowerCase();
                                    if (fam.includes('times')) fontToUse = timesFont;
                                    else if (fam.includes('courier')) fontToUse = courierFont;
                                    else if (fam.includes('arial') && (o.fontWeight === 'bold' || o.fontWeight > 500)) fontToUse = helveticaBold;

                                    // Calcul Y spécifique pour le texte (Baseline)
                                    const textY = pdfHeight - (relY * ratio) - (fontSize * 0.88);

                                    page.drawText(txt, {
                                        x: finalX,
                                        y: textY,
                                        size: fontSize,
                                        font: fontToUse,
                                        color: toRgb(o.fill) || rgb(0, 0, 0),
                                        opacity: o.opacity
                                    });
                                    continue;
                                }

                                // --- 2. EXPORT IMAGES ---
                                if (o.ctype === 'image' && o.srcObj) {
                                    (async () => {
                                        try {
                                            let img;
                                            if (o.srcObj.startsWith('data:image/png')) img = await doc.embedPng(o.srcObj);
                                            else img = await doc.embedJpg(o.srcObj);
                                            page.drawImage(img, { ...opts, opacity: o.opacity });
                                        } catch (e) { }
                                    })();
                                    continue;
                                }

                                // --- 3. EXPORT DESSINS ---
                                if (o.ctype === 'draw') {
                                    const op = {
                                        borderColor: toRgb(o.stroke),
                                        borderWidth: o.strokeWidth * ratio,
                                        color: o.fill !== 'transparent' ? toRgb(o.fill) : undefined,
                                        opacity: o.opacity
                                    };
                                    if (o.type === 'rect') page.drawRectangle({ ...opts, ...op });
                                    else if (o.type === 'ellipse') page.drawEllipse({ x: finalX + finalW / 2, y: finalY + finalH / 2, xScale: finalW / 2, yScale: finalH / 2, ...op });
                                    else if (o.type === 'line') {
                                        const lX1 = (o.left - bgLeft) * ratio;
                                        const lY1 = pdfHeight - ((o.top - bgTop) * ratio);
                                        const lX2 = (o.left + o.width - bgLeft) * ratio;
                                        const lY2 = pdfHeight - ((o.top + o.height - bgTop) * ratio);
                                        page.drawLine({ start: { x: lX1, y: lY1 }, end: { x: lX2, y: lY2 }, color: toRgb(o.stroke), thickness: o.strokeWidth * ratio });
                                    }
                                }

                                // --- 4. EXPORT INPUTS ---
                                else if (o.ctype) {
                                    const bg = (rect.fill && rect.fill !== 'transparent') ? toRgb(rect.fill) : undefined;
                                    const bc = toRgb(rect.stroke);
                                    const bw = (o.bStyle === 'none' || o.bStyle === 'underline') ? 0 : rect.strokeWidth * ratio;

                                    const formOpts = { ...opts, backgroundColor: bg, borderColor: bc, borderWidth: bw };
                                    const safeId = getSafeId(o.pid, usedIds);

                                    try {
                                        let f;

                                        if (o.ctype === 'textfield') {
                                            f = form.createTextField(safeId);
                                            if (textObj && textObj.text) f.setText(textObj.text);
                                            f.addToPage(page, formOpts);
                                            if (o.bStyle === 'underline') page.drawLine({ start: { x: finalX, y: finalY }, end: { x: finalX + finalW, y: finalY }, color: bc, thickness: 1 * ratio });
                                            if (o.tAlign === 'center') f.setAlignment(TextAlignment.Center);
                                            else if (o.tAlign === 'right') f.setAlignment(TextAlignment.Right);
                                            else f.setAlignment(TextAlignment.Left);
                                            if (o.fmt === 'date' && (!textObj || !textObj.text)) f.setText('JJ/MM/AAAA');
                                        }
                                        else if (o.ctype === 'textarea') {
                                            f = form.createTextField(safeId);
                                            f.enableMultiline();
                                            if (textObj && textObj.text) f.setText(textObj.text);
                                            f.addToPage(page, formOpts);
                                            if (o.tAlign === 'center') f.setAlignment(TextAlignment.Center);
                                            else if (o.tAlign === 'right') f.setAlignment(TextAlignment.Right);
                                        }
                                        else if (o.ctype === 'checkbox') {
                                            f = form.createCheckBox(safeId);
                                            f.addToPage(page, formOpts);
                                            if (o.isChecked) f.check();
                                        }
                                        else if (o.ctype === 'radio') {
                                            let g;
                                            try { g = form.getRadioGroup(o.grp); } catch { g = form.createRadioGroup(o.grp); }
                                            g.addOptionToPage(o.val, page, formOpts);
                                            if (o.isChecked) g.select(o.val);
                                            f = g;
                                        }
                                        else if (o.ctype === 'dropdown') {
                                            f = form.createDropdown(safeId);
                                            f.setOptions((o.opts || "").split('\n'));
                                            f.addToPage(page, formOpts);
                                        }

                                        // --- APPLIQUER OBLIGATOIRE / LECTURE SEULE ---
                                        if (f) {
                                            if (o.isRequired) f.setRequired(true);
                                            if (o.isReadOnly) f.enableReadOnly();
                                        }
                                        // --------------------------------------------

                                    } catch (e) { console.error(e); }
                                }
                            }
                            resolve();
                        });
                    });
                }

                // --- AJOUT DES MÉTADONNÉES PRO ---
                const title = document.getElementById('doc-title').value || "Formulaire";
                doc.setTitle(title);
                doc.setAuthor("Pdf Studio"); // Tu peux mettre ton nom ici
                doc.setCreator("Généré par Pdf Studio");
                doc.setProducer("Pdf Studio V1.0");
                // ----------------------------------

                const bytes = await doc.save();
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = (document.getElementById('doc-title').value || "doc") + ".pdf";
                link.click();
            }
        };
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

        document.getElementById('file-input').addEventListener('change', async e => {
            const f = e.target.files[0];
            if (!f) return;

            // UI : Petit loading (optionnel mais sympa)
            App.showModal("Chargement", "Importation du PDF en cours...");

            const ab = await f.arrayBuffer();
            State.pdfBytes = new Uint8Array(ab); // On garde le binaire pour l'export
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(new Blob([ab]))).promise;

            // RESET TOTAL
            State.pages = [];
            State.totalPages = pdf.numPages;
            State.currentPage = 0;

            // BOUCLE SUR CHAQUE PAGE
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const scale = 2.0; // Bonne qualité
                const vp = page.getViewport({ scale: scale });

                // Uniquement pour la page 1 : on définit la taille globale du canvas
                if (i === 1) {
                    State.canvas.pageW = vp.width;
                    State.canvas.pageH = vp.height;
                    App.resize();
                    const cx = (State.canvas.width / 2 - vp.width / 2);
                    const cy = 20;
                    State.canvas.pageOffset = { x: cx, y: cy };
                }

                // Rendu off-screen (canvas invisible)
                const c = document.createElement('canvas');
                c.width = vp.width;
                c.height = vp.height;
                await page.render({ canvasContext: c.getContext('2d'), viewport: vp }).promise;

                // Création de l'objet Image Fabric
                const img = new fabric.Image(c);
                img.set({
                    left: State.canvas.pageOffset.x,
                    top: State.canvas.pageOffset.y,
                    selectable: false, evented: false, hasControls: false,
                    lockMovementX: true, lockMovementY: true,
                    isBackground: true,
                    shadow: { color: 'rgba(0,0,0,0.1)', blur: 15 }
                });

                // CRÉATION DU JSON DE LA PAGE
                // On crée une "fausse" page qui contient juste cette image de fond pour l'instant
                // Note: On doit simuler la structure JSON de Fabric
                const pageJSON = {
                    version: "5.3.0",
                    objects: [img.toObject(customProps)]
                };

                State.pages.push(pageJSON);
            }

            // Terminé : On charge la page 0 (la première)
            App.closeModal();
            App.loadPage(0);

            // Reset de l'input pour pouvoir réimporter le même fichier si besoin
            e.target.value = '';
        });
    </script>
</body>

</html>
